<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于YOLOv5的电瓶车识别入门级项目记录</title>
      <link href="/%E7%AC%94%E8%AE%B0/yolov5/"/>
      <url>/%E7%AC%94%E8%AE%B0/yolov5/</url>
      
        <content type="html"><![CDATA[<p>一次基于YOLOv5的深度学习项目，在GPU服务器完成模型训练，在Windows 10下进行图像识别推理（C++）。</p><p>关键词：深度学习、YOLOv5、C++推演、TensorRT、OpenCV</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#%E9%9B%B6-%E5%89%8D%E8%A8%80">零 —— 前言</a></li><li><a href="#%E5%A3%B9-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87">壹 —— 环境准备</a></li><li><a href="#%E8%B4%B0-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">贰 —— 数据准备</a><ul><li><a href="#21-%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BB%93%E6%9E%84">2.1 数据集结构</a></li><li><a href="#22-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E9%9B%86">2.2 处理数据集</a></li></ul></li><li><a href="#%E5%8F%81-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%8F%8A%E5%88%86%E6%9E%90">叁 —— 模型训练及分析</a><ul><li><a href="#31-%E9%83%A8%E7%BD%B2yolov5">3.1 部署YOLOv5</a><ul><li><a href="#311-%E4%BD%BF%E7%94%A8%E7%A4%BE%E5%8C%BA%E9%95%9C%E5%83%8F%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2yolov5">3.1.1 使用社区镜像自动部署YOLOv5</a></li><li><a href="#312-%E6%89%8B%E5%8A%A8%E9%83%A8%E7%BD%B2yolov5">3.1.2 手动部署YOLOv5</a></li></ul></li><li><a href="#32-%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE">3.2 上传数据</a></li><li><a href="#33-%E9%85%8D%E7%BD%AE%E8%AE%AD%E7%BB%83%E5%8F%82%E6%95%B0">3.3 配置训练参数</a><ul><li><a href="#331-%E4%BF%AE%E6%94%B9trainpy%E6%96%87%E4%BB%B6">3.3.1 修改train.py文件</a></li><li><a href="#332-%E4%BF%AE%E6%94%B9valpy%E6%96%87%E4%BB%B6">3.3.2 修改val.py文件</a></li><li><a href="#333-%E4%BF%AE%E6%94%B9%E6%A8%A1%E5%9E%8B%E9%85%8D%E7%BD%AE">3.3.3 修改模型配置</a></li></ul></li><li><a href="#34-%E8%AE%AD%E7%BB%83%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98">3.4 训练可能出现的问题</a></li><li><a href="#35-%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90">3.5 训练结果分析</a><ul><li><a href="#351-%E4%BF%9D%E5%AD%98%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C">3.5.1 保存训练结果</a></li><li><a href="#352-%E6%9B%B2%E7%BA%BF%E7%B1%BB%E5%88%86%E6%9E%90">3.5.2 曲线类分析</a></li><li><a href="#353-%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90">3.5.3 混淆矩阵分析</a></li><li><a href="#354-%E6%A0%87%E7%AD%BE%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90">3.5.4 标签相关分析</a></li><li><a href="#355-%E8%AE%AD%E7%BB%83%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90">3.5.5 训练验证结果分析</a></li><li><a href="#356-%E5%85%B6%E4%BD%99%E5%88%86%E6%9E%90">3.5.6 其余分析</a></li></ul></li></ul></li><li><a href="#%E8%82%86-%E6%A8%A1%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%A4%84%E7%90%86%E5%9F%BA%E4%BA%8Eonnx%E6%96%87%E4%BB%B6%E6%8E%A8%E7%90%86">肆 —— 模型转化处理（基于.onnx文件推理）</a><ul><li><a href="#41-%E8%BD%AC%E5%8C%96%E4%B8%BAonnx%E6%96%87%E4%BB%B6">4.1 转化为.onnx文件</a></li><li><a href="#42-%E9%80%9A%E8%BF%87c%E5%88%A9%E7%94%A8onnx%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%A8%E7%90%86%E8%AF%86%E5%88%AB">4.2 通过C++利用.onnx文件进行推理识别</a><ul><li><a href="#421-%E8%AE%B0%E5%BD%95%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">4.2.1 记录处理的数据结构</a></li><li><a href="#422-%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB%E5%87%BD%E6%95%B0">4.2.2 检测识别函数</a></li><li><a href="#423-%E9%A2%84%E6%B5%8B%E7%94%BB%E6%A1%86%E5%87%BD%E6%95%B0">4.2.3 预测画框函数</a></li><li><a href="#424-%E4%B8%BB%E5%87%BD%E6%95%B0">4.2.4 主函数</a></li></ul></li></ul></li><li><a href="#%E4%BC%8D-%E6%A8%A1%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%8A%A0%E9%80%9F%E5%A4%84%E7%90%86%E5%9F%BA%E4%BA%8Eengine%E6%96%87%E4%BB%B6%E6%8E%A8%E7%90%86">伍 —— 模型转化加速处理（基于.engine文件推理）</a><ul><li><a href="#51-%E8%BD%AC%E5%8C%96%E4%B8%BAengine%E6%96%87%E4%BB%B6">5.1 转化为.engine文件</a><ul><li><a href="#511-%E9%80%9A%E8%BF%87yolov5%E8%87%AA%E5%B8%A6%E7%9A%84exportpy%E8%BD%AC%E6%8D%A2">5.1.1 通过YOLOv5自带的export.py转换</a></li><li><a href="#512-%E9%80%9A%E8%BF%87%E8%87%AA%E5%B7%B1%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E7%9A%84tensorrt%E8%BD%AC%E6%8D%A2">5.1.2 通过自己下载安装的TensorRT转换</a></li></ul></li><li><a href="#52-%E9%80%9A%E8%BF%87c%E5%88%A9%E7%94%A8engine%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%A8%E7%90%86%E8%AF%86%E5%88%AB">5.2 通过C++利用.engine文件进行推理识别</a><ul><li><a href="#521-%E8%AE%B0%E5%BD%95%E8%AF%86%E5%88%AB%E7%BB%93%E6%9E%9C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">5.2.1 记录识别结果的数据结构</a></li><li><a href="#522-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97">5.2.2 日志模块</a></li><li><a href="#523-%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E6%A8%A1%E5%9D%97">5.2.3 计算内存大小模块</a></li><li><a href="#524-%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9D%97">5.2.4 检测识别模块</a></li><li><a href="#525-%E4%B8%BB%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1">5.2.5 主函数设计</a></li></ul></li></ul></li><li><a href="#%E9%99%86-%E6%89%93%E5%8C%85%E8%BD%AF%E4%BB%B6">陆 —— 打包软件</a><ul><li><a href="#61-%E5%9F%BA%E4%BA%8Eonnx%E6%96%87%E4%BB%B6%E5%9B%BE%E5%83%8F%E6%8E%A8%E7%90%86%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85">6.1 基于.onnx文件图像推理程序打包</a></li><li><a href="#62-%E5%9F%BA%E4%BA%8Eengine%E6%96%87%E4%BB%B6%E5%9B%BE%E5%83%8F%E6%8E%A8%E7%90%86%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85">6.2 基于.engine文件图像推理程序打包</a></li><li><a href="#63-%E6%95%B4%E4%BD%93%E6%89%93%E5%8C%85">6.3 整体打包</a></li></ul></li><li><a href="#%E6%9F%92-%E6%80%BB%E7%BB%93%E5%8F%8A%E5%90%8E%E8%AF%9D">柒 —— 总结及后话</a></li></ul><!-- tocstop --><h1><span id="零-前言">零 —— 前言</span></h1><p>此篇博客是我亲手做的一次项目记录（2023.7.3~2023.7.14），在GPU服务器完成基于YOLOv5的模型训练，在Windows 10下将训练得到的权重文件作基本处理转化为.onnx文件和.engine文件分别进行C++下的推理，最后并做了简单界面，效果如下图。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_chengguo.jpg" alt="成品展示"></p><p>本人学术不精，此篇博客可能会因为一些深度学习上的知识不熟悉而造成的表达错误，此博客只是记录此次项目过程，并尽力使其有参考性、使其可复刻。</p><p>项目代码放在<a href="https://gitee.com/fingsinz/ele-bicycle-detection/">码云Gitee仓库</a></p><p><br><br><br></p><h1><span id="壹-环境准备">壹 —— 环境准备</span></h1><p>本项目需要的环境：</p><ul><li><u>Python环境</u>：YOLOv5所需</li><li><u>CUDA环境</u>：调用显卡进行显存加速</li><li><u>OpenCV环境</u>：进行图像处理</li></ul><p>我的环境是CUDA12.0，OpenCV4.5.2，训练所用Python3.8.10，本机Windows 10所用Python3.11.4。</p><p>下载安装CUDA可参考<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/5/#more">这篇博客</a><br>配置OpenCV和CUDA环境可参考<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/9/#more">这篇博客</a>。</p><p><br><br><br></p><h1><span id="贰-数据准备">贰 —— 数据准备</span></h1><h2><span id="21-数据集结构">2.1 数据集结构</span></h2><p>本项目需要的数据集（不公开）：</p><ul><li><u>校园内电瓶车463张</u>：435张用于训练，28张用于验证</li></ul><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_dataset.jpg" alt="数据集文件结构"></p><p>这个数量上和比例上并不良好，也没有设测试集，建议照片尽量多，并按8:1:1的比例分配在训练集、验证集和测试集。</p><ul><li>训练集：用于YOLOv5模型调试神经网络；相当于学生的课本，学生根据课本里的内容来掌握知识。</li><li>验证集：验证集用来查看训练效果；相当于作业，通过作业可以知道不同学生学习情况、进步的速度快慢。</li><li>测试集：用来测试网络的实际学习能力；相当于考试，考的题是平常都没有见过，考察学生举一反三的能力。</li></ul><p>数据集的文件结构应如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dataset</span><br><span class="line">|---images</span><br><span class="line">|   |---train</span><br><span class="line">|   |---val</span><br><span class="line">|   |---test</span><br><span class="line">|---labels</span><br><span class="line">|   |---train</span><br><span class="line">|   |---val</span><br><span class="line">|   |---test</span><br></pre></td></tr></table></figure><h2><span id="22-处理数据集">2.2 处理数据集</span></h2><p>使用<a href="https://zhuanlan.zhihu.com/p/550021453">LabelImg</a>进行对图片标记。或自行搜索使用安装教程。</p><p>打标签时，选择YOLO格式，生成的是.txt文件，用于模型训练。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_labeling.jpg" alt="使用LabelImg工具对数据集进行打标签"></p><p>打完标签后，在labels文件夹下的train文件夹、val文件夹和test文件夹会生成一个对应images各文件夹的.txt文件，还会生成一个classes.txt文件。故labels文件夹下的各个文件夹会多一个文件。</p><p>最后命名此数据集为<code>eleb</code>。</p><p><br><br><br></p><h1><span id="叁-模型训练及分析">叁 —— 模型训练及分析</span></h1><h2><span id="31-部署yolov5">3.1 部署YOLOv5</span></h2><p>训练模型需要在专业的GPU加速服务器上运行， <strong>请勿尝试在自己的电脑上跑模型</strong>。</p><p>挑选GPU服务器可参考<a href="https://fingsinz.space/%E5%85%B6%E4%BB%96%E5%88%86%E4%BA%AB/gpuserver/#more">这篇博客</a>。</p><h3><span id="311-使用社区镜像自动部署yolov5">3.1.1 使用社区镜像自动部署YOLOv5</span></h3><p>我使用的是AutoDL算力云，其社区镜像默认安装了YOLOv5。在算力市场中寻找合适的地区，GPU型号尽量好，按量计费租用。我此次租用的是：<u>芜湖区-RTX3090</u>，1.58r&#x2F;h，跑四百多张图片估计是四个小时左右。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_ser.jpg" alt="租用GPU服务器"></p><p>租用实例后开机，我选择JupyterLab的方式连接服务器。为了方便，我把默认的<code>yolov5</code>文件夹转到（剪贴粘贴）数据盘。有文件如下：</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_yolov5.jpg" alt="yolov5文件夹"></p><h3><span id="312-手动部署yolov5">3.1.2 手动部署YOLOv5</span></h3><p>建议租用Ubuntu系统，在有Python、Git等环境下，服务器新建文件夹，使用git命令克隆<a href="https://github.com/ultralytics/yolov5">YOLOv5仓库</a>或者网页下载压缩包解压部署。如果有缺少的库可以<code>pip install</code>安装。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/yolov5.git</span><br></pre></td></tr></table></figure><p>至此YOLOv5部署完毕。</p><h2><span id="32-上传数据">3.2 上传数据</span></h2><p>将我们准备好的数据集压缩成.zip压缩文件，上传到<code>yolov5/data/eleb</code>（数据集根目录，新建文件夹eleb），由于文件比较大，上传速度也比较慢，比较费时间，也可以在服务器上创建文件夹后多选文件上传。</p><p>在终端上进入<code>yolov5/data</code>运行下面的指令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip xx.zip</span><br></pre></td></tr></table></figure><p>如果提示有包没下载就去下载。</p><p>解压后，复制data文件夹下的<code>coco.yaml</code>，并命名为数据集的名字。在上面我将数据集名字命名为<code>eleb</code>，故复制并命名为<code>eleb.yaml</code>。</p><p>将eleb.yaml编辑如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练集、验证集、测试集路径设置</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">./data/eleb</span>    <span class="comment"># 数据集根目录</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">images/train</span>  <span class="comment"># 训练集目录</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">images/val</span>      <span class="comment"># 验证集目录</span></span><br><span class="line"><span class="attr">test:</span>                <span class="comment"># 测试集目录，此处没设立</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签的类，此项目只有一个类</span></span><br><span class="line"><span class="attr">names:</span></span><br><span class="line">  <span class="attr">0:</span> <span class="string">elebike</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Download script/URL (optional) 不管，默认</span></span><br><span class="line"><span class="attr">download:</span> <span class="comment">#https://ultralytics.com/assets/coco128-seg.zip</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="33-配置训练参数">3.3 配置训练参数</span></h2><h3><span id="331-修改trainpy文件">3.3.1 修改train.py文件</span></h3><p><strong>回到<code>yolov5/</code>目录，找到<code>train.py</code>文件打开，找到<code>parse_opt()</code>函数，更改部分参数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># model.yaml是模型配置文件，在文件夹yolov5/models中，此处我使用yolov5l.yaml</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--cfg&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;yolov5l.yaml path&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置数据集的yaml文件，即eleb.yaml</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--data&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=ROOT / <span class="string">&#x27;data/eleb.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;dataset.yaml path&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置训练轮数，默认300轮</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">300</span>, <span class="built_in">help</span>=<span class="string">&#x27;total training epochs&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置训练时所有GPU的总批量大小，为-1则自动</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--batch-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">16</span>, <span class="built_in">help</span>=<span class="string">&#x27;所有GPU的总批量大小, -1 for autobatch&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置训练输入的照片大小，默认为640 × 640</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--imgsz&#x27;</span>, <span class="string">&#x27;--img&#x27;</span>, <span class="string">&#x27;--img-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">640</span>, <span class="built_in">help</span>=<span class="string">&#x27;train, val image size (pixels)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面保持默认即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ……</span></span><br></pre></td></tr></table></figure><h3><span id="332-修改valpy文件">3.3.2 修改val.py文件</span></h3><p><strong>回到<code>yolov5/</code>目录，找到<code>val.py</code>文件打开，找到<code>parse_opt()</code>函数，更改部分参数：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置数据集的yaml文件，即eleb.yaml</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--data&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=ROOT / <span class="string">&#x27;data/eleb.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;dataset.yaml path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ……</span></span><br></pre></td></tr></table></figure><h3><span id="333-修改模型配置">3.3.3 修改模型配置</span></h3><p> <strong>（3）进入<code>yolov5/models/</code>目录，找到<code>train.py</code>设置的模型配置.yaml文件，我这里使用的是yolov5l模型，打开yolov5l.yaml，修改<code>nc</code>（分类数），此项目修改为1：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ……</span></span><br><span class="line"><span class="attr">nc:</span> <span class="number">1</span>  <span class="comment"># number of classes</span></span><br><span class="line"><span class="attr">depth_multiple:</span> <span class="number">1.0</span>  <span class="comment"># model depth multiple</span></span><br><span class="line"><span class="attr">width_multiple:</span> <span class="number">1.0</span>  <span class="comment"># layer channel multiple</span></span><br><span class="line"><span class="attr">anchors:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">10</span>,<span class="number">13</span>, <span class="number">16</span>,<span class="number">30</span>, <span class="number">33</span>,<span class="number">23</span>]  <span class="comment"># P3/8</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">30</span>,<span class="number">61</span>, <span class="number">62</span>,<span class="number">45</span>, <span class="number">59</span>,<span class="number">119</span>]  <span class="comment"># P4/16</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">116</span>,<span class="number">90</span>, <span class="number">156</span>,<span class="number">198</span>, <span class="number">373</span>,<span class="number">326</span>]  <span class="comment"># P5/32</span></span><br><span class="line"><span class="comment"># ……</span></span><br></pre></td></tr></table></figure><p>至此训练参数配置完毕。</p><p>启动终端，进入yolov5文件夹，我这里是进入<code>autodl-tmp/yolov5/</code>，输入命令启动训练：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py</span><br></pre></td></tr></table></figure><p>如下图即开始训练</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_train2.jpg" alt="训练开始"></p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_train.jpg" alt="训练结束"></p><h2><span id="34-训练可能出现的问题">3.4 训练可能出现的问题</span></h2><p> 如果出现训练过程长时间的<code>R</code>和<code>P</code>值为<code>0</code>或者<code>val/box_loss</code>和<code>val/obj_loss</code>为<code>nan</code>的情况，参考<a href="https://blog.csdn.net/weixin_55249340/article/details/125855686">此篇博客</a>。</p><p>如果仍不能解决，可以考虑重新手动部署YOLOv5，接着修改参数运行train.py启动训练，如果缺少库就pip install安装。</p><h2><span id="35-训练结果分析">3.5 训练结果分析</span></h2><p>等待训练结束，在 <code>yolov5/runs/train</code> 文件夹就存放在训练的数据，其中weights文件夹中还存放着此次训练的权重文件，用于后续推理。</p><h3><span id="351-保存训练结果">3.5.1 保存训练结果</span></h3><p>在训练结果文件夹（我的是<code>runs/train/exp2</code>）中新建.py文件，输入下面代码，接着使用终端进入<code>runs/train/exp2</code>，使用命令<code>python save.py</code>可以变成压缩包，下载压缩包即下载全部训练结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursive_files</span>(<span class="params">dir_name=<span class="string">&#x27;.&#x27;</span>, ignore=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">for</span> dir_name,subdirs,files <span class="keyword">in</span> os.walk(dir_name):</span><br><span class="line">        <span class="keyword">if</span> ignore <span class="keyword">and</span> os.path.basename(dir_name) <span class="keyword">in</span> ignore: </span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> ignore <span class="keyword">and</span> file_name <span class="keyword">in</span> ignore:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> os.path.join(dir_name, file_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_tar_file</span>(<span class="params">dir_name=<span class="string">&#x27;.&#x27;</span>, tar_file_name=<span class="string">&#x27;tarfile.tar&#x27;</span>, ignore=<span class="literal">None</span></span>):</span><br><span class="line">    tar = tarfile.<span class="built_in">open</span>(tar_file_name, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> recursive_files(dir_name, ignore):</span><br><span class="line">        tar.add(file_name)</span><br><span class="line"></span><br><span class="line">    tar.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dir_name = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">tar_file_name = <span class="string">&#x27;train.tar&#x27;</span></span><br><span class="line">ignore = &#123;<span class="string">&#x27;.ipynb_checkpoints&#x27;</span>, <span class="string">&#x27;__pycache__&#x27;</span>, tar_file_name&#125;</span><br><span class="line">make_tar_file(dir_name, tar_file_name, ignore)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将训练结果下载到电脑上，解压有如下文件：</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_results.jpg"></p><h3><span id="352-曲线类分析">3.5.2 曲线类分析</span></h3><ul><li>P_curve：准确率Precision和置信度Confidence的关系图，当设置某置信度时对应某个类别的识别准确率。随着置信度设置越高，某个类别识别准确率越高。</li></ul><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_P_curve.png" alt="P曲线"></p><ul><li>R_curve：召回率Recall和置信度Confidence的关系图，当设置某置信度时对应某个类别的查找完全的概率。随着置信度设置越高，某个类别能被查找完全的概率越低。</li></ul><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_R_curve.png" alt="R曲线"></p><ul><li>PR_cruve：准确率Precision和召回率Recall的关系图，尽可能希望准确率高的同时召回率也高，即曲线与坐标轴围成的面积越大，模型越好。</li></ul><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_PR_curve.png" alt="PR曲线"></p><ul><li>F1_curve：精确率和召回率的调和平均数，某个分类对应F1的值，1为最好，0为最差。</li></ul><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_F1_curve.png" alt="F1曲线"></p><h3><span id="353-混淆矩阵分析">3.5.3 混淆矩阵分析</span></h3><ul><li>confusion_matrix：矩阵的每一列代表一个类的实例预测，而每一行表示一个实际的类的实例，可以方便地看出机器是否将两个不同的类混淆。</li></ul><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_confusion_matrix.png" alt="混淆矩阵"></p><h3><span id="354-标签相关分析">3.5.4 标签相关分析</span></h3><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_labels.jpg" alt="标签相关labels.jpg"></p><ul><li>左上角为训练集的数据量；</li><li>右上角是框的尺寸和数量；</li><li>左下角是打标签目标框中心点位置，由图可知中心点多为中心偏上。</li><li>右下角是打标签目标框的高和宽，由图可知多聚集在0.2×0.2</li></ul><h3><span id="355-训练验证结果分析">3.5.5 训练验证结果分析</span></h3><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_results.png" alt="results.png"></p><p>前面加<code>train</code>为训练集的情况，加<code>val</code>表示验证集的情况。</p><ul><li><p>定位损失box_loss：预测框与标定框之间的误差。</p></li><li><p>置信度损失obj_loss：计算网络的置信度。</p></li><li><p>分类损失cls_loss：计算锚框与对应标定分类是否正确。</p></li><li><p>precision：模型精度。</p></li><li><p>recall：真实为positive的准确率，即正样本有多少被找出来了。</p></li><li><p>mAP：Mean Average Precision，均值平均精度，mAP_0.5表示阈值大于0.5的平均mAP。</p></li><li><p>mAP_0.5:0.95：表示不同<a href="https://blog.csdn.net/gaoyu1253401563/article/details/86484851">IoU</a>阈值（从0.5到0.95，步长0.05）上的平均mAP。</p></li></ul><h3><span id="356-其余分析">3.5.6 其余分析</span></h3><ul><li><p><code>train_batch</code>、 <code>val_batch</code>表示一批次读取的照片数。</p></li><li><p><code>results.csv</code>存放着每轮训练的数据。</p></li></ul><p><br><br><br></p><h1><span id="肆-模型转化处理基于onnx文件推理">肆 —— 模型转化处理（基于.onnx文件推理）</span></h1><h2><span id="41-转化为onnx文件">4.1 转化为.onnx文件</span></h2><p>将我们的.pt文件经过服务器上YOLOv5自带的<code>export.py</code>处理后即可得到.onnx文件。即下面的命令格式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python export.py --weights yolov5s.pt --include onnx</span><br></pre></td></tr></table></figure><p>我输入的是（位于yolov5文件夹）：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python export.py --weights runs/train/exp2/weights/best.pt --include onnx</span><br></pre></td></tr></table></figure><h2><span id="42-通过c利用onnx文件进行推理识别">4.2 通过C++利用.onnx文件进行推理识别</span></h2><h3><span id="421-记录处理的数据结构">4.2.1 记录处理的数据结构</span></h3><p>将置信度阈值<code>confThreshold</code>、NMS非极大值抑制阈值<code>nmsThreshold</code>、目标置信度阈值<code>objThreshold</code>和识别模型路径<code>modelpath</code>打包成结构体，用于识别时参数的配置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义配置结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Configuration</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">float</span> confThreshold; <span class="comment">// Confidence threshold</span></span><br><span class="line"><span class="type">float</span> nmsThreshold;  <span class="comment">// Non-maximum suppression threshold</span></span><br><span class="line"><span class="type">float</span> objThreshold;  <span class="comment">// Object Confidence threshold</span></span><br><span class="line">string modelpath;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建<code>YOLOv5</code>类，其成员变量有置信度阈值<code>confThreshold</code>、NMS非极大值抑制阈值<code>nmsThreshold</code>、目标置信度阈值<code>objThreshold</code>，以及输入图片宽度<code>inpWidth</code>、输入图片高度<code>inpHeight</code>两个照片参数，识别种类数<code>num_classes</code>，类名<code>classes</code>；</p><p>主要函数为检测函数<code>detect</code>，辅助函数为预测画框函数<code>drawPred</code>和调整图片大小函数<code>resize_image</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOLOv5</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">YOLOv5</span>(Configuration config, <span class="type">bool</span> isCuda);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">(Mat &amp;frame)</span></span>;  <span class="comment">// 检测函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">float</span> confThreshold;</span><br><span class="line"><span class="type">float</span> nmsThreshold;</span><br><span class="line"><span class="type">float</span> objThreshold;</span><br><span class="line"><span class="type">int</span> inpWidth;</span><br><span class="line"><span class="type">int</span> inpHeight;</span><br><span class="line"><span class="type">int</span> num_classes;</span><br><span class="line">string classes[<span class="number">1</span>] = &#123; <span class="string">&quot;eleb&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//vector&lt;string&gt; class_names;</span></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> keep_ratio = <span class="literal">true</span>;</span><br><span class="line">Net net;   <span class="comment">// dnn里的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawPred</span><span class="params">(<span class="type">float</span> conf, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, Mat &amp;frame, <span class="type">int</span> classid)</span></span>;</span><br><span class="line"><span class="function">Mat <span class="title">resize_image</span><span class="params">(Mat srcimg, <span class="type">int</span> *newh, <span class="type">int</span> *neww, <span class="type">int</span> *top, <span class="type">int</span> *left)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="422-检测识别函数">4.2.2 检测识别函数</span></h3><ol><li>进行预处理：对输入图像（帧）进行大小调整和归一化处理，以便为模型做准备。调整后的图像会被转换为Blob，一个具有NCHW 维度（图像数、通道数、高度、宽度）的 4D 矩阵。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat dstimg = <span class="keyword">this</span>-&gt;<span class="built_in">resize_image</span>(frame, &amp;newh, &amp;neww, &amp;padh, &amp;padw);</span><br><span class="line">Mat blob = <span class="built_in">blobFromImage</span>(dstimg, <span class="number">1</span> / <span class="number">255.0</span>, <span class="built_in">Size</span>(<span class="keyword">this</span>-&gt;inpWidth, <span class="keyword">this</span>-&gt;inpHeight), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;net.<span class="built_in">setInput</span>(blob);</span><br></pre></td></tr></table></figure><ol start="2"><li>模型推理：在Blob上运行模型以获得输出，即边界框和类别概率列表。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Mat&gt; outs;</span><br><span class="line"><span class="keyword">this</span>-&gt;net.forward(outs, <span class="keyword">this</span>-&gt;net.<span class="built_in">getUnconnectedOutLayersNames</span>());</span><br></pre></td></tr></table></figure><ol start="3"><li>进行后处理：如果输出超过2维，则会对其进行重塑。对于每个边界框，它会检查对象的置信度是否高于阈值。计算最大类得分，同时检查其是否高于置信度阈值。如果超过了，就会保存边界框、置信度和类ID。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_proposal; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (obj_conf &gt; <span class="keyword">this</span>-&gt;objThreshold)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (max_class_socre &gt; <span class="keyword">this</span>-&gt;confThreshold)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            confidences.<span class="built_in">push_back</span>((<span class="type">float</span>) max_class_socre);</span><br><span class="line">            boxes.<span class="built_in">push_back</span>(<span class="built_in">Rect</span>(left, top, (<span class="type">int</span>) (w * ratiow), (<span class="type">int</span>) (h * ratioh)));</span><br><span class="line">            classIds.<span class="built_in">push_back</span>(class_idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>非最大值抑制 (NMS)：NMS用于移除重叠的边界框。剩余的边界框在原始图像上绘制。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; indices;</span><br><span class="line">dnn::<span class="built_in">NMSBoxes</span>(boxes, confidences, <span class="keyword">this</span>-&gt;confThreshold, <span class="keyword">this</span>-&gt;nmsThreshold, indices);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; indices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">drawPred</span>(confidences[idx], box.x, box.y, box.x + box.width, box.y + box.height, frame, classIds[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="423-预测画框函数">4.2.3 预测画框函数</span></h3><p>预测画框函数用于将预测函数所得到的目标区域，经OpenCV的工具在图片上绘制出方框。首先传入的参数有置信度，图片的四个角落点，Mat类型图片和类id，接着借助OpenCV的<code>rectangle</code>函数和<code>putText</code>函数绘制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制预测目标的边界框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">YOLOv5::drawPred</span><span class="params">(<span class="type">float</span> conf, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, Mat &amp;frame, <span class="type">int</span> classid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 绘制一个显示边界框的矩形</span></span><br><span class="line"><span class="built_in">rectangle</span>(frame, <span class="built_in">Point</span>(left, top), <span class="built_in">Point</span>(right, bottom), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到目标的类名和置信度</span></span><br><span class="line">string label = cv::format(<span class="string">&quot;%.2f&quot;</span>, conf);</span><br><span class="line">label = <span class="keyword">this</span>-&gt;classes[classid] + <span class="string">&quot;:&quot;</span> + label;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制目标的类名和置信度文本</span></span><br><span class="line"><span class="type">int</span> baseLine;</span><br><span class="line">Size labelSize = <span class="built_in">getTextSize</span>(label, FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span>, <span class="number">1</span>, &amp;baseLine);</span><br><span class="line">top = <span class="built_in">max</span>(top, labelSize.height);</span><br><span class="line"><span class="built_in">putText</span>(frame, label, <span class="built_in">Point</span>(left, top), FONT_HERSHEY_SIMPLEX, <span class="number">0.75</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="424-主函数">4.2.4 主函数</span></h3><p>本程序通过<code>main</code>函数的参数进行传参。如C&#x2F;C++语言语法， <code>argc</code> 是argument count的缩写，表示传入main函数中的参数个数，包括这个程序本身； <code>argv</code> 是 argument vector的缩写，表示传入 <code>main</code> 函数中的参数列表，其中 <code>argv[0]</code> 表示这个程序的名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//yolov5-onnx.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Run like this:\n    &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; yolov5s.onnx input.jpg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Configuration yolo_nets = &#123; <span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.3</span>, argv[<span class="number">1</span>] &#125;; <span class="comment">// 初始化数据</span></span><br><span class="line"><span class="function">YOLOv5 <span class="title">yolo_model</span><span class="params">(yolo_nets, <span class="literal">false</span>)</span></span>;</span><br><span class="line">Mat srcimg = <span class="built_in">imread</span>(argv[<span class="number">2</span>]);  <span class="comment">// 读入图片</span></span><br><span class="line">yolo_model.<span class="built_in">detect</span>(srcimg);     <span class="comment">// 进行推理</span></span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;result.jpg&quot;</span>, srcimg); <span class="comment">// 输出图片</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以当调用该程序时，只需在命令提示符的当前目录下，输入指令格式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yolov5-onnx.exe best.onnx input.jpg</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1><span id="伍-模型转化加速处理基于engine文件推理">伍 —— 模型转化加速处理（基于.engine文件推理）</span></h1><h2><span id="51-转化为engine文件">5.1 转化为.engine文件</span></h2><h3><span id="511-通过yolov5自带的exportpy转换">5.1.1 通过YOLOv5自带的export.py转换</span></h3><p>将我们的.pt文件经过服务器上YOLOv5自带的<code>export.py</code>处理后即可得到.engine文件（可能会自动下载TensorRT）。即下面的命令格式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python export.py --weights yolov5s.pt --include engine</span><br></pre></td></tr></table></figure><p>我输入的是（位于yolov5文件夹）：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python export.py --weights runs/train/exp2/weights/best.pt --include engine</span><br></pre></td></tr></table></figure><h3><span id="512-通过自己下载安装的tensorrt转换">5.1.2 通过自己下载安装的TensorRT转换</span></h3><p>在<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/5/#more">安装TensorRT</a>后，在TensorRT文件夹下有一个名为 <code>bin</code> 的文件夹，里面存在一个<code>trtexec.exe</code>文件。可以通过这个文件进行文件转换。在 <code>bin</code> 目录启动命令提示符，命令格式如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trtexec --onnx=best.onnx --saveEngine=best.engine</span><br></pre></td></tr></table></figure><h2><span id="52-通过c利用engine文件进行推理识别">5.2 通过C++利用.engine文件进行推理识别</span></h2><h3><span id="521-记录识别结果的数据结构">5.2.1 记录识别结果的数据结构</span></h3><p>一个记录识别结果的结构体，包括检测物体置信度 <code>score</code>，目标预测框 <code>box</code> 和类ID <code>class_id</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> score;</span><br><span class="line">cv::Rect box;</span><br><span class="line"><span class="type">int</span> class_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="522-日志模块">5.2.2 日志模块</span></h3><p>在构建TensorRT Runtime时需要作为参数传入。日志模块必须继承自<code>nvinfer1::ILogger</code>类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TensorRT需要日志</span></span><br><span class="line"><span class="comment">// 参考: https://github.com/cyrusbehr/tensorrt-cpp-api</span></span><br><span class="line"><span class="keyword">using</span> Severity = nvinfer1::ILogger::Severity;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> : <span class="keyword">public</span> nvinfer1::ILogger</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(Severity severity, <span class="type">const</span> <span class="type">char</span> *msg)</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(Severity severity, <span class="type">const</span> <span class="type">char</span> *msg)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (severity &lt;= Severity::kWARNING)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger logger;</span><br></pre></td></tr></table></figure><h3><span id="523-计算内存大小模块">5.2.3 计算内存大小模块</span></h3><p>一个计算内存大小的辅助函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">get_memory_size</span><span class="params">(<span class="type">const</span> nvinfer1::Dims &amp;dims, <span class="type">const</span> <span class="type">int32_t</span> elem_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">accumulate</span>(dims.d, dims.d + dims.nbDims, <span class="number">1</span>, std::<span class="built_in">multiplies</span>&lt;<span class="type">int64_t</span>&gt;()) * <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(elem_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="524-检测识别模块">5.2.4 检测识别模块</span></h3><p>基于.engine文件的推理识别涉及到显卡的调用，故需用到CUDA的Context。</p><p>CUDA的Context是由CUDA驱动程序创建的数据结构，包含执行CUDA操作所需的所有信息，如设备代码、数据以及线程、内存和硬件设置等资源。每个线程都有一个当前Context，该线程上的所有CUDA操作都在该Context中执行。</p><ol><li>初始化YOLOv5模型</li></ol><ul><li>首先从<code>engine_file_path</code>指定的文件中加载TensorRT引擎。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取TensorRT引擎</span></span><br><span class="line"><span class="function">std::ifstream <span class="title">engine_file</span><span class="params">(engine_file_path, std::ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (engine_file.<span class="built_in">fail</span>())</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to read model file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">engine_file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ifstream::end);</span><br><span class="line"><span class="keyword">auto</span> fsize = engine_file.<span class="built_in">tellg</span>();</span><br><span class="line">engine_file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ifstream::beg);</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">engineData</span><span class="params">(fsize)</span></span>;</span><br><span class="line">engine_file.<span class="built_in">read</span>(engineData.<span class="built_in">data</span>(), fsize);</span><br></pre></td></tr></table></figure><ul><li>其次，推演运行时 <code>nvinfer1::IRuntime</code> 是一切资源的源头，是第一个需要被初始化的对象，注意运行时的初始化需要将辅助模块中定义好的 <code>logger</code> 作为传入参数。同时这段代码使用 <code>unique_ptr</code> 来跟踪初始化后的运行时对象。引擎 <code>nvinfer1::ICudaEngine</code> 存储了模型的权重参数，它的初始化分2步：首先将模型文件读入内存，然后使用运行时的 <code>deserializeCudaEngine</code> 方法初始化引擎对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化IRuntime和ICudaEngine</span></span><br><span class="line">std::unique_ptr&lt;nvinfer1::IRuntime&gt; runtime&#123; nvinfer1::<span class="built_in">createInferRuntime</span>(logger) &#125;;</span><br><span class="line">std::unique_ptr&lt;nvinfer1::ICudaEngine&gt; mEngine&#123; runtime-&gt;<span class="built_in">deserializeCudaEngine</span>(engineData.<span class="built_in">data</span>(), fsize) &#125;;</span><br><span class="line"><span class="keyword">if</span> (mEngine.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to deserialize CUDA engine.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后创建CUDA的context，并为输入和输出绑定分配CUDA内存。引擎的本质是专为TensorRT优化后的模型。可使用<code>createExecutionContext</code> 方法来构建推演环境 <code>nvinfer1::IExecutionContext</code> 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;nvinfer1::IExecutionContext&gt; context&#123; mEngine-&gt;<span class="built_in">createExecutionContext</span>() &#125;;</span><br><span class="line"><span class="keyword">if</span> (context.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Failed to create CUDA context.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>准备模型输入</li></ol><ul><li>了解模型结构，通过<a href="https://netron.app/">netron.app</a>输入.onnx文件查看自己的神经网络结构。我这里输入名字为 <code>images</code> ，尺寸为3×640×640；输出名字为 <code>output0</code> ，尺寸为1×25200×6。</li></ul><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_model.jpg" alt="模型结构"></p><ul><li>TensorRT的模型推演在GPU上进行，需要在显存上为用于计算的数据申请空间。输入尺寸为3×640×640，使用内存大小计算函数得到显存中应当开辟的空间大小，然后使用 <code>cudaMalloc</code> 申请显存。其中 <code>cuda_mem_input</code> 为指向该显存区域的指针。为了方便后续推演，这里使用一个指针数组 <code>bindings</code> 记录下与推演有关的内存区域。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录与推演相关的内存区域</span></span><br><span class="line"><span class="type">void</span> *bindings[<span class="number">5</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *input_name = <span class="string">&quot;images&quot;</span>;</span><br><span class="line"><span class="type">int32_t</span> input_idx = mEngine-&gt;<span class="built_in">getBindingIndex</span>(input_name);</span><br><span class="line"><span class="keyword">if</span> (input_idx == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ERROR: failed to get input by name: &quot;</span> &lt;&lt; input_name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算显存大小并开辟</span></span><br><span class="line"><span class="type">int32_t</span> channels = <span class="number">3</span>, height = <span class="number">640</span>, width = <span class="number">640</span>;</span><br><span class="line">nvinfer1::Dims4 input_dims &#123; <span class="number">1</span>, channels, height, width &#125;;</span><br><span class="line"><span class="type">size_t</span> input_mem_size = <span class="built_in">get_memory_size</span>(input_dims, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"><span class="type">void</span>* cuda_mem_input &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cudaMalloc</span>(&amp;cuda_mem_input, input_mem_size) != cudaSuccess) </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR: input cuda memory allocation failed, size = &quot;</span> &lt;&lt; input_mem_size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bindings[<span class="number">0</span>] = cuda_mem_input;</span><br></pre></td></tr></table></figure><ul><li>同时还需为输出区域计算并开辟内存。模型的输出包含一个或多个对象，必须为每个输出对象分配独立的显存区域。在循环体中，首先通过 <code>getBindingDimensions</code> 获得输出每个对象的维度，然后计算其占据的显存区域大小，并调用 <code>cudaMalloc</code> 函数分配显存，最后将指向该存储区域的指针存入之前创建好的 <code>bindings</code> 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; output_node_names&#123; <span class="string">&quot;output0&quot;</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">size_t</span>&gt; output_mem_sizes;</span><br><span class="line"><span class="type">bool</span> output_mem_initialized = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_node_names.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int32_t</span> output_idx = mEngine-&gt;<span class="built_in">getBindingIndex</span>(output_node_names[i].<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">if</span> (output_idx == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ERROR: failed to get output by name: &quot;</span> &lt;&lt; output_node_names[i] &lt;&lt; std::endl;</span><br><span class="line">output_mem_initialized = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> output_dims = context-&gt;<span class="built_in">getBindingDimensions</span>(output_idx);</span><br><span class="line"><span class="keyword">auto</span> output_size = <span class="built_in">get_memory_size</span>(output_dims, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">output_mem_sizes.<span class="built_in">push_back</span>(output_size);</span><br><span class="line"><span class="type">void</span> *cuda_mem_output&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cudaMalloc</span>(&amp;cuda_mem_output, output_size) != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ERROR: output cuda memory allocation failed, size = &quot;</span> &lt;&lt; output_size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">output_mem_initialized = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">bindings[<span class="number">1</span> + i] = cuda_mem_output;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>显存空间初始化完成后，还需要初始化最后一个对象 <code>cudaStream</code> 。它用来在异步操作中同步结果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cudaStream_t stream&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cudaStreamCreate</span>(&amp;stream) != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ERROR: cuda stream creation failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从<code>image_file_path</code>中读取图像，将其调整为所需尺寸，并复制到GPU内存中。输入图像在进入神经网络之前，首先会进行预处理操作。典型的预处理操作包括：缩放到指定尺寸、减去均值、归一化、除方差。另外如果模型对输入通道的顺序有要求，预处理也会调整通道顺序。YOLOv5的输入大小为640x640像素，通道顺序为RGB， 预处理也非常简单，像素值除以255即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat img_bgr = cv::<span class="built_in">imread</span>(image_file_path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理</span></span><br><span class="line">cv::<span class="built_in">resize</span>(img_bgr, img_bgr, cv::<span class="built_in">Size</span>(width, height));</span><br><span class="line"><span class="type">int32_t</span> tmp = height * width * channels;</span><br><span class="line"><span class="type">float</span> *input_buffer = <span class="keyword">new</span> <span class="type">float</span>[tmp]();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; channels; c++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, HW = height * width; j &lt; HW; ++j)</span><br><span class="line">&#123;</span><br><span class="line">input_buffer[c * HW + j] = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(img_bgr.data[j * channels + <span class="number">2</span> - c]) / <span class="number">255.0f</span>;</span><br><span class="line"><span class="comment">// 其中 img_bgr.data 为指向像素存储区域的指针，而括号内下表运算中的 +2 实现了BGR数据到RGB的转换。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据预处理的操作是在HOST（CPU）侧完成，在推演之前还需要将预处理后的数据拷贝到GPU一侧。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">cudaMemcpyAsync</span>(cuda_mem_input, input_buffer, input_mem_size, cudaMemcpyHostToDevice, stream) != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ERROR: CUDA memory copy of input failed, size = &quot;</span> &lt;&lt; input_mem_size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>运行推理</li></ol><ul><li>使用执行Context的 <code>enqueueV2</code> 方法异步运行模型。 <code>enqueueV2</code> 是真正触发模型推演的操作。参数中的 <code>bindings</code> 是之前记录的指向输入与输出显存的指针数组。 <code>stream</code> 是在初始化资源章节创建的 <code>cudaStream</code> 对象，用于同步数据。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> status = context-&gt;<span class="built_in">enqueueV2</span>(bindings, stream, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (!status)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ERROR: TensorRT inference failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>模型输出后处理</li></ol><ul><li>首先按照输出数据的规格申请输出内存空间。为输出结果 <code>output0</code> 申请了一份内存空间，并将指向这些内存区域的指针存储在 <code>output_buffers</code> 指针数组中。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">float</span> *&gt; output_buffers;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_mem_sizes.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> *buf = <span class="keyword">new</span> <span class="type">float</span>[output_mem_sizes[i] / <span class="built_in">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">output_buffers.<span class="built_in">push_back</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接着将输出从GPU内存复制到CPU内存。使用 <code>cudaMemcpyAsync</code> 函数。其中参数 <code>output_buffers</code> 为刚才申请好的内存空间， <code>bindings</code> 为GPU一侧的显存空间， <code>output_mem_sizes</code> 为输出结果所占据的内存大小， <code>cudaMemcpyDeviceToHost</code> 指定了拷贝操作的方向，由于这是一个异步操作，所以要使用 <code>stream</code> 作为同步数据的依据。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_mem_sizes.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> mem_to_host_result = <span class="built_in">cudaMemcpyAsync</span>(output_buffers[i], bindings[<span class="number">1</span> + i], output_mem_sizes[i], cudaMemcpyDeviceToHost, stream);</span><br><span class="line"><span class="keyword">if</span> (mem_to_host_result != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ERROR: CUDA memory copy of output &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; failed, size = &quot;</span> &lt;&lt; output_mem_sizes[i] &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>等待同步，已经调用了3个异步操作函数，因此这里需要使用同步操作来等待执行真正完成。同步之后，模型推演的结果才真正存储在了内存 <code>output_buffers</code> 中。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cudaStreamSynchronize</span>(stream);</span><br></pre></td></tr></table></figure><ul><li>对输出进行后处理。首先定义三个向量分别存储检测获得的物体边界框 <code>boxes</code> 、分值 <code>scores</code> 与类别ID <code>class_ids</code> 。此次训练的YOLOv5模型有1个输出，即 <code>output0</code> 。 其本身是一个巨大的矩阵，其行数为25200，代表模型给出的物体检测结果。为此，可以定义一个指针 <code>p</code> 指向 <code>output0</code> ，然后通过一个循环来轮询结果。 此次训练中， <code>output0</code> 每行具有6个元素：第0~3个元素为物体边界框中心x，物体边界框中心y，物体边界框宽度和物体边界框高度；第4个元素为预测框分值；第5个元素是物体类别ID的概率，可以按照最大值获取到分类结果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">float</span>&gt; scores;</span><br><span class="line">std::vector&lt;cv::Rect&gt; boxes;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; class_ids;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> *p = output_buffers[<span class="number">0</span>]; <span class="comment">// 指向output0的第一个元素</span></span><br><span class="line"><span class="type">int</span> step = <span class="number">6</span>, proposal_count = <span class="number">25200</span>;</span><br><span class="line"><span class="type">float</span> score_threshold = <span class="number">0.5</span>, nms_threshold = <span class="number">0.45</span>; <span class="comment">// 分支阈值和NMS阈值</span></span><br><span class="line"><span class="type">float</span> scale = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; proposal_count; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 置信度低于分数阈值</span></span><br><span class="line"><span class="type">float</span> obj_score = p[<span class="number">4</span>]; <span class="comment">// 第4个元素是预测框分值</span></span><br><span class="line"><span class="keyword">if</span> (obj_score &lt; score_threshold)</span><br><span class="line">&#123;</span><br><span class="line">p += step;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断对象分类</span></span><br><span class="line"><span class="type">int</span> c_id = <span class="number">-1</span>;</span><br><span class="line"><span class="type">float</span> c_score = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; step; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p[j] &gt; c_score)</span><br><span class="line">&#123;</span><br><span class="line">c_score = p[j];</span><br><span class="line">c_id = j - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scores.<span class="built_in">push_back</span>(c_score * obj_score);</span><br><span class="line">class_ids.<span class="built_in">push_back</span>(c_id);</span><br><span class="line">boxes.<span class="built_in">push_back</span>(cv::<span class="built_in">Rect</span>((p[<span class="number">0</span>] - p[<span class="number">2</span>] / <span class="number">2</span>) / scale, (p[<span class="number">1</span>] - p[<span class="number">3</span>] / <span class="number">2</span>) / scale, p[<span class="number">2</span>] / scale, p[<span class="number">3</span>] / scale));</span><br><span class="line">p += step; <span class="comment">// 指向下一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用了OpenCV提供的NMS方法 <code>cv::dnn::NMSBoxes</code> 。其中 <code>boxes</code> 为存储了 <code>Rect</code> 类的向量， <code>scores</code> 为存储了分值的向量， <code>score_threshold</code> 为检测分值阈值， <code>nms_threshold</code> 为NMS操作的阈值， <code>indices</code> 为一个空向量，用来存储NMS的结果。最后按照 <code>indices</code> 给出的物体序号提取最终结果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行非最大值抑制以消除具有较低置信度的冗余重叠框</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; indices;</span><br><span class="line">cv::dnn::<span class="built_in">NMSBoxes</span>(boxes, scores, score_threshold, nms_threshold, indices);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集检测结果</span></span><br><span class="line">std::vector&lt;Result&gt; results;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : indices) </span><br><span class="line">&#123;</span><br><span class="line">    results.<span class="built_in">push_back</span>(Result &#123; scores[i], boxes[i], class_ids[i] &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>保存结果：它将包含绘制结果的图像保存下来。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : results)</span><br><span class="line">&#123;</span><br><span class="line">cv::<span class="built_in">rectangle</span>(img_bgr, r.box, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv::<span class="built_in">imwrite</span>(<span class="string">&quot;result.jpg&quot;</span>, img_bgr);</span><br></pre></td></tr></table></figure><h3><span id="525-主函数设计">5.2.5 主函数设计</span></h3><p>此程序主函数与基于.onnx文件推理程序类似，通过<code>main</code>函数的参数进行传参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//yolov5-engine.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Run like this:\n    &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; yolov5s.engine input.jpg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">run</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以当调用该程序时，只需在命令提示符的当前目录下，输入指令格式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yolov5-engine.exe best.engine input.jpg</span><br></pre></td></tr></table></figure><p><br><br><br></p><h1><span id="陆-打包软件">陆 —— 打包软件</span></h1><h2><span id="61-基于onnx文件图像推理程序打包">6.1 基于.onnx文件图像推理程序打包</span></h2><p>打包程序考虑其可用性，在输出文件的时候做了处理：在当前目录输出一张照片，在<code>output/</code>文件夹也输出一张照片并做名字冲突处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导出名冲突</span></span><br><span class="line"><span class="function">string <span class="title">getUniqueFileName</span><span class="params">(<span class="type">const</span> std::string &amp;fileName, <span class="type">const</span> std::string &amp;outputDirectory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string baseName, extension;</span><br><span class="line"><span class="type">size_t</span> dotIndex = fileName.<span class="built_in">rfind</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (dotIndex != string::npos)</span><br><span class="line">&#123;</span><br><span class="line">baseName = fileName.<span class="built_in">substr</span>(<span class="number">0</span>, dotIndex);</span><br><span class="line">extension = fileName.<span class="built_in">substr</span>(dotIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">baseName = fileName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string newFileName = fileName;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ifstream(outputDirectory + newFileName).<span class="built_in">good</span>())</span><br><span class="line">&#123;</span><br><span class="line">newFileName = baseName + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(counter) + extension;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newFileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备份存储</span></span><br><span class="line">string dir = <span class="string">&quot;output/&quot;</span>; <span class="comment">//文件夹路径</span></span><br><span class="line"><span class="keyword">if</span> (_access(dir.<span class="built_in">c_str</span>(), <span class="number">0</span>) == <span class="number">-1</span>)<span class="comment">//判断该文件夹是否存在</span></span><br><span class="line">&#123;</span><br><span class="line">_mkdir(dir.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;result.jpg&quot;</span>, srcimg);</span><br><span class="line">string newname = <span class="built_in">getUniqueFileName</span>(<span class="string">&quot;result.jpg&quot;</span>, <span class="string">&quot;output/&quot;</span>);</span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;output/&quot;</span> + newname, srcimg);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于主函数设计为可用命令提示符运行，故只需使用Visual Studio的Release版本生成.exe文件，再参考<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/11/#more">此博客</a>进行打包即可。</p><p>打包之后即可移植到其他PC设备使用。</p><h2><span id="62-基于engine文件图像推理程序打包">6.2 基于.engine文件图像推理程序打包</span></h2><p>同理，打包程序考虑其可用性，在输出文件的时候做了处理：在当前目录输出一张照片，在<code>output/</code>文件夹也输出一张照片并做名字冲突处理。</p><p>由于主函数设计为可用命令提示符运行，故只需使用Visual Studio的Release版本生成.exe文件，再参考<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/11/#more">此博客</a>进行打包即可。</p><p>注意一点，由于.engine文件需要调用显卡驱动，故不能移植到别的电脑使用（暂时我是没成功）。</p><h2><span id="63-整体打包">6.3 整体打包</span></h2><p>此次项目整体打包采用Qt作为前端页面，将上面两个打包好的程序结合，使用时只需调用指定程序模块即可。具体Qt打包可参考<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/10/">此博客</a></p><p>具体代码不细展开，分享于<a href="https://gitee.com/fingsinz/ele-bicycle-detection/">码云仓库</a>。</p><p><br><br><br></p><h1><span id="柒-总结及后话">柒 —— 总结及后话</span></h1><p>实际上，如5.1的步骤，将参数改为.trt，即可导出.trt文件。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trtexec --onnx=best.onnx --saveEngine=best.trt</span><br></pre></td></tr></table></figure><p>至于如何根据.trt文件设计算法进一步进行推测识别，此次项目未能完成，有待补充，深度学习很多方面的知识也有待补充。故此次项目仅能作为一个带有启发性的入门级别的项目。</p><p>深度学习是机器学习领域中的一个新的研究方向，旨在让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据。深度学习试图为数据的高层次摘要进行建模，通过使用多个处理层和对这些层的结果进行线性和非线性的转换，来实现对数据的识别和理解。深度学习在搜索技术、数据挖掘、机器翻译、自然语言处理、多媒体学习、语音、推荐和个性化技术等领域都取得了了很多成果。经过这次项目，我感受到了深度学习的有趣，写下这篇博客，用于记录与分享。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> YOLOv5 </tag>
            
            <tag> TensorRT </tag>
            
            <tag> C++推演 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio2022的C++项目打包成软件记录</title>
      <link href="/%E6%97%A5%E5%B8%B8/11/"/>
      <url>/%E6%97%A5%E5%B8%B8/11/</url>
      
        <content type="html"><![CDATA[<p>介绍如何将VS的C++项目打包</p><p>关键词：C++</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#1%E7%BC%96%E8%AF%91%E5%87%BAexe%E6%96%87%E4%BB%B6">1.编译出.exe文件</a></li><li><a href="#2%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE">2.打包项目</a></li></ul><!-- tocstop --><h1><span id="1编译出exe文件">1.编译出.exe文件</span></h1><p>选择Release生成，我在此是<code>Realease x64</code>编译。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_vs.jpg" alt="编译"></p><h1><span id="2打包项目">2.打包项目</span></h1><p>将刚才构建出来的.exe文件复制到一个新的文件夹（目录尽量不带中文），该目录作为软件的工作目录。比如我复制到F:\test\HelloWorld1.0，软件工作目录就是这个文件夹，test目录下的一个新建文件夹。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_exe.jpg" alt="软件工作目录"></p><p>打开Visual Studio的安装目录，找到<code>dumpbin.exe</code>并复制其路径，可以按照下面的路径查找：<br><code>E:\Microsoft_Visual_Studio\VS\VC\Tools\MSVC\14.36.32532\bin\Hostx64\x64</code></p><p>回到软件工作目录，在地址栏输入cmd打开命令提示符，按格式输入：<br><code>dumpbin.exe路径 /dependents 发布软件的路径</code></p><p>如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Microsoft_Visual_Studio</span>\<span class="title">VS</span>\<span class="title">VC</span>\<span class="title">Tools</span>\<span class="title">MSVC</span>\14.36.32532\<span class="title">bin</span>\<span class="title">Hostx64</span>\<span class="title">x64</span>\<span class="title">dumpbin.exe</span> /<span class="title">dependents</span> <span class="title">HelloWorld.exe</span></span></span><br></pre></td></tr></table></figure><p>接着将出现的.dll文件找出来，推荐使用<a href="https://www.voidtools.com/zh-cn/downloads/">Everything软件</a>搜索，选择路径上对应的平台（x86或x64），复制到软件的工作目录即可。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_dependents.jpg" alt="软件依赖"></p><p>如图：</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_last.jpg" alt="完整的软件工作目录"></p><p>这样即可直接点击.exe文件运行。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt5.14.2项目打包成软件记录</title>
      <link href="/%E6%97%A5%E5%B8%B8/10/"/>
      <url>/%E6%97%A5%E5%B8%B8/10/</url>
      
        <content type="html"><![CDATA[<p>介绍如何将Qt项目打包成软件发布</p><p>关键词：C++、Qt</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#1%E7%BC%96%E8%AF%91%E5%87%BAexe%E6%96%87%E4%BB%B6">1.编译出.exe文件</a></li><li><a href="#2%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE">2.打包项目</a></li></ul><!-- tocstop --><h1><span id="1编译出exe文件">1.编译出.exe文件</span></h1><p>打开需要打包的项目，在左下角选择合适的构建部件和版本，版本要选择<code>Release</code>，至于64bit还是32bit看需求。</p><p>选择后点击锤子编译项目，此处我以<code>MinGWx64,Release</code>编译。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_qt.jpg" alt="选择构建部件和版本"></p><p>点击左侧的项目，查看构建目录（项目目录跟构建目录尽量别带中文）。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_qt2.jpg" alt="查看构建目录"></p><p>打开构建目录，发现出现一个.exe文件。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_exe.jpg" alt="编译出.exe文件"></p><h1><span id="2打包项目">2.打包项目</span></h1><p>将刚才构建出来的.exe文件复制到一个新的文件夹（目录尽量不带中文），该目录作为软件的工作目录。比如我复制到<code>F:\test\HelloWorld1.0</code>，软件工作目录就是这个文件夹，test目录下的一个新建文件夹。</p><p>接着打开Qt的安装目录下的bin文件夹，找到<code>windeployqt.exe</code>，复制其路径，我的<code>windeployqt.exe</code>位于<code>D:\Qt\5.14.2\mingw73_64\bin</code>。</p><p>回到软件的工作目录（新建的文件夹），在地址栏输入cmd打开命令提示符，按格式输入：</p><p><code>windeployqt文件路径 发布软件的路径</code></p><p>如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Qt\5.14.2\mingw73_64\bin\windeployqt.exe HelloWorld.exe</span><br></pre></td></tr></table></figure><p>慢慢等待打包完成。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_finish.jpg" alt="打包完成"></p><p>之后就可以直接打开软件工作目录下的exe执行。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OI Wiki，一个整合了编程竞赛的知识整合站点</title>
      <link href="/%E5%85%B6%E4%BB%96%E5%88%86%E4%BA%AB/oiwiki/"/>
      <url>/%E5%85%B6%E4%BB%96%E5%88%86%E4%BA%AB/oiwiki/</url>
      
        <content type="html"><![CDATA[<p>Github分享</p><p>关键词：算法、数据结构、竞赛</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88">是什么</a></li><li><a href="#%E5%86%85%E5%AE%B9%E9%93%BE%E6%8E%A5">内容链接</a></li><li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">如何使用</a></li></ul><!-- tocstop --><h1><span id="是什么">是什么</span></h1><p>“OI Wiki 致力于成为一个免费开放且持续更新的知识整合站点，大家可以在这里获取关于 编程竞赛 (competitive programming) 有趣又实用的知识，我们为大家准备了竞赛中的基础知识、常见题型、解题思路以及常用工具等内容，帮助大家更快速深入地学习编程竞赛。”</p><h1><span id="内容链接">内容链接</span></h1><p><a href="https://oi-wiki.org/">OI Wiki——网页使用</a><br><a href="https://github.com/OI-wiki/OI-wiki">Github 仓库</a><br><a href="https://gitee.com/OI-wiki/OI-wiki">Gitee 仓库</a></p><h1><span id="如何使用">如何使用</span></h1><p>在Github主页上有详细介绍。</p><p>可以直接点击上面的OI Wiki链接使用。</p><p>我在此用Windows 10做一个简单的 <strong>离线版</strong> 使用示例。</p><ol><li>直接或git方式下载仓库压缩包。</li></ol><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_download.jpg" alt="下载"></p><ol start="2"><li><p>解压压缩包</p></li><li><p>在Python下（没有Python的可以<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/8/#more">安装Python</a>），使用命令建立静态网页：在解压后的目录下地址栏输入cmd，接着输入下面的命令启动网页。</p></li></ol><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_run.jpg" alt="打开cmd"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果是 python3</span><br><span class="line">python3 -m http.server</span><br><span class="line"># 如果是 python2</span><br><span class="line">python2 -m SimpleHTTPServer</span><br><span class="line"># 有些环境下找不到名叫 python3/python2 的可执行文件，不妨运行 python 试试</span><br></pre></td></tr></table></figure><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_run2.jpg" alt="启动网页服务"></p><ul><li>如上图则为启动网页服务成功。我在此输入的是<code>python</code>，可以试试<code>python3</code>或者<code>python2</code>能不能运行。</li><li>在浏览器地址栏中输入<code>http://localhost:8000/</code>或<code>127.0.0.1:8000</code>即可进入网页，其中<code>8000</code>为上图启动网页服务的端口，并不一定是<code>8000</code>。</li></ul><ol start="4"><li>页面如下图即可进行阅读学习</li></ol><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_home.jpg" alt="OI Wiki"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 其他分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio2022的OpenCV4.5.2和CUDA12.0项目配置</title>
      <link href="/%E6%97%A5%E5%B8%B8/9/"/>
      <url>/%E6%97%A5%E5%B8%B8/9/</url>
      
        <content type="html"><![CDATA[<p>记录一次环境配置</p><p>关键词：深度学习、OpenCV、CUDA</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#opencv%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">OpenCV的环境配置</a><ul><li><a href="#opencv%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">OpenCV下载安装</a></li><li><a href="#%E6%B7%BB%E5%8A%A0opencv%E5%88%B0%E7%B3%BB%E7%BB%9Fpath%E5%8F%98%E9%87%8F">添加OpenCV到系统Path变量</a></li><li><a href="#%E6%B7%BB%E5%8A%A0opencv%E7%8E%AF%E5%A2%83%E5%88%B0vs%E9%A1%B9%E7%9B%AE">添加OpenCV环境到VS项目</a><ul><li><a href="#vc%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AEopencv">VC++目录配置OpenCV</a></li><li><a href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E9%85%8D%E7%BD%AEopencv">链接器配置OpenCV</a></li></ul></li></ul></li><li><a href="#cuda%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">CUDA环境配置</a><ul><li><a href="#cuda%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">CUDA下载安装</a></li><li><a href="#%E6%B7%BB%E5%8A%A0cuda%E7%8E%AF%E5%A2%83%E5%88%B0vs%E9%A1%B9%E7%9B%AE">添加CUDA环境到VS项目</a><ul><li><a href="#vc%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AEcuda">VC++目录配置CUDA</a></li><li><a href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E9%85%8D%E7%BD%AEcuda">链接器配置CUDA</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E9%A3%8E%E6%A0%BC">配置源码文件风格</a></li></ul></li><li><a href="#%E6%B5%8B%E8%AF%95cuda%E4%BB%A3%E7%A0%81">测试CUDA代码</a></li><li><a href="#cuda%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%A2%B0%E5%A3%81">CUDA环境的一些碰壁</a></li></ul></li></ul><!-- tocstop --><h1><span id="opencv的环境配置">OpenCV的环境配置</span></h1><h2><span id="opencv下载安装">OpenCV下载安装</span></h2><p>前往官网选择适合的OpenCV版本下载，并安装到合适的位置。</p><p><a href="https://opencv.org/releases/">官网下载OpenCV</a></p><p>我的OpenCV安装在：<code>D:\opencv4.5.2</code></p><h2><span id="添加opencv到系统path变量">添加OpenCV到系统Path变量</span></h2><p>打开编辑系统环境变量，点击右下方的环境变量，在系统变量中找到PATH项，点击编辑添加OpenCV目录下的bin文件夹。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_opencv2PATH.jpg" alt="添加OpenCV至PATH"></p><p>至于添加的是vc14还是vc15，参照下表</p><table><thead><tr><th align="center">VS版本</th><th align="center">VC</th></tr></thead><tbody><tr><td align="center">VS2015</td><td align="center">VC14</td></tr><tr><td align="center">VS2017及以上</td><td align="center">VC15</td></tr></tbody></table><h2><span id="添加opencv环境到vs项目">添加OpenCV环境到VS项目</span></h2><p>右键项目，选择最下方属性，打开属性配置窗口，选择是Debug模式或Release模式配置。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_vs1.jpg" alt="VS项目配置窗口"></p><h3><span id="vc目录配置opencv">VC++目录配置OpenCV</span></h3><ol><li><strong>点击包含目录</strong>，在包含目录中把OpenCV目录下的include文件夹添加。</li></ol><p>此处我的添加是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\opencv4.5.2\build\include\opencv2</span><br><span class="line">D:\opencv4.5.2\build\include</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>点击库目录</strong>，在库目录中把OpenCV的lib文件添加，此处路径藏得比较深，参考我的添加。</li></ol><p>此处我的添加是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\opencv4.5.2\build\x64\vc15\lib</span><br></pre></td></tr></table></figure><h3><span id="链接器配置opencv">链接器配置OpenCV</span></h3><ol><li><strong>点击输入，再点击附加依赖项</strong>，将OpenCV的lib文件添加，lib文件存放在上面库目录的文件夹中。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">opencv_world452.lib</span><br><span class="line">opencv_world452d.lib</span><br></pre></td></tr></table></figure><p>注意，此处文件名带<code>d</code>的为Debug版本的依赖项，不带<code>d</code>的为Release版本的依赖项。<br>在配置Debug版本时把带<code>d</code>的文件放在不带<code>d</code>的文件之上，<br>在配置Release版本时把不带<code>d</code>的文件放在带<code>d</code>的文件之上。</p><h1><span id="cuda环境配置">CUDA环境配置</span></h1><h2><span id="cuda下载安装">CUDA下载安装</span></h2><p><a href="http://fingsinz.space/%E6%97%A5%E5%B8%B8/5/">参考此条博客</a></p><p>我的CUDA目录在：<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code></p><h2><span id="添加cuda环境到vs项目">添加CUDA环境到VS项目</span></h2><p>配置为x64平台。</p><p>右键项目→生成依赖项→生成自定义→勾选“CUDA xxx”。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_cuda.jpg" alt="生成依赖项"></p><h3><span id="vc目录配置cuda">VC++目录配置CUDA</span></h3><ol><li><strong>点击包含目录</strong>，在包含目录中把OpenCV目录下的include文件夹添加。</li></ol><p>此处我的添加是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>点击库目录</strong>，在库目录中把OpenCV的lib文件夹添加。</li></ol><p>此处我的添加是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\lib\x64</span><br></pre></td></tr></table></figure><h3><span id="链接器配置cuda">链接器配置CUDA</span></h3><ol><li><strong>点击常规，再点击附加库目录</strong>，添加下面的目录。<em>似乎不配置这一条也可以</em></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(CUDA_PATH_V12_0)\lib\$(Platform)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Debug配置下：</span><br><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\lib\Win32</span><br><span class="line">Release配置下：</span><br><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\lib\x64</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>点击输入，再点击附加依赖项</strong>，将CUDA的lib文件添加，输入下面的内容。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\lib\x64\*.lib</span><br></pre></td></tr></table></figure><h3><span id="配置源码文件风格">配置源码文件风格</span></h3><p>右键源文件，可以添加新建项中选择“CUDA C&#x2F;C++ File”。<br>右键“xxx.cu”源文件，点击属性，选择配置属性中的常规，从项类型中找到“CUDA C&#x2F;C++”。</p><h2><span id="测试cuda代码">测试CUDA代码</span></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cuda_runtime.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;device_launch_parameters.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">cudaError_t <span class="title">addWithCuda</span><span class="params">(<span class="type">int</span> *c, <span class="type">const</span> <span class="type">int</span> *a, <span class="type">const</span> <span class="type">int</span> *b, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">addKernel</span><span class="params">(<span class="type">int</span> *c, <span class="type">const</span> <span class="type">int</span> *a, <span class="type">const</span> <span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = threadIdx.x;</span><br><span class="line">    c[i] = a[i] + b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> arraySize = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a[arraySize] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b[arraySize] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="type">int</span> c[arraySize] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add vectors in parallel.</span></span><br><span class="line">    cudaError_t cudaStatus = <span class="built_in">addWithCuda</span>(c, a, b, arraySize);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;addWithCuda failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#123;1,2,3,4,5&#125; + &#123;10,20,30,40,50&#125; = &#123;%d,%d,%d,%d,%d&#125;\n&quot;</span>,</span><br><span class="line">        c[<span class="number">0</span>], c[<span class="number">1</span>], c[<span class="number">2</span>], c[<span class="number">3</span>], c[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cudaDeviceReset must be called before exiting in order for profiling and</span></span><br><span class="line">    <span class="comment">// tracing tools such as Nsight and Visual Profiler to show complete traces.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaDeviceReset</span>();</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaDeviceReset failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper function for using CUDA to add vectors in parallel.</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">addWithCuda</span><span class="params">(<span class="type">int</span> *c, <span class="type">const</span> <span class="type">int</span> *a, <span class="type">const</span> <span class="type">int</span> *b, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *dev_a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *dev_b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *dev_c = <span class="number">0</span>;</span><br><span class="line">    cudaError_t cudaStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Choose which GPU to run on, change this on a multi-GPU system.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaSetDevice</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaSetDevice failed!  Do you have a CUDA-capable GPU installed?&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate GPU buffers for three vectors (two input, one output)    .</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_c, size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMalloc failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_a, size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMalloc failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_b, size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMalloc failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy input vectors from host memory to GPU buffers.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMemcpy</span>(dev_a, a, size * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMemcpy failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMemcpy</span>(dev_b, b, size * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMemcpy failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Launch a kernel on the GPU with one thread for each element.</span></span><br><span class="line">    addKernel&lt;&lt;&lt;<span class="number">1</span>, size&gt;&gt;&gt;(dev_c, dev_a, dev_b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for any errors launching the kernel</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaGetLastError</span>();</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;addKernel launch failed: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(cudaStatus));</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cudaDeviceSynchronize waits for the kernel to finish, and returns</span></span><br><span class="line">    <span class="comment">// any errors encountered during the launch.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaDeviceSynchronize returned error code %d after launching addKernel!\n&quot;</span>, cudaStatus);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy output vector from GPU buffer to host memory.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMemcpy</span>(c, dev_c, size * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyDeviceToHost);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMemcpy failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Error:</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_c);</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_a);</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cudaStatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果如下图：</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_result.jpg" alt="测试结果"></p><h2><span id="cuda环境的一些碰壁">CUDA环境的一些碰壁</span></h2><ol><li><p>我的CUDA安装在一个可移动固态硬盘（G盘）中，可能导致了我的CUDA项目只能位于G盘使用，复制粘贴到电脑的盘会出现问题。</p></li><li><p>如果出现了大段指令无法运行，像下面的错误显示，可以复制命令（引号部分）到cmd运行，查看更详细的报错原因。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// VS报错如下</span><br><span class="line">严重性代码说明项目文件行禁止显示状态</span><br><span class="line">错误MSB3721命令“&quot;G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\bin\nvcc.exe&quot; -gencode=arch=compute_52,code=\&quot;sm_52,compute_52\&quot; --use-local-env -ccbin &quot;E:\Microsoft_Visual_Studio\VS\VC\Tools\MSVC\14.33.31629\bin\HostX64\x64&quot; -x cu   -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include  -G   --keep-dir x64\Debug  -maxrregcount=0  --machine 64 --compile -cudart static  -g  -D_DEBUG -D_CONSOLE -D_UNICODE -DUNICODE -Xcompiler &quot;/EHsc /W3 /nologo /Od /FdG:\Data\Coding_Master\yolov5-trt\bin\immediate\x64\Debug\vc143.pdb /FS /Zi /RTC1 /MDd &quot; -o G:\Data\Coding_Master\yolov5-trt\bin\x64\File.cu.obj &quot;G:\Data\Coding_Master\yolov5-trt\File.cu&quot;”已退出，返回代码为 1。yolov5-trtE:\Microsoft_Visual_Studio\VS\MSBuild\Microsoft\VC\v170\BuildCustomizations\CUDA 12.0.targets794</span><br><span class="line"></span><br><span class="line">// 复制命令部分，即下面部分到cmd输入</span><br><span class="line">&quot;G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\bin\nvcc.exe&quot; -gencode=arch=compute_52,code=\&quot;sm_52,compute_52\&quot; --use-local-env -ccbin &quot;E:\Microsoft_Visual_Studio\VS\VC\Tools\MSVC\14.33.31629\bin\HostX64\x64&quot; -x cu   -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include  -G   --keep-dir x64\Debug  -maxrregcount=0  --machine 64 --compile -cudart static  -g  -D_DEBUG -D_CONSOLE -D_UNICODE -DUNICODE -Xcompiler &quot;/EHsc /W3 /nologo /Od /FdG:\Data\Coding_Master\yolov5-trt\bin\immediate\x64\Debug\vc143.pdb /FS /Zi /RTC1 /MDd &quot; -o G:\Data\Coding_Master\yolov5-trt\bin\x64\File.cu.obj &quot;G:\Data\Coding_Master\yolov5-trt\File.cu&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li>还遇到一些其他的坑可以自行必应。</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下Python3.11.4的安装记录</title>
      <link href="/%E6%97%A5%E5%B8%B8/8/"/>
      <url>/%E6%97%A5%E5%B8%B8/8/</url>
      
        <content type="html"><![CDATA[<p>记录一次安装Python</p><p>关键词：Python</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#%E4%B8%8B%E8%BD%BDpython%E5%AE%89%E8%A3%85%E5%8C%85">下载Python安装包</a></li><li><a href="#%E5%AE%89%E8%A3%85python">安装Python</a></li><li><a href="#%E6%B5%8B%E8%AF%95python">测试Python</a></li><li><a href="#%E9%99%84%E6%9B%B4%E6%94%B9python%E7%9A%84pip%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84">附：更改Python的pip安装路径</a></li></ul><!-- tocstop --><h1><span id="下载python安装包">下载Python安装包</span></h1><p><a href="https://www.python.org/downloads/windows/">官网</a>选择尽量较新的Python版本下载。</p><h1><span id="安装python">安装Python</span></h1><p>打开下载的Python安装包，选择<code>Customize installation</code>客制化安装，记得勾选下面的“Add python.exe to PATH”。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py1.jpg" alt="安装步骤1"></p><p>接着默认勾选：</p><ul><li>pip：包管理器，下载包时使用。建议勾选上</li></ul><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py2.jpg" alt="安装步骤2"></p><p>再接着更改安装路径，建议安装在非系统盘。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py3.jpg" alt="安装步骤3"></p><p>等待安装完成即可。</p><h1><span id="测试python">测试Python</span></h1><p>按下<code>Win+R</code>输入<code>cmd</code>打开命令窗口，输入下面命令验证是否安装成功。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -V</span><br></pre></td></tr></table></figure><p>如果出现版本号，即为安装成功。</p><h1><span id="附更改python的pip安装路径">附：更改Python的pip安装路径</span></h1><p>建议将pip安装的包放至非系统盘。进入Python的安装路径，如我的在<code>D:\Pyhton\Lib</code>，寻找文件<code>site.py</code>，使用记事本打开。使用<code>ctrl+f</code>查找关键字<code>USER_SITE</code>等字，将路径更改为自定义的路径。我更改情况如下图。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py.jpg" alt="更改路径"></p><p>更改路径后，打开cmd，使用下面指令安装numpy包。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure><p>安装成功后，再使用下面指令查看numpy包的安装位置。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show numpy</span><br></pre></td></tr></table></figure><p>我成功更改pip的安装路径，新下载的numpy包位于<code>D:\Pyhton\Lib\site-packages</code>。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py4.jpg" alt="更改路径后"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于GPU服务器的选用</title>
      <link href="/%E5%85%B6%E4%BB%96%E5%88%86%E4%BA%AB/gpuserver/"/>
      <url>/%E5%85%B6%E4%BB%96%E5%88%86%E4%BA%AB/gpuserver/</url>
      
        <content type="html"><![CDATA[<p>介绍关于GPU服务器：租用、使用</p><p>关键词：深度学习、GPU服务器</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#gpu%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%8D%E5%8A%A1%E5%95%86">GPU服务器服务商</a></li><li><a href="#gpu%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8">GPU服务器使用</a></li></ul><!-- tocstop --><h1><span id="gpu服务器服务商">GPU服务器服务商</span></h1><ol><li>AutoDL算力云</li></ol><ul><li>网站：<a href="https://www.autodl.com/home">AutoDL算力云</a></li><li>个人评价：本人具有使用经历，价格偏便宜，镜像有现成，适合新手入门尝试。</li></ul><ol start="2"><li><a href="https://mistgpu.com/">MistGPU</a></li></ol><ul><li>网站：<a href="https://mistgpu.com/">MistGPU</a></li><li>个人评价：价格还行，备用选择。</li></ul><ol start="3"><li>阿里云</li></ol><ul><li>网站：<a href="https://www.aliyun.com/product/ecs/gpu">阿里云</a></li><li>个人评价：阿里云，不多说，可靠也不便宜。</li></ul><h1><span id="gpu服务器使用">GPU服务器使用</span></h1><ol><li>选择适合的GPU型号、显存大小、浮点算力、存储盘大小。</li><li>选择合适的镜像进行环境配置。</li><li>一般无图形窗口，命令行使用，文件上传下载。</li><li>详细可参考各个服务商的帮助文档。</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 其他分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> GPU服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLOv5由pt文件转onnx文件报错解决</title>
      <link href="/%E6%97%A5%E5%B8%B8/7/"/>
      <url>/%E6%97%A5%E5%B8%B8/7/</url>
      
        <content type="html"><![CDATA[<p>ONNX: export failure ❌ 5.9s: Unsupported ONNX opset version: 17</p><p>关键词：深度学习、YOLOv5、onnx</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#%E6%8A%A5%E9%94%99%E7%AA%97%E5%8F%A3">报错窗口</a></li><li><a href="#%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0">报错原因</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li></ul><!-- tocstop --><h1><span id="报错窗口">报错窗口</span></h1><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/7_error.png" alt="报错"></p><h1><span id="报错原因">报错原因</span></h1><p>export.py文件中parse_opt()函数设置的opset版本错误。</p><h1><span id="解决方案">解决方案</span></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找到parse_opt()函数中的此行，将default值改为12</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--opset&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">12</span>, <span class="built_in">help</span>=<span class="string">&#x27;ONNX: opset version&#x27;</span>)</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> YOLOv5 </tag>
            
            <tag> onnx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++报错：表达式必须含有常量值</title>
      <link href="/%E6%97%A5%E5%B8%B8/6/"/>
      <url>/%E6%97%A5%E5%B8%B8/6/</url>
      
        <content type="html"><![CDATA[<p>关于在Visual Studio 2022使用C++ 20语法的表达式开辟数组空间报错</p><p>关键词：C++</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0">错误原因</a></li><li><a href="#%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B">错误示例</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li></ul><!-- tocstop --><h1><span id="错误原因">错误原因</span></h1><ol><li><p>c++中不允许使用变量作为数组的长度定义数组，必须为常量值，c++中所有的内存需求都是在程序执行前通过定义的常量来确定的。</p></li><li><p>声明为const或constexpr的表达式在编译时计算结果不是常数。</p></li><li><p>编译器必须能够在表达式被使用时确定表达式的值。</p></li></ol><h1><span id="错误示例">错误示例</span></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示范1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>, c = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> d[a * b * c]; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示范2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>, c = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> tmp = a * b * c;</span><br><span class="line"><span class="type">int</span> d[tmp]; <span class="comment">// error，如错误原因2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示范3</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> array_size; <span class="comment">// error</span></span><br><span class="line">    <span class="type">int</span> size_array[array_size];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> test::array_size = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><h1><span id="解决方案">解决方案</span></h1><p>使用<code>new</code>进行动态内存分配，<strong>记得通过<code>delete</code>回收分配的内存</strong>，如上述代码改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>, c = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *d = <span class="keyword">new</span> <span class="type">int</span>[a * b * c];</span><br><span class="line"><span class="keyword">delete</span>[] d;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于new分配内存的使用：</p><ol><li>单变量分配</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Type *p = <span class="keyword">new</span> Type;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">Type *p = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="number">2</span>); <span class="comment">//动态分配内存并初始化</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><ol start="2"><li>一维数组申请</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Type *p = <span class="keyword">new</span> Type[n];</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line">Type *p = <span class="keyword">new</span> Type[n]();<span class="comment">//动态分配内存并初始化全部为0</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure><ol start="3"><li>二维数组申请</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Type **p = <span class="keyword">new</span> Type *[m];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = <span class="keyword">new</span> Type[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10下安装CUDA、TensorRT记录</title>
      <link href="/%E6%97%A5%E5%B8%B8/5/"/>
      <url>/%E6%97%A5%E5%B8%B8/5/</url>
      
        <content type="html"><![CDATA[<p>GPU：NVIDIA GeFOrce GTX 1050</p><p>关键词：深度学习、YOLOv5、TensorRT、C++推演</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#%E4%B8%80-%E4%B8%8B%E8%BD%BDcuda">一、下载CUDA</a><ul><li><a href="#1%E7%A1%AE%E5%AE%9A%E9%80%82%E9%85%8D%E6%9C%AC%E6%9C%BA%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%9A%84cuda%E7%89%88%E6%9C%AC">1.确定适配本机显卡驱动的CUDA版本</a></li><li><a href="#2%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84cuda">2.下载对应版本的CUDA</a></li><li><a href="#3%E5%AE%89%E8%A3%85cuda">3.安装CUDA</a></li></ul></li><li><a href="#%E4%BA%8C-%E4%B8%8B%E8%BD%BDcudnn%E5%8C%85">二、下载cuDNN包</a><ul><li><a href="#1%E9%80%89%E6%8B%A9%E9%80%82%E9%85%8Dcuda%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%9A%84cudnn%E5%8C%85">1.选择适配CUDA的版本下载对应的cuDNN包</a></li><li><a href="#2%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E4%BD%8D%E7%BD%AE%E8%A7%A3%E5%8E%8Bcudnn%E5%8E%8B%E7%BC%A9%E5%8C%85">2.选择合适的位置解压cuDNN压缩包</a></li><li><a href="#3%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6">3.复制文件</a></li><li><a href="#4%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F">4.验证是否成功</a></li></ul></li><li><a href="#%E4%B8%89-%E4%B8%8B%E8%BD%BDtensorrt%E5%8C%85">三、下载TensorRT包</a><ul><li><a href="#1%E9%80%89%E6%8B%A9%E9%80%82%E9%85%8Dcuda%E7%89%88%E6%9C%AC%E7%9A%84tensorrt%E5%8C%85%E4%B8%8B%E8%BD%BD">1.选择适配CUDA版本的TensorRT包下载</a></li><li><a href="#2%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E4%BD%8D%E7%BD%AE%E8%A7%A3%E5%8E%8Btensorrt%E5%8E%8B%E7%BC%A9%E5%8C%85">2.选择合适的位置解压TensorRT压缩包</a></li><li><a href="#3%E5%AE%89%E8%A3%85tensorrt">3.安装TensorRT</a></li><li><a href="#4%E9%AA%8C%E8%AF%81tensort">4.验证TensoRT</a></li></ul></li></ul><!-- tocstop --><h1><span id="一-下载cuda">一、下载CUDA</span></h1><h2><span id="1确定适配本机显卡驱动的cuda版本">1.确定适配本机显卡驱动的CUDA版本</span></h2><p>系统搜索打开NVIDIA控制面板，点击帮助，选择系统信息-&gt;组件，找到CUDA字样。此处我的CUDA适配版本为<code>12.0</code>。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/5_CUDA%E7%89%88%E6%9C%AC.jpg" alt="CUDA版本查看"></p><h2><span id="2下载对应版本的cuda">2.下载对应版本的CUDA</span></h2><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">下载地址 - NVIDIA官网</a></p><h2><span id="3安装cuda">3.安装CUDA</span></h2><p>点击下载的安装exe文件，可以更改文件安装位置，记住文件安装位置。此处我的安装位置是<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code>。</p><h1><span id="二-下载cudnn包">二、下载cuDNN包</span></h1><h2><span id="1选择适配cuda的版本下载对应的cudnn包">1.选择适配CUDA的版本下载对应的cuDNN包</span></h2><p><a href="https://developer.nvidia.com/rdp/cudnn-archive">下载地址 - NVIDIA官网</a></p><h2><span id="2选择合适的位置解压cudnn压缩包">2.选择合适的位置解压cuDNN压缩包</span></h2><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/5_cuDNN.jpg" alt="解压cuDNN后的文件"></p><h2><span id="3复制文件">3.复制文件</span></h2><p>cuDNN属于是CUDA的一个补丁包，因此无需安装。需要将<code>bin</code>、<code>include</code>、<code>lib</code>文件夹中的相关文件拷贝到CUDA安装位置的<code>bin</code>、<code>include</code>、<code>lib的x64</code>文件夹中。</p><p>我的CUDA安装位置是：<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code>。</p><h2><span id="4验证是否成功">4.验证是否成功</span></h2><p><code>Win + R</code>输入cmd打开cmd窗口。<br>直接输入盘符如<code>F:</code>跳转到F盘，<code>cd</code>进入到具体地址。<br>比如我的CUDA安装在<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code>，<br>那么进入到<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\extras\demo_suite</code></p><p>接着在cmd窗口输入下面的指令分别运行两个exe文件，结果出现PASS（如图）则验证成功。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bandwidthTest.exe</span><br></pre></td></tr></table></figure><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/5_cuDNN%E9%AA%8C%E8%AF%81.jpg" alt="第一个exe运行结果"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deviceQuery.exe</span><br></pre></td></tr></table></figure><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/5_cuDNN%E9%AA%8C%E8%AF%812.jpg" alt="第二个exe运行结果"></p><h1><span id="三-下载tensorrt包">三、下载TensorRT包</span></h1><h2><span id="1选择适配cuda版本的tensorrt包下载">1.选择适配CUDA版本的TensorRT包下载</span></h2><p>进入<a href="https://developer.nvidia.com/nvidia-tensorrt-download">官网</a>，选择较新的大版本，再选择适合自己安装的CUDA版本下载。</p><p>我在此处下载Windows的支持CUDA12.0的版本。</p><h2><span id="2选择合适的位置解压tensorrt压缩包">2.选择合适的位置解压TensorRT压缩包</span></h2><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/5_TensorRT.jpg" alt="解压TensorRT后的文件"></p><h2><span id="3安装tensorrt">3.安装TensorRT</span></h2><ul><li>将TensorRT的<code>include</code>文件夹中文件复制到CUDA安装位置的<code>include</code>文件夹。</li></ul><p>我的操作是：<code>copy \TensorRT-8.6.1.6\include → NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include</code></p><ul><li><p>将TensorRT的<code>lib</code>中所有lib文件复制到CUDA安装位置的<code>lib\x64</code>文件夹</p></li><li><p>将TensorRT的<code>lib</code>中所有dll文件复制到CUDA安装位置的<code>bin</code>文件夹</p></li></ul><h2><span id="4验证tensort">4.验证TensoRT</span></h2><p>检查系统环境变量中是否有包含了CUDA的bin文件夹，没有则添加。</p><p>使用Visual Studio打开sampleMNIST示例，即打开<code>../TensorRT-8.6.1.6\samples\sampleOnnxMNIST</code>文件夹中的sln文件，必要时对项目属性的常规、VC++目录、C&#x2F;C++里面的环境进行配置，添加依赖。<a href="https://blog.csdn.net/shanglianlm/article/details/92847719">参考</a></p><p>右键项目，点击重新生成。可以点击不调试运行测试。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> YOLOv5 </tag>
            
            <tag> TensorRT </tag>
            
            <tag> C++推演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建一个自己的简单博客</title>
      <link href="/%E6%97%A5%E5%B8%B8/4/"/>
      <url>/%E6%97%A5%E5%B8%B8/4/</url>
      
        <content type="html"><![CDATA[<p>简单几步，基于Hexo搭建一个属于自己的简单博客</p><p>关键词：Hexo、博客</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#%E5%B7%A5%E5%85%B7%E5%87%86%E5%A4%87">工具准备</a><ul><li><a href="#1-nodejs">1. Nodejs</a></li><li><a href="#2-git">2. Git</a></li><li><a href="#3-%E9%AA%8C%E8%AF%81nodejs%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F">3. 验证Nodejs是否安装成功</a></li><li><a href="#4-cnpm">4. cnpm</a></li></ul></li><li><a href="#%E5%AE%89%E8%A3%85hexo">安装Hexo</a></li><li><a href="#%E5%BC%80%E5%A7%8B%E5%BB%BA%E9%80%A0%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2">开始建造你的博客</a><ul><li><a href="#1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%B0%BD%E9%87%8F%E4%B8%8D%E5%86%8D%E7%A7%BB%E5%8A%A8">1. 创建一个新的文件夹，尽量不再移动。</a></li><li><a href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%9A%E5%AE%A2">2. 初始化博客</a></li><li><a href="#3-%E6%9F%A5%E7%9C%8B%E5%8D%9A%E5%AE%A2">3. 查看博客</a></li><li><a href="#4-%E7%BB%99%E5%8D%9A%E5%AE%A2%E4%B8%8B%E8%BD%BD%E4%B8%BB%E9%A2%98next">4. 给博客下载主题——Next</a></li><li><a href="#5-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">5. 修改配置文件</a></li></ul></li><li><a href="#%E7%BC%96%E5%86%99%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%8D%9A%E5%AE%A2">编写你的第一条博客</a></li><li><a href="#%E9%83%A8%E7%BD%B2%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%B0github">部署你的博客到Github</a><ul><li><a href="#1-%E5%9C%A8%E5%8D%9A%E5%AE%A2%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%93%E5%BC%80git-bash%E8%BE%93%E5%85%A5%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%91%BD%E4%BB%A4%E6%8E%A5%E7%9D%80%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BD%A0%E7%9A%84%E5%AF%86%E9%92%A5">1. 在博客根目录打开Git Bash，输入下面的命令，接着会出现你的密钥。</a></li><li><a href="#2-%E5%9C%A8github%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BB%E5%A4%B4%E5%83%8F-settings-ssh-and-gpg-keys-new-ssh-key%E6%8E%A5%E7%9D%80%E6%8A%8A%E5%AF%86%E9%92%A5%E5%A4%8D%E5%88%B6%E4%B8%8A%E5%8E%BB">2. 在Github页面点击头像-&gt;Settings-&gt;SSH and GPG keys-&gt;New SSH key，接着把密钥复制上去。</a></li><li><a href="#3-%E5%86%8D%E5%9C%A8git-bash%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%B8%8B%E9%9D%A2%E5%91%BD%E4%BB%A4">3. 再在Git Bash中执行下面命令。</a></li><li><a href="#4-%E7%82%B9%E5%87%BB%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93%E5%9C%A8%E5%B7%A6%E4%B8%8A%E8%A7%92%E7%9A%84clone-or-download%E4%B8%AD%E7%82%B9%E5%87%BBuse-ssh%E5%A4%8D%E5%88%B6git%E5%BC%80%E5%A4%B4%E7%9A%84%E5%9C%B0%E5%9D%80">4. 点击项目仓库，在左上角的Clone or download中点击Use SSH，复制git开头的地址。</a></li><li><a href="#5-%E6%89%93%E5%BC%80%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%89%BE%E5%88%B0deploy%E4%B8%80%E8%A1%8C%E6%8C%89%E7%85%A7%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%8C%87%E7%A4%BA%E4%BF%AE%E6%94%B9">5. 打开博客配置文件，找到deploy一行，按照下面的指示修改。</a></li><li><a href="#6-%E5%9C%A8%E5%8D%9A%E5%AE%A2%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%93%E5%BC%80git-bash%E5%88%86%E5%88%AB%E6%89%A7%E8%A1%8C%E4%B8%8B%E5%88%97%E5%91%BD%E4%BB%A4">6. 在博客根目录打开Git Bash，分别执行下列命令。</a></li><li><a href="#7-%E5%AE%89%E8%A3%85%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6">7. 安装上传插件。</a></li><li><a href="#8-%E4%BD%BF%E7%94%A8%E4%B8%8B%E9%9D%A2%E6%8C%87%E4%BB%A4%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2">8. 使用下面指令上传博客。</a></li><li><a href="#9-%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93%E9%80%89%E6%8B%A9%E4%B8%8A%E6%96%B9%E7%9A%84settings%E6%89%BE%E5%88%B0pages%E5%9C%A8source%E5%A4%84%E9%80%89%E6%8B%A9deploy-from-a-branch-%E4%B9%8B%E5%90%8E%E5%B0%B1%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9D%80%E4%BE%BF%E6%98%AF%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80">9. 打开项目仓库，选择上方的Settings，找到Pages，在Source处选择Deploy from a branch。之后就会出现一个网站地址，便是博客地址。</a></li></ul></li><li><a href="#%E6%B3%A8">注</a></li></ul><!-- tocstop --><h1><span id="工具准备">工具准备</span></h1><h2><span id="1-nodejs">1. Nodejs</span></h2><p>Nodejs简单来说就是运行在服务端的JavaScript，博客交互需要用到Nodejs。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/4_NodejsDonwload.png" alt="Nodejs下载页面"></p><p>选择合适的软件版本下载，<a href="https://nodejs.cn/download/">下载地址：https://nodejs.cn/download/</a></p><p>下载完成后按正常流程安装，可安装在非系统盘，记得选择“Add to PATH”配置PATH环境变量。我的Nodejs安装在<code>E:\Nodejs</code>中。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/4_Node.png" alt="选择"></p><p>注：为了软件安装简洁可控，还需要对Nodejs的内容（Cache和global）进行规划，具体可参考<a href="https://juejin.cn/post/7227434605392642104">nodejs的安装及详细环境配置</a>或<a href="https://blog.csdn.net/Ouchieve_111/article/details/70878090">修改项目默认node_modules路径</a>或<a href="https://blog.csdn.net/scorpio_meng/article/details/83314675">node安装后的设置(node_global和node_cache) - windows</a>，或自行搜索。</p><h2><span id="2-git">2. Git</span></h2><p>Git是一个分布式版本控制系统，简单理解为它可以帮助我们管理文件各种版本，博客的更新之类的。</p><p><a href="https://git-scm.com/">下载地址：https://git-scm.com/</a></p><p>下载完成后按正常流程安装，可安装在非系统盘，其他选项可以保持默认。我的Git安装在<code>E:\Git</code>中。</p><h2><span id="3-验证nodejs是否安装成功">3. 验证Nodejs是否安装成功</span></h2><p>在桌面鼠标右键，选择菜单中的Git Bash Here。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/4_%E5%8F%B3%E9%94%AE.jpg" alt="右键菜单"></p><p>在弹出的窗口中输入以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>若出现了对应的版本号，则说明安装成功。若不出现版本号，则检查Nodejs的安装过程，或者必应搜索相关帮助。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/4_%E9%AA%8C%E8%AF%81.png" alt="验证Nodejs安装"></p><h2><span id="4-cnpm">4. cnpm</span></h2><p>上面的<code>npm -v</code>查看了npm的版本，可以简单理解为npm是一种下载工具。而npm下载一般是通过国外网络下载，速度比较慢。因此需要先通过npm安装cnpm（国内下载），之后就是用cnpm代替npm。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>通过查询版本号验证是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><h1><span id="安装hexo">安装Hexo</span></h1><p>Hexo是一种博客框架，通过它可以将简单的Markdown语言转化为带装饰的网页。</p><p>通过下面命令安装Hexo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>也可以通过查询版本号确认Hexo是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -V</span><br></pre></td></tr></table></figure><p>Hexo的常用命令：<code>hexo -s</code>本地查看博客，<code>hexo g</code>生成博客，<code>hexo clean</code>删除当前博客所有网页页面。</p><h1><span id="开始建造你的博客">开始建造你的博客</span></h1><h2><span id="1-创建一个新的文件夹尽量不再移动">1. 创建一个新的文件夹，尽量不再移动。</span></h2><p>如我在F盘创建了一个文件夹叫<code>15.Blog</code>，就在15.Blog文件夹下右键选择Git Bash。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/4_%E5%8D%9A%E5%AE%A21.png"></p><h2><span id="2-初始化博客">2. 初始化博客</span></h2><p>在窗口中输入命令，等待完成。（如果运行至<code>Install dependencies</code>卡住，可以<code>Ctrl + C</code>结束命令）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><h2><span id="3-查看博客">3. 查看博客</span></h2><p>在窗口中输入命令，查看博客的初始页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2><span id="4-给博客下载主题next">4. 给博客下载主题——Next</span></h2><p>点击<a href="https://hexo.io/themes/">此处</a>寻找合适的主题，以Next为例，因为该主题基础、自定义程度高。</p><p>可以用git指令将Github的主题压缩包下载到博客的<code>themes/</code>文件夹中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 复制的地址 themes/主题名字</span><br></pre></td></tr></table></figure><p>上面指令意思是将指定地址的内容克隆到本地<code>themes/</code>文件夹并命名为指定名字。<br>也可以直接下载压缩包粘贴至<code>themes/</code>文件夹中。</p><h2><span id="5-修改配置文件">5. 修改配置文件</span></h2><p>在博客的根目录中有一个名为<code>_config</code>的文本文件，在主题目录也有一个名为<code>_config</code>的文本文件，此处做区分，前者为博客配置文件，后者为主题配置文件。</p><p>打开博客配置文件，可以根据<a href="https://hexo.io/zh-cn/docs/configuration">官方配置介绍</a>进行修改个性化博客。<br>将博客配置文件中<code>themes</code>一行填入刚下载的next主题，即可使用该主题。在博客目录打开Git Bash，输入<code>hexo s</code>可以查看博客。</p><p>注意：有些主题你更换之后是暂时无法预览的，因为有的主题还需要安装它需要的依赖。</p><h1><span id="编写你的第一条博客">编写你的第一条博客</span></h1><p>在博客根目录打开Git Bash，输入下面的指令即可创建文章。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;文章名字&quot;</span></span><br></pre></td></tr></table></figure><p>每次生成的文章都固定在你的博客根目录下面的<code>source/_posts</code>下，并以Markdown文件形式编写保存。</p><h1><span id="部署你的博客到github">部署你的博客到Github</span></h1><p>首先需要有一个Github账号，并且新建仓库名为<code>用户名+.github.io</code>。</p><p>接着需要进行一系列的密钥绑定：</p><h2><span id="1-在博客根目录打开git-bash输入下面的命令接着会出现你的密钥">1. 在博客根目录打开Git Bash，输入下面的命令，接着会出现你的密钥。</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “your_email@youremail.com“</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><h2><span id="2-在github页面点击头像-gtsettings-gtssh-and-gpg-keys-gtnew-ssh-key接着把密钥复制上去">2. 在Github页面点击头像-&gt;Settings-&gt;SSH and GPG keys-&gt;New SSH key，接着把密钥复制上去。</span></h2><h2><span id="3-再在git-bash中执行下面命令">3. 再在Git Bash中执行下面命令。</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>接着提示<code>Are you sure you want to continue connecting (yes/no/[fingerprint])? </code>，输入yes回车即可。</p><h2><span id="4-点击项目仓库在左上角的clone-or-download中点击use-ssh复制git开头的地址">4. 点击项目仓库，在左上角的Clone or download中点击Use SSH，复制git开头的地址。</span></h2><h2><span id="5-打开博客配置文件找到deploy一行按照下面的指示修改">5. 打开博客配置文件，找到deploy一行，按照下面的指示修改。</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: 复制到的地址</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><h2><span id="6-在博客根目录打开git-bash分别执行下列命令">6. 在博客根目录打开Git Bash，分别执行下列命令。</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><h2><span id="7-安装上传插件">7. 安装上传插件。</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2><span id="8-使用下面指令上传博客">8. 使用下面指令上传博客。</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2><span id="9-打开项目仓库选择上方的settings找到pages在source处选择deploy-from-a-branch-之后就会出现一个网站地址便是博客地址">9. 打开项目仓库，选择上方的Settings，找到Pages，在Source处选择Deploy from a branch。之后就会出现一个网站地址，便是博客地址。</span></h2><h1><span id="注">注</span></h1><p>如有纰漏，可同步参考<a href="https://www.cnblogs.com/huanhao/p/hexobase.html">此篇博客</a>或自行搜索他人教程相互参考。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用阿里云对象存储OSS实现图床</title>
      <link href="/%E6%97%A5%E5%B8%B8/3/"/>
      <url>/%E6%97%A5%E5%B8%B8/3/</url>
      
        <content type="html"><![CDATA[<p>注册登录阿里云👉开启对象存储👉配置Key👉放心上传</p><p>关键词：对象存储OSS</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#1%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE%E5%BA%8A">1.什么是图床</a></li><li><a href="#2%E5%BC%80%E5%90%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1">2.开启对象存储服务</a></li><li><a href="#3%E4%BD%BF%E7%94%A8picgo%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0">3.使用PicGo工具进行图片上传</a></li></ul><!-- tocstop --><h1><span id="1什么是图床">1.什么是图床</span></h1><p>图床是一种概念，顾名思义用于网络上存放图片。当网站图片过多时，整个网站的存储大小会变得较大，负担也变得较大。为了减轻负担，可以选择把图片置于一种存储容器（图床）中，之后显示图片就只需引用网络链接即可。</p><h1><span id="2开启对象存储服务">2.开启对象存储服务</span></h1><p> 进入<a href="https://cn.aliyun.com/">阿里云官网</a>，点击右上角控制台，搜索对象存储OSS。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/3_1.png" alt="阿里云页面"></p><p>选择创建Bucket，设置建议如下：</p><ul><li>Bucket名称：自定义</li><li>地域：选择距离自己较近的</li><li>存储类型：默认不动</li><li>存储荣誉类型：默认不动</li><li>读写权限：公共读</li></ul><p>创建成功后可在Bucket列表查看。</p><h1><span id="3使用picgo工具进行图片上传">3.使用PicGo工具进行图片上传</span></h1><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/">下载地址</a></p><p>下载后选择合适的盘符安装，打开软件。<br>初始时可能不显示界面，需要去系统任务栏右键软件图标，选择打开主窗口。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/3_2.png" alt="软件打开"></p><p>接着选择图床设置，此处使用阿里云OSS。</p><p>回到阿里云OSS控制台，移动至右上角悬浮，点击AccessKey管理。创建一个新AccessKey，复制并粘贴到PicGo中。</p><p>配置参数建议如下：</p><ul><li>设定KeyID：AccessKey中复制得来</li><li>设定KeySecret：AccessKey中复制得来</li><li>设定Bucket：你Bucket得名字</li><li>设定存储区域：OSS选择的地域</li><li>设定存储路径：图片上传至OSS的文件夹或路径</li></ul><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/3_3.png" alt="配置Key"></p><p>配置完成后即可上传图片，在PicGo的相册中可以获得图片的连接，可在HTML或者Markdown等文件中调用。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象存储OSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个便捷的启动小工具</title>
      <link href="/%E8%BD%AF%E4%BB%B6/tools2/"/>
      <url>/%E8%BD%AF%E4%BB%B6/tools2/</url>
      
        <content type="html"><![CDATA[<p>介绍一个便捷的启动工具、搜索工具——Flow Launcher</p><p>关键词：启动工具</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#1-flow-launcher">1. Flow Launcher</a></li><li><a href="#2%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C">2.使用体验</a></li><li><a href="#3%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD">3.软件下载</a></li><li><a href="#4%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE">4.使用建议</a></li></ul><!-- tocstop --><h1><span id="1-flow-launcher">1. Flow Launcher</span></h1><p>Flow Launcher是一款快速启动软件或者打开文件的工具。</p><p>其特点有：</p><ul><li>整合了Everything搜索工具</li><li>日期时间显示</li><li>文件拖拽</li><li>支持缩写</li><li>可导入插件</li><li>……</li></ul><h1><span id="2使用体验">2.使用体验</span></h1><p>软件界面简约，可设置多款主题、字体。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E6%95%B4%E4%BD%93%E9%A2%84%E8%A7%88.jpg" alt="软件界面"></p><p>设置面板条理清晰，支持自定义，配置一个适合自己的工具。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E8%AE%BE%E7%BD%AE%E9%9D%A2%E6%9D%BF.jpg" alt="设置面板"></p><p>搜索过程简单，直接输入马上得到结果，很适合文件太多不想一个个去翻的人。点击即可打开文件或打开应用。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E6%90%9C%E7%B4%A2%E4%BD%93%E9%AA%8C.jpg" alt="搜索过程"></p><p>支持各种命令，支持缩写。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E6%8C%87%E4%BB%A4.jpg" alt="关机指令"></p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E6%8C%87%E4%BB%A42.jpg" alt="关机指令"></p><h1><span id="3软件下载">3.软件下载</span></h1><p><a href="https://www.flowlauncher.com/">官网下载</a><br><a href="https://github.com/Flow-Launcher/Flow.Launcher">Github源码</a></p><h1><span id="4使用建议">4.使用建议</span></h1><ul><li>开机自启，占用率不算很高，很是方便。</li><li>开启便携模式，增加结果显示个数。<br><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E5%BB%BA%E8%AE%AE.jpg" alt="使用建议1"></li><li>设置好默认文件管理器，默认浏览器。</li><li>自定义插件设置（如默认网页搜索引擎等）。<br><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E5%BB%BA%E8%AE%AE2.jpg" alt="使用建议2"></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 启动工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录Keil_C51和Keil_MDK的安装</title>
      <link href="/%E6%97%A5%E5%B8%B8/2/"/>
      <url>/%E6%97%A5%E5%B8%B8/2/</url>
      
        <content type="html"><![CDATA[<p>介绍Keil_C51和Keil_MDK的安装</p><p>关键词：Keil</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFkeil-c51%E5%92%8Ckeil-mdk">什么是Keil C51和Keil MDK</a></li><li><a href="#keil-c51">Keil C51</a><ul><li><a href="#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F">下载安装程序</a></li><li><a href="#%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">安装过程</a></li><li><a href="#%E5%90%AF%E5%8A%A8%E8%BD%AF%E4%BB%B6">启动软件</a></li></ul></li><li><a href="#keil-mdk">Keil MDK</a><ul><li><a href="#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F-1">下载安装程序</a></li><li><a href="#%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B-1">安装过程</a></li><li><a href="#%E5%90%AF%E5%8A%A8%E8%BD%AF%E4%BB%B6-1">启动软件</a></li></ul></li><li><a href="#keil-key-generator">Keil Key Generator</a></li></ul><!-- tocstop --><h1><span id="什么是keil-c51和keil-mdk">什么是Keil C51和Keil MDK</span></h1><ul><li><p>Keil是一家公司名称，也是一款软件名称。Keil 有四大软件（IDE），包括 MDK、C51、C251、C166。</p></li><li><p>Keil C51和MDK是针对不同类型MCU的两款集成开发工具。</p></li></ul><h1><span id="keil-c51">Keil C51</span></h1><h2><span id="下载安装程序">下载安装程序</span></h2><p><a href="https://www.keil.com/download/product/">Keil官网下载</a></p><h2><span id="安装过程">安装过程</span></h2><p>像正常软件安装一样，按需要更改安装的磁盘，建立新的文件夹空间安装，个人信息随便填，等待安装完成。</p><p>此次我安装路径设置为<code>G:\Keil_C51</code>中。</p><h2><span id="启动软件">启动软件</span></h2><p>UV4可执行文件位于：<code>G:\Keil_C51\UV4</code></p><h1><span id="keil-mdk">Keil MDK</span></h1><h2><span id="下载安装程序">下载安装程序</span></h2><p><a href="https://www.keil.com/download/product/">Keil官网下载</a></p><h2><span id="安装过程">安装过程</span></h2><p>像正常软件安装一样，按需要更改安装的磁盘，建立新的文件夹空间安装本体和Pack文件，个人信息随便填，等待安装完成。</p><p>此次我将本体路径设置为<code>G:\Keil_MDK</code>中，Pack路径设置为<code>G:\Keil_MDK\</code>。</p><h2><span id="启动软件">启动软件</span></h2><p>UV4可执行文件位于：<code>G:\Keil_MDK\UV4</code></p><h1><span id="keil-key-generator">Keil Key Generator</span></h1><p><a href="https://blog.csdn.net/qq_22329595/article/details/108703002">参考此博客</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML语言学习记录</title>
      <link href="/HTML/HTML/"/>
      <url>/HTML/HTML/</url>
      
        <content type="html"><![CDATA[<p>HTML：基础</p><p>关键词：HTML</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#html%E5%89%8D%E8%A8%80">HTML前言</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFhtml">什么是HTML？</a></li><li><a href="#html5">HTML5</a></li><li><a href="#%E5%93%8D%E5%BA%94%E5%BC%8Fweb%E8%AE%BE%E8%AE%A1">响应式Web设计</a></li><li><a href="#html%E6%A0%87%E5%87%86%E5%AD%97%E7%AC%A6%E9%9B%86">HTML标准字符集</a></li><li><a href="#html%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E5%99%A8%E4%B8%8E%E8%B7%AF%E5%BE%84">HTML统一资源定位器与路径</a></li><li><a href="#xhtml">XHTML</a></li></ul></li><li><a href="#html%E5%85%83%E7%B4%A0%E7%90%86%E5%BF%B5">HTML元素理念</a><ul><li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li><li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li><li><a href="#%E5%85%83%E7%B4%A0%E5%AE%9E%E4%BE%8B">元素实例</a></li><li><a href="#%E5%85%83%E7%B4%A0%E5%B5%8C%E5%A5%97">元素嵌套</a></li></ul></li><li><a href="#html%E5%B1%9E%E6%80%A7%E7%90%86%E5%BF%B5">HTML属性理念</a></li><li><a href="#html%E5%A4%B4%E9%83%A8%E5%85%83%E7%B4%A0">HTML头部元素</a></li><li><a href="#html%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0">HTML基本元素</a><ul><li><a href="#html%E6%A0%87%E9%A2%98">HTML标题</a></li><li><a href="#html%E6%AE%B5%E8%90%BD">HTML段落</a></li><li><a href="#html%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B1%BB%E6%A0%87%E7%AD%BE">HTML格式化类标签</a><ul><li><a href="#%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%87%E7%AD%BE">文本格式化标签</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%93%E5%87%BA%E6%A0%87%E7%AD%BE">“计算机输出”标签</a></li><li><a href="#%E5%BC%95%E7%94%A8%E5%92%8C%E6%9C%AF%E8%AF%AD%E5%AE%9A%E4%B9%89">引用和术语定义</a></li></ul></li><li><a href="#html%E9%93%BE%E6%8E%A5">HTML链接</a></li><li><a href="#html%E5%9B%BE%E5%83%8F">HTML图像</a></li><li><a href="#html%E8%A1%A8%E6%A0%BC%E5%85%83%E7%B4%A0">HTML表格元素</a><ul><li><a href="#table%E6%A0%87%E7%AD%BE">table标签</a></li><li><a href="#caption%E6%A0%87%E7%AD%BE">caption标签</a></li><li><a href="#th%E6%A0%87%E7%AD%BE%E4%B8%8Etd%E6%A0%87%E7%AD%BE">th标签与td标签</a></li><li><a href="#tr%E6%A0%87%E7%AD%BE">tr标签</a></li><li><a href="#thead%E6%A0%87%E7%AD%BE-tbody%E6%A0%87%E7%AD%BE%E5%92%8Ctfoot%E6%A0%87%E7%AD%BE">thead标签、tbody标签和tfoot标签</a></li><li><a href="#col%E6%A0%87%E7%AD%BE">col标签</a></li><li><a href="#colgroup%E6%A0%87%E7%AD%BE">colgroup标签</a></li></ul></li><li><a href="#html%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0">HTML列表元素</a><ul><li><a href="#%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8">无序列表</a></li><li><a href="#%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8">有序列表</a></li><li><a href="#%E5%AE%9A%E4%B9%89%E5%88%97%E8%A1%A8">定义列表</a></li><li><a href="#%E5%88%97%E8%A1%A8%E6%A0%87%E7%AD%BE">列表标签</a><ul><li><a href="#ol%E6%A0%87%E7%AD%BE">ol标签</a></li><li><a href="#ul%E6%A0%87%E7%AD%BE">ul标签</a></li><li><a href="#li%E6%A0%87%E7%AD%BE">li标签</a></li><li><a href="#dl%E6%A0%87%E7%AD%BE-dt%E6%A0%87%E7%AD%BE%E5%92%8Cdd%E6%A0%87%E7%AD%BE">dl标签、dt标签和dd标签</a></li><li><a href="#dir%E6%A0%87%E7%AD%BE%E5%92%8Cmenu%E6%A0%87%E7%AD%BE">dir标签和menu标签</a></li></ul></li></ul></li><li><a href="#html%E5%9D%97">HTML块</a><ul><li><a href="#div%E5%85%83%E7%B4%A0">div元素</a></li><li><a href="#span%E5%85%83%E7%B4%A0">span元素</a></li></ul></li><li><a href="#html%E7%B1%BB%E6%A0%87%E7%AD%BE">HTML类标签</a></li><li><a href="#html%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6">HTML内联框架</a></li><li><a href="#html%E5%B8%83%E5%B1%80%E7%B1%BB%E6%A0%87%E7%AD%BE">HTML布局类标签</a><ul><li><a href="#html5%E8%AF%AD%E4%B9%89%E5%85%83%E7%B4%A0">HTML5语义元素</a></li><li><a href="#%E6%A1%86%E6%9E%B6">框架</a><ul><li><a href="#%E6%A0%87%E7%AD%BE">标签</a></li></ul></li></ul></li><li><a href="#html%E8%A1%A8%E5%8D%95">HTML表单</a><ul><li><a href="#form%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7">form元素属性</a><ul><li><a href="#action%E5%B1%9E%E6%80%A7">action属性</a></li><li><a href="#target%E5%B1%9E%E6%80%A7">target属性</a></li><li><a href="#method%E5%B1%9E%E6%80%A7">method属性</a><ul><li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li></ul></li><li><a href="#autocomplete%E5%B1%9E%E6%80%A7">autocomplete属性</a></li><li><a href="#novalidate%E5%B1%9E%E6%80%A7">novalidate属性</a></li><li><a href="#accept-charset%E5%B1%9E%E6%80%A7">accept-charset属性</a></li><li><a href="#enctype%E5%B1%9E%E6%80%A7">enctype属性</a></li><li><a href="#name%E5%B1%9E%E6%80%A7">name属性</a></li><li><a href="#rel%E5%B1%9E%E6%80%A7">rel属性</a></li></ul></li><li><a href="#input%E5%85%83%E7%B4%A0%E8%BE%93%E5%85%A5%E7%B1%BB%E5%9E%8B">input元素输入类型</a><ul><li><a href="#%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5">文本输入</a></li><li><a href="#%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5">密码输入</a></li><li><a href="#%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE%E8%BE%93%E5%85%A5">单选按钮输入</a></li><li><a href="#%E5%A4%8D%E9%80%89%E6%A1%86%E8%BE%93%E5%85%A5">复选框输入</a></li><li><a href="#%E6%8C%89%E9%92%AE%E8%BE%93%E5%85%A5">按钮输入</a></li><li><a href="#%E6%8F%90%E4%BA%A4%E6%8C%89%E9%92%AE">提交按钮</a></li><li><a href="#html5%E6%96%B0%E5%A2%9E%E8%BE%93%E5%85%A5%E7%B1%BB%E5%9E%8B">HTML5新增输入类型</a></li></ul></li><li><a href="#input%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7">input元素属性</a></li><li><a href="#select%E5%85%83%E7%B4%A0"><code>&lt;select&gt;</code>元素</a></li><li><a href="#textarea%E5%85%83%E7%B4%A0">textarea元素</a></li><li><a href="#button%E5%85%83%E7%B4%A0">button元素</a></li></ul></li><li><a href="#html%E5%AA%92%E4%BD%93">HTML媒体</a><ul><li><a href="#html%E5%AF%B9%E8%B1%A1">HTML对象</a><ul><li><a href="#object%E5%85%83%E7%B4%A0">object元素</a></li><li><a href="#embed%E5%85%83%E7%B4%A0">embed元素</a></li></ul></li><li><a href="#html%E9%9F%B3%E9%A2%91">HTML音频</a><ul><li><a href="#audio%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7">audio标签属性</a></li></ul></li><li><a href="#html%E8%A7%86%E9%A2%91">HTML视频</a><ul><li><a href="#video%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7">video标签属性</a></li></ul></li></ul></li><li><a href="#html5%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0">HTML5新增元素</a><ul><li><a href="#fieldset%E5%85%83%E7%B4%A0">fieldset元素</a></li></ul></li></ul></li><li><a href="#html-id%E5%B1%9E%E6%80%A7">HTML id属性</a></li></ul><!-- tocstop --><h1><span id="html前言">HTML前言</span></h1><h2><span id="什么是html">什么是HTML？</span></h2><ul><li>HTML，为HyperTest Markup Language的缩写，意为超文本标记语言。其是一种用于创建网页的标准标记语言。</li><li>HTML由一系列元素组成，可以用于描述网页的结构。</li><li>HTML使用各种元素使得浏览器展示内容，并使用元素标记内容片段。</li><li>作为HTML文件，必须以一个声明开始。<br>这个声明表示文档类型，帮助浏览器正确展示网页内容。其只需在每个文档开头出现一次，它也不注重大小写。一般的HTML5文件以<code>&lt;!DOCTYPE html&gt;</code>开始。</li><li>HTML文件应该以<code>&lt;html&gt;</code>开始并以<code>&lt;/html&gt;</code>结束。</li><li>HTML文件的可视部分应该在<code>&lt;body&gt;</code>和<code>&lt;/body&gt;</code>之间。</li><li>HTML整体是大小写不敏感，但为了格式与美观，一般有统一的标准。</li><li>HTML使用<code>&lt;!-- --&gt;</code>进行注释。</li></ul><h2><span id="html5">HTML5</span></h2><ul><li>HTML5 是最新的 HTML 标准。</li><li>HTML5 是专门为承载丰富的 web 内容而设计的，并且无需额外插件。</li><li>HTML5 拥有新的<a href="https://www.w3school.com.cn/html/html5_browsers.asp">语义</a>、图形以及多媒体元素。</li><li>HTML5 提供的新<a href="https://www.w3school.com.cn/html/html5_new_elements.asp">元素</a>和新的 API 简化了 web 应用程序的搭建。</li><li>HTML5 是跨平台的，被设计为在不同类型的硬件（PC、平板、手机、电视机等等）之上运行。</li></ul><h2><span id="响应式web设计">响应式Web设计</span></h2><ul><li>响应式Web设计，Responsive Web Design，能够以可变尺寸传递网页。</li><li>可以使用Bootstrap创建响应式设计。</li></ul><h2><span id="html标准字符集">HTML标准字符集</span></h2><ul><li>为了正确显示HTML页面，在<code>&lt;meta&gt;</code>标签中设置编码。如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>字符集有很多，如ASCII码，UTF-8码，ISO-8859-1码，推荐用UTF-8码。</li><li>在使用某些字符时，存在歧义，使用<a href="https://www.w3school.com.cn/charsets/ref_html_8859.asp">实体代码或编号</a>表示。</li><li><a href="https://www.w3school.com.cn/charsets/ref_utf_punctuation.asp">更多字符</a></li></ul><h2><span id="html统一资源定位器与路径">HTML统一资源定位器与路径</span></h2><ul><li>统一资源定位器和路径不完全相同。</li><li>URL，Uniform Resource Locator，统一资源定位器，也被称为网址。</li><li>URL 只能使用 ASCII 字符集来通过因特网进行发送。URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。</li><li>网址具有一定的语法规则：scheme:&#x2F;&#x2F;host.domain:port&#x2F;path&#x2F;filename<br>scheme定义因特网服务类型，常见为http和https。<br>host定义域主机，http默认主机是www。<br>domain定义因特网域名。<br>:port定义主机上的端口号。<br>path定义服务器上的路径，省略默认根目录。<br>filename定义文档、资源的名称。</li><li>路径描述了网站文件夹结构中某个文件的位置，使用相对路径是个好习惯。</li></ul><h2><span id="xhtml">XHTML</span></h2><ul><li>XHTML是指可扩展超文本标记语言，是更严格更纯净的HTML版本。</li><li>其与HTML4.01几乎相同。</li></ul><h1><span id="html元素理念">HTML元素理念</span></h1><h2><span id="定义">定义</span></h2><ul><li>HTML 元素指的是从开始标签（<code>&lt;xxx&gt;</code>）到结束标签（<code>&lt;/xxx&gt;</code>）的所有代码。其包含开始标签，内容和结束标签。</li></ul><h2><span id="语法">语法</span></h2><ul><li>HTML元素以开始标签起始。</li><li>HTML元素以结束标签终止。</li><li>元素的内容是开始标签与结束标签之间的内容。</li><li>某些HTML元素具有空内容。</li><li>没有内容的 HTML 元素被称为空元素。空元素在开始标签中进行关闭（以开始标签的结束而结束，即无结束标签）。</li><li>在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。在开始标签中添加斜杠，比如 <code>&lt;br /&gt;</code>，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。即使<code>&lt;br&gt;</code>在所有浏览器中都是有效的，但使用<code>&lt;br /&gt;</code>其实是更长远的保障。</li><li>大多数HTML元素可拥有属性。</li></ul><h2><span id="元素实例">元素实例</span></h2><ul><li>如<code>&lt;html&gt;</code>和<code>&lt;/html&gt;</code>元素（<code>&lt;html&gt;</code>与<code>&lt;/html&gt;</code>标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。），<code>&lt;body&gt;</code>和<code>&lt;/body&gt;</code>元素（body元素包含文档的所有内容），HTML标题，HTML段落，HTML链接，HTML图像等。</li></ul><h2><span id="元素嵌套">元素嵌套</span></h2><ul><li><p>大多数HTML元素可以嵌套（即包含其他HTML元素）如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标签&lt;p&gt;表示段落元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1><span id="html属性理念">HTML属性理念</span></h1><ul><li>属性为 HTML 元素提供附加信息。</li><li>HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。</li><li>属性总是在 HTML 元素的开始标签中规定。</li><li>属性总是以名称或值对的形式出现</li><li><a href="https://www.w3school.com.cn/tags/html_ref_standardattributes.asp">HTML全局属性</a></li></ul><h1><span id="html头部元素">HTML头部元素</span></h1><ol><li><code>&lt;head&gt;</code>元素</li></ol><ul><li>定义关于文档的信息。</li><li><code>&lt;head&gt;</code>标签放在文档的开始处，紧跟在<code>&lt;html&gt;</code>后面，并处于<code>&lt;body&gt;</code>标签或<code>&lt;frameset&gt;</code>标签之前。</li><li><code>&lt;head&gt;</code>元素是所有头部元素的容器。<code>&lt;head&gt;</code>内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息，等等。以下标签都可以添加到 head 部分：<code>&lt;title&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>、<code>&lt;script&gt;</code>以及<code>&lt;style&gt;</code>。</li><li>属性<br>profile，可以设置URL，一个由空格分隔的URL列表，这些URL包含有关页面的元数据信息。<br>文档的头部经常会包含一些<code>&lt;meta&gt;</code>标签，用来告诉浏览器关于文档的附加信息。在将来，创作者可能会利用预先定义好的标准文档的元数据配置文件（metadata profile），以便更好地描述它们的文档。profile属性提供了与当前文档相关联的配置文件的 URL。</li></ul><ol start="2"><li><code>&lt;title&gt;</code>元素</li></ol><ul><li>定义文档标题，定义浏览器工具栏中的标题，定义页面被收藏时显示的标题，定义显示在搜索引擎结果中的页面标题。</li><li>title元素在所有 HTML&#x2F;XHTML文档中都是必需的。</li><li>属性</li></ul><p>dir，可以设置值，规定元素中内容的文本方向。</p><p>lang，可以设置代码，规定元素中内容的语言代码。</p><p>xml:lang，可以设置代码，规定XHTML文档中元素内容的语言代码。</p><ol start="3"><li><code>&lt;base&gt;</code>元素</li></ol><ul><li>定义页面上所有链接的默认地址或默认目标（target）。</li><li>其必须位于head元素内部。</li><li>属性</li></ul><p>href，可以设置URL，规定页面中所有相对链接的基准URL。即设置默认地址。</p><p>target，可以设置值，规定在何处打开页面中的所有链接。值包括“_blank”，“_parent”，“_self”，“_top”，和框架名。</p><ol start="4"><li><code>&lt;link&gt;</code>元素</li></ol><ul><li>定义文档与外部资源之间的关系。</li><li><code>&lt;link&gt;</code>标签最常用于连接样式表。</li><li>属性</li></ul><p>charset，可以设置字符编码方式，在HTML5不支持。</p><p>href，可以设置URL，规定被链接文档的位置。</p><p>hreflang，可以设置语言代码，规定被链接文档中文本的语言。</p><p>media，可以设置媒体查询，规定被链接文档将被显示在什么设备上。</p><p>referrerpolicy，可以设置值，规定在获取资源时使用的引荐来源信息。值包括“no-referrer”，“no-referrer-when-downgrade”，“origin”，“origin-when-cross-origin”，“unsafe-url”。</p><p>rel，可以设置值，规定当前文档与被链接文档之间的关系。值包括“alternate”，“author”，“help”，“icon”，“licence”，“next”，“pingback”，“prefetch”，“prev”，“search”，“sidebar”，“stylesheet”，“tag”。</p><p>rev，可以设置反向关系，在HTML5中不支持。</p><p>sizes，可以设置值，规定被链接资源的尺寸，仅适用<code>rel=&quot;icon&quot;</code>。值包括“heightxwidth”，“any”。</p><p>target，可以设置目标，在HTML5中不支持。</p><p>type，可以设置MIME类型，规定被链接文档的MIME类型。</p><ol start="5"><li><code>&lt;style&gt;</code>元素</li></ol><ul><li>定义文档的样式信息。如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:red&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Header 1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>属性</li></ul><p>type，只能设置text&#x2F;css，规定样式表的MIME类型。</p><p>media，可以设置值，为样式表规定不同的媒介类型。值包括“screen”，“tty”，“tv”，“projection”，“handheld”，“print”，“braille”，“aural”，“all”。</p><ol start="6"><li><code>&lt;meta&gt;</code>元素</li></ol><ul><li>定义关于HTML文档的元数据。</li><li><code>&lt;meta&gt;</code>标签位于文档的头部，不包含任何内容。<code>&lt;meta&gt;</code>标签的属性定义了与文档相关联的名称&#x2F;值对。</li><li><code>&lt;meta&gt;</code>无结束标签。</li><li>属性</li></ul><p>charset，可以设置字符，规定HTML文档的字符编码。</p><p>content，可以设置文本，定义与http-equiv或name相关的元信息。</p><p>content 属性提供了名称&#x2F;值对中的值。该值可以是任何有效的字符串。content 属性始终要和name属性或http-equiv属性一起使用。</p><p>http-equiv，可以设置值，把content属性关联到HTTP头部。值包括“content-security-policy”，“content-type”，“default-style”，“refresh”。</p><p>name，可以设置值，把content属性关联到一个名称。值包括“application-name”，“author”，“description”，“generator”，“keywords”，“viewport”。</p><p>scheme，可以设置一些文本，定义用于解释content属性值的格式。scheme 属性用于指定要用来翻译属性值的方案。此方案应该在由 <code>&lt;head&gt;</code>标签的 profile 属性指定的概况文件中进行了定义。</p><ol start="7"><li><code>&lt;script&gt;</code>元素</li></ol><ul><li>定义客户端脚本。比如JavaScript。</li><li>属性</li></ul><p>async，规定异步执行脚本（仅适用于外部脚本）。</p><p>charset，可以设置编码，规定在外部脚本文件中使用的字符编码。</p><p>crossorigin，可以设置值，将请求模式设置为HTTP CORS请求。值包括“anonymous”，“use-credentials”。</p><p>defer，规定是否对脚本执行进行延迟，直到页面加载为止。</p><p>language，规定脚本语言，不赞成使用，用type代替。</p><p>referrerpolicy，可以设置值，规定外部脚本文件的URL。值包括“no-referrer”，“no-referrer-when-downgrade”，“origin”，“origin-when-cross-origin”，“same-origin”，“strict-origin”，“strict-origin-when-cross-origin”，“unsafe-url”。</p><p>src，可以设置URL，规定外部脚本文件的URL。</p><p>xml:space，规定是否保留代码中的空白。</p><p>type，可以设置MIME类型，指示脚本的MIME类型。</p><h1><span id="html基本元素">HTML基本元素</span></h1><h2><span id="html标题">HTML标题</span></h2><ul><li>标题（Heading）是通过<code>&lt;h1&gt;</code>~&#96;<h6><span id="等标签进行定义的-定义最大的标题-96定义最小的标题"><code>等标签进行定义的。</code><h1><code>定义最大的标题。</code><h6>&#96;定义最小的标题。</h6></h1></span></h6></li><li>具有“align”属性，其值有“left”、“center”、“right”和“justify”，规定了标题中文本的排列。</li><li><code>&lt;hr /&gt;</code>标签在 HTML 页面中创建水平线。hr元素可用于分隔内容。</li></ul><h2><span id="html段落">HTML段落</span></h2><ul><li>段落是通过<code>&lt;p&gt;</code>标签定义的。</li><li>具有“align”属性，其值有“left”、“center”、“right”和“justify”，规定了段落中文本的排列。</li><li><code>&lt;br /&gt;</code>标签可以在段落中进行换行。</li></ul><h2><span id="html格式化类标签">HTML格式化类标签</span></h2><h3><span id="文本格式化标签">文本格式化标签</span></h3><ul><li><code>&lt;b&gt;</code>和<code>&lt;/b&gt;</code>加粗字体</li><li><code>&lt;strong&gt;</code>和<code>&lt;/strong&gt;</code>加重语气</li><li><code>&lt;big&gt;</code>和<code>&lt;/big&gt;</code>加大字体</li><li><code>&lt;small&gt;</code>和<code>&lt;/small&gt;</code>小字体</li><li><code>&lt;em&gt;</code>和<code>&lt;/em&gt;</code>着重文字</li><li><code>&lt;i&gt;</code>和<code>&lt;/i&gt;</code> 斜体字</li><li><code>&lt;sup&gt;</code>和<code>&lt;/sup&gt;</code>上标</li><li><code>&lt;sub&gt;</code>和<code>&lt;/sub&gt;</code>下标</li><li><code>&lt;del&gt;</code>和<code>&lt;/del&gt;</code>删除字</li><li><code>&lt;ins&gt;</code>和<code>&lt;/ins&gt;</code>下划线</li></ul><h3><span id="计算机输出标签">“计算机输出”标签</span></h3><ul><li><code>&lt;code&gt;</code>和<code>&lt;/code&gt;</code>计算机代码字体</li><li><code>&lt;kbd&gt;</code>和<code>&lt;/kbd&gt;</code>键盘码字体</li><li><code>&lt;samp&gt;</code>和<code>&lt;/samp&gt;</code>计算机代码样本字体</li><li><code>&lt;tt&gt;</code>和<code>&lt;/tt&gt;</code>打字机代码字体</li><li><code>&lt;var&gt;</code>和<code>&lt;/var&gt;</code>定义变量字体</li><li><code>&lt;pre&gt;</code>和<code>&lt;/pre&gt;</code>预格式文本字体</li></ul><h3><span id="引用和术语定义">引用和术语定义</span></h3><ul><li><code>&lt;abbr&gt;</code>和<code>&lt;/abbr&gt;</code>定义缩写，鼠标悬浮显示内容</li><li><code>&lt;acronym&gt;</code>和<code>&lt;/acronym&gt;</code>定义首字母缩写，鼠标悬浮显示内容。</li><li><code>&lt;address&gt;</code>和<code>&lt;/address&gt;</code>定义地址</li><li><code>&lt;bdo&gt;</code>和<code>&lt;/bdo&gt;</code>定义文字方向，具有dir属性，值为“rtl”(right-to-left)和“ltr”(left-to-right)</li><li><code>&lt;blockquote&gt;</code>和<code>&lt;/blockquote&gt;</code>定义长引用</li><li><code>&lt;q&gt;</code>和<code>&lt;/q&gt;</code>定义短引用</li><li><code>&lt;cite&gt;</code>和<code>&lt;/cite&gt;</code>定义引用、引证；<code>&lt;dfn&gt;</code>和<code>&lt;/dfn&gt;</code>定义项目。</li></ul><h2><span id="html链接">HTML链接</span></h2><ul><li>链接或者超链接，可以是一个字、一个词、一幅画像，可以点击跳转到新的内容。</li><li>链接是通过<code>&lt;a&gt;</code>定义的。</li><li>开始标签和结束标签之间的文字被作为超级链接来显示。超级链接可以是文本、图片或者其他HTML元素。</li><li><code>&lt;a&gt;</code>标签具有href属性和name属性，href属性用于创建指向另一个文档的链接，name属性用于创建文档内的书签。用法如下。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span> = <span class="string">&quot;flag&quot;</span>&gt;</span>这是一句话<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://cn.bing.com/&quot;</span> &gt;</span>A link to Bing<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;#flag&quot;</span>&gt;</span>跳转到顶部句子<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;a&gt;</code>标签具有target属性，其用于定义被链接的文档在何处显示。如<code>&lt;a href=&quot;http://cn.bing.com/&quot; target=&quot;_blank&quot;&gt;A Link&lt;/a&gt;</code>中的<code>target=&quot;_blank&quot;</code>表示在新的窗口打开文档。</li></ul><h2><span id="html图像">HTML图像</span></h2><ul><li>在 HTML 中，图像由<code>&lt;img&gt;</code>标签定义。<code>&lt;img&gt;</code>是空标签，意思是说，它只包含属性，并且没有闭合标签。</li><li>页面上显示图像需要使用源属性（src，source），源属性的值是图像的URL地址。如：<code>&lt;img src=&quot;xxx/image.jpg&quot;&gt;</code>，则image这个jpg文件需要在源属性的值的地址上。</li><li>替换文本属性（Alt），用来为图像定义一串预备的可替换的文本。替换文本属性的值是人为定义的。即当图片无法显示时，展示alt属性的值的文字。如：<code>&lt;img src=&quot;xxx/a.jpg&quot; alt=&quot;test&quot;&gt;</code>，当a.jpg无法显示时，显示test。</li><li>img标签中可以使用align属性进行图像与文本对齐。此处align的值可选“bottom”、“middle”和“top”，默认bottom对齐。</li><li>img标签中可以使用align属性进行文本和图像位置设定。此处align的值可选“left”、“right”，分别用于图像固定段落的左端和右端。</li><li>img标签中可以使用width和height属性进行更改图像的大小。如：<code>&lt;img src=&quot;xxx/a.jpg&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;</code></li><li>可以将<code>&lt;a&gt;</code>标签和<code>&lt;img&gt;</code>结合，制作能跳转链接的图片。如：<code>&lt;a href=&quot;http://cn.bing.cn&quot;&gt;&lt;img src=&quot;xxx/a.jpg&quot;&gt;&lt;/a&gt;</code></li><li>img标签中还有以下属性</li></ul><table><thead><tr><th align="center">属性</th><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">border</td><td align="center">像素值</td><td align="center">定义图像周围的边框</td></tr><tr><td align="center">hspace</td><td align="center">像素值</td><td align="center">定义图像左侧和右侧的空白</td></tr><tr><td align="center">ismap</td><td align="center">URL</td><td align="center">将图像定义为服务器端图像映射</td></tr><tr><td align="center">loading</td><td align="center">eager&#x2F;lazy</td><td align="center">规定浏览器是立即加载图像还是推迟加载屏幕外图像</td></tr><tr><td align="center">longdesc</td><td align="center">URL</td><td align="center">指向包含长的图像描述文档的URL</td></tr><tr><td align="center">referrerpolicy</td><td align="center">no-referrer&#x2F;no-referrer-when-downgrade&#x2F;origin&#x2F;origin-when-cross-origin&#x2F;unsafe-url</td><td align="center">规定获取图像时要使用的引荐来源信息</td></tr><tr><td align="center">usemap</td><td align="center">URL</td><td align="center">将图像定义为客户器端图像映射</td></tr><tr><td align="center">vspace</td><td align="center">像素值</td><td align="center">定义图像顶部和底部的空白</td></tr></tbody></table><ul><li>在body标签中使用background属性可以使用图像作为背景。但如果图像小于页面，图像会进行重复。</li><li>使用<code>&lt;map&gt;</code>标签和<code>&lt;area&gt;</code>标签制作图像映射。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;xxx/a.jpg&quot;</span> <span class="attr">usemap</span>=<span class="string">&quot;#amap&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--map标签中有属性name和id，与img标签usemap对应--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--map标签中id属性时必须且唯一的，name属性时可选的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;amap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;amap&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--area标签中有shape属性、coords属性等--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;180,139,14&quot;</span> <span class="attr">href</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;129,161,10&quot;</span> <span class="attr">href</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;rect&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;0,0,110,260&quot;</span> <span class="attr">href</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>area标签的其他属性如下：</p><table><thead><tr><th align="center">属性</th><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">coords</td><td align="center">坐标值</td><td align="center">定义可点击区域的坐标和大小</td></tr><tr><td align="center">download</td><td align="center">文件名</td><td align="center">指定用户点击超链接时下载目标</td></tr><tr><td align="center">href</td><td align="center">URL</td><td align="center">此区域目标URL</td></tr><tr><td align="center">hreflang</td><td align="center">language_code</td><td align="center">规定区域中URL的语言</td></tr><tr><td align="center">media</td><td align="center">media query</td><td align="center">规定目标URL优化的媒体、设备</td></tr><tr><td align="center">referrerpolicy</td><td align="center">no-referrer&#x2F;no-referrer-when-downgrade&#x2F;origin&#x2F;origin-when-cross-origin&#x2F;same-origin&#x2F;strict-origin-when-cross-origin&#x2F;unsafe-url</td><td align="center">规定用户单击超链接时发送引荐来源信息</td></tr><tr><td align="center">rel</td><td align="center">alternate&#x2F;author&#x2F;bookmark&#x2F;help&#x2F;licence&#x2F;next&#x2F;nofollow&#x2F;noreferrer&#x2F;prefatch&#x2F;prev&#x2F;search&#x2F;tag</td><td align="center">规定区域中目标URL的语言</td></tr><tr><td align="center">nohref</td><td align="center">nohref</td><td align="center">从图像映射排除某个区域</td></tr><tr><td align="center">shape</td><td align="center">default&#x2F;rect&#x2F;circ&#x2F;poly</td><td align="center">定义区域形状</td></tr><tr><td align="center">target</td><td align="center">_blank&#x2F;_parent&#x2F;_self&#x2F;_top</td><td align="center">规定在何处打开href属性指定目标的URL</td></tr><tr><td align="center">type</td><td align="center">media_type</td><td align="center">规定目标URL的Internet媒体类型</td></tr></tbody></table><h2><span id="html表格元素">HTML表格元素</span></h2><ul><li>表格由<code>&lt;table&gt;</code>标签定义。每个表格均有若干行（由<code>&lt;tr&gt;</code>标签定义），每行被分割为若干单元格（由<code>&lt;td&gt;</code>标签定义）。</li><li>字母 tr 指一行（table row）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</li><li>表格的表头用<code>&lt;th&gt;</code>标签表示。</li><li>为了避免空单元边框（添加border属性）不显示，在空单元格中添加一个空格占位符（<code>&amp;nbsp;</code>），就可以将边框显示出来。</li><li>表格标签：</li></ul><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>&lt;table&gt;</code></td><td align="center">定义表格</td></tr><tr><td align="center"><code>&lt;caption&gt;</code></td><td align="center">定义表格标题</td></tr><tr><td align="center"><code>&lt;th&gt;</code></td><td align="center">定义表格的表头</td></tr><tr><td align="center"><code>&lt;tr&gt;</code></td><td align="center">定义表格的行</td></tr><tr><td align="center"><code>&lt;td&gt;</code></td><td align="center">定义表格单元</td></tr><tr><td align="center"><code>&lt;thead&gt;</code></td><td align="center">定义表格的页眉</td></tr><tr><td align="center"><code>&lt;tbody&gt;</code></td><td align="center">定义表格主体</td></tr><tr><td align="center"><code>&lt;tfoot&gt;</code></td><td align="center">定义表格页脚</td></tr><tr><td align="center"><code>&lt;col&gt;</code></td><td align="center">用于表格列的属性</td></tr><tr><td align="center"><code>&lt;colgroup&gt;</code></td><td align="center">定义表格列的组</td></tr></tbody></table><h3><span id="table标签">table标签</span></h3><ul><li>属性</li></ul><p>align，可以设置值，规定表格相对周围元素的对齐方式。值包括“left”，“right”，“center”。不赞成使用，用样式代替。</p><p>bgcolor，可以设置rgb值或十六进制颜色或颜色名，规定表格的背景颜色。不赞成使用，用样式代替。</p><p>border，可以设置像素值，规定表格边框的宽度。</p><p>cellpadding，可以通过设置百分比或像素值，规定单元边沿与其内容之间的空白。</p><p>cellspacing，可以通过设置百分比或像素值，规定单元格之间的空白。</p><p>frame，可以通过设置值，规定外侧边框的哪个部分时可见的。值包括“void”，“above”，“below”，“hsides”，“lhs”，“rhs”，“vsides”，“box”，“border”。</p><p>rules，可以通过设置值，规定内侧边框的哪个部分时可见的。值包括“none”，“groups”，“rows”，“cols”，“all”。</p><p>summary，可以通过设置文本，规定表格的摘要。</p><p>width，可以通过设置百分比或像素值，规定表格的宽度。</p><h3><span id="caption标签">caption标签</span></h3><ul><li><p>caption 元素定义表格标题。caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。</p></li><li><p>属性</p></li></ul><p>其属性有align，可以设置值，规定标题的对齐方式。值包括“left”，“right”，“top”，“bottom”。不赞成使用，用样式代替。</p><h3><span id="th标签与td标签">th标签与td标签</span></h3><ul><li>定义表格内的表头单元格。</li><li>HTML 表单中有两种类型的单元格：<br>表头单元格 - 包含表头信息（由 th 元素创建）<br>标准单元格 - 包含数据（由 td 元素创建）</li><li>th 元素内部的文本通常会呈现为居中的粗体文本，而 td 元素内的文本通常是左对齐的普通文本。如果需要将内容横跨多个行或列，请使用 colspan 和 rowspan 属性。</li><li>属性</li></ul><p>abbr，可以通过设置文本，规定单元格中内容的缩写版本。</p><p>align，可以通过设置值，规定单元格内容的水平对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。</p><p>axis，可以设置分类名字，对单元格进行分类。</p><p>bgcolor，可以设置rgb值或十六进制颜色或颜色名，规定表格的背景颜色。不赞成使用，用样式代替。</p><p>char，可以设置字符，规定根据哪个字符进行内容的对齐。</p><p>charoff，可以设置数字，规定对齐字符的偏移量。</p><p>colspan，可以设置数字，规定单元格可跨越的列数。</p><p>headers，可以设置属性类型，由空格分隔的表头单元格ID列标，为数据单元格提供表头信息。</p><p>nowrap，可以设置值，规定单元格中是否折行。不推荐使用，用样式代替。</p><p>rowspan，可以设置数字，规定单元格可横跨的行数。</p><p>scope，可以设置值，定义将表头数据与单元数据相关联的方法。值包括“col”，“clogroup”，“row”，“rowgroup”。</p><p>valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。</p><p>width，可以设置百分比或像素值，规定表格单元格的宽度。不推荐使用，用样式代替。</p><p>height，可以设置百分比或像素值，规定表格单元格的高度。不推荐使用，用样式代替。</p><h3><span id="tr标签">tr标签</span></h3><ul><li>属性</li></ul><p>align，可以通过设置值，规定表格行内容对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。</p><p>bgcolor，可以设置rgb值或十六进制颜色或颜色名，规定表格的背景颜色。不赞成使用，用样式代替。</p><p>char，可以设置字符，规定根据哪个字符进行内容的对齐。</p><p>charoff，可以设置数字，规定对齐字符的偏移量。</p><p>valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。</p><h3><span id="thead标签-tbody标签和tfoot标签">thead标签、tbody标签和tfoot标签</span></h3><ul><li><code>&lt;thead&gt;</code>标签定义表格的表头。thead 元素应该与 tbody 和 tfoot 元素结合起来使用。</li><li>tbody 元素用于对 HTML 表格中的主体内容进行分组，而 tfoot 元素用于对 HTML 表格中的表注（页脚）内容进行分组。</li><li>如果使用 thead、tfoot 以及 tbody 元素，就必须使用全部的元素。它们的出现次序是：thead、tfoot、tbody。必须在 table 元素内部使用这些标签。</li><li>属性</li></ul><p>align，可以通过设置值，规定元素中内容对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。</p><p>char，可以设置字符，规定根据哪个字符进行内容的对齐。</p><p>charoff，可以设置数字，规定对齐字符的偏移量。</p><p>valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。</p><h3><span id="col标签">col标签</span></h3><ul><li><code>&lt;col&gt;</code>标签为表格中一个或多个列定义属性值。</li><li>如需对全部列应用样式，<code>&lt;col&gt;</code>标签很有用，这样就不需要对各个单元和各行重复应用样式了。</li><li>只能在 table 或 colgroup 元素中使用<code>&lt;col&gt;</code>标签。</li><li>无结束标签。</li><li>为<code>&lt;col&gt;</code>标签添加 class 属性。这样就可以使用 CSS 来负责对齐方式、宽度和颜色等等。</li><li>属性</li></ul><p>align，可以通过设置值，规定与col元素相关的内容的水平对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。</p><p>char，可以设置字符，规定根据哪个字符进行内容的对齐。</p><p>charoff，可以设置数字，规定对齐字符的偏移量。</p><p>span，可以设置数字，规定col元素应该跨越的列数。</p><p>valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。</p><p>width，可以设置百分比或像素值或相关长度，规定col元素的宽度。</p><h3><span id="colgroup标签">colgroup标签</span></h3><ul><li><code>&lt;colgroup&gt;</code>标签用于对表格中的列进行组合，以便对其进行格式化。</li><li>如需对全部列应用样式，<code>&lt;colgroup&gt;</code>标签很有用，这样就不需要对各个单元和各行重复应用样式了。</li><li><code>&lt;colgroup&gt;</code>标签只能在 table 元素中使用。</li><li>属性</li></ul><p>align，可以通过设置值，定义在列组合中内容的水平对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。</p><p>char，可以设置字符，规定根据哪个字符进行内容的对齐。</p><p>charoff，可以设置数字，规定对齐字符的偏移量。</p><p>span，可以设置数字，规定列组应该跨越的列数。</p><p>valign，可以设置值，定义在列组合中内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。</p><p>width，可以设置百分比或像素值或相关长度，规定列组合的宽度。</p><h2><span id="html列表元素">HTML列表元素</span></h2><h3><span id="无序列表">无序列表</span></h3><ul><li>无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。</li><li>无序列表始于<code>&lt;ul&gt;</code>标签（unordered_list）。每个列表项始于<code>&lt;li&gt;</code>标签（list）。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。</li></ul><h3><span id="有序列表">有序列表</span></h3><ul><li>有序列表始于<code>&lt;ol&gt;</code>标签（ordered_list）。每个列表项始于<code>&lt;li&gt;</code>标签（list）。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。</li></ul><h3><span id="定义列表">定义列表</span></h3><ul><li>自定义列表不仅仅是一列项目，而是项目及其注释的组合。</li><li>自定义列表以<code>&lt;dl&gt;</code>标签开始。每个自定义列表项以<code>&lt;dt&gt;</code>开始。每个自定义列表项的定义以<code>&lt;dd&gt;</code>开始。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>White cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="列表标签">列表标签</span></h3><h4><span id="ol标签">ol标签</span></h4><ul><li>定义有序列表。</li><li>属性</li></ul><p>compact，不赞成使用。</p><p>reversed，设置列表顺序为降序。</p><p>start，可以设置数字，规定有序列表的起始值。</p><p>type，可以设置值，规定在列表中使用的标记类型。值包括“1”，“A”，“a”，“I”，“i”。</p><h4><span id="ul标签">ul标签</span></h4><ul><li>定义无序列表。</li><li>属性</li></ul><p>compact，不赞成使用。</p><p>type，可以设置值，规定在列表中使用的标记类型。值包括“disc”，“square”，“circle”。</p><h4><span id="li标签">li标签</span></h4><ul><li>定义列表项目。</li><li>用于<code>&lt;ol&gt;</code>标签或<code>&lt;ul&gt;</code>标签中。</li><li>属性</li></ul><p>type，不赞成使用，值如上5+3，共8种。</p><p>value，不赞成使用，规定项目的数字。</p><h4><span id="dl标签-dt标签和dd标签">dl标签、dt标签和dd标签</span></h4><ul><li><code>&lt;dl&gt;</code>标签定义定义列表。</li><li><code>&lt;dt&gt;</code>标签定义定义项目。</li><li><code>&lt;dd&gt;</code>标签定义定义描述。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>一个定义列表：<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>计算机<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>用来计算的仪器 ... ...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>显示器<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>以视觉方式显示信息的装置 ... ...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4><span id="dir标签和menu标签">dir标签和menu标签</span></h4><ul><li>已废弃，使用<code>&lt;ul&gt;</code>标签代替。</li></ul><h2><span id="html块">HTML块</span></h2><ul><li>大多数 HTML 元素被定义为块级元素（block level element）或内联元素（inline element）。</li><li>块级元素在浏览器显示时，通常会以新行来开始（和结束）而内联元素在显示时通常不会以新行开始。</li></ul><h3><span id="div元素">div元素</span></h3><ul><li><code>&lt;div&gt;</code>用于定义文档中的分区或节（division&#x2F;section）。</li><li>HTML<code>&lt;div&gt;</code>元素是块级元素，它是可用于组合其他 HTML 元素的容器。浏览器通常会在 div 元素前后放置一个换行符。</li><li><code>&lt;div&gt;</code>元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。如果与 CSS 一同使用，<code>&lt;div&gt;</code>元素可用于对大的内容块设置样式属性。</li><li><code>&lt;div&gt;</code>元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用<code>&lt;div&gt;</code>元素来组合块级元素，这样就可以使用样式对它们进行格式化。如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用div分块，并用class标识和更改颜色为蓝色--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:blue&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>align属性，可以设置值，规定div元素中的内容的对齐方式。不赞成使用，用样式取代。<br>值包括“left”、“right”、“center”、“justify”。</p><h3><span id="span元素">span元素</span></h3></li><li><p><code>&lt;span&gt;</code>用于组合文档中的行内元素。</p></li><li><p>HTML<code>&lt;span&gt;</code>元素是内联元素，可用作文本的容器。</p></li><li><p><code>&lt;span&gt;</code>元素也没有特定的含义。当与 CSS 一同使用时，<code>&lt;span&gt;</code>元素可用于为部分文本设置样式属性。如：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在html中标识class，并使用span组合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;tip&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>强调：<span class="tag">&lt;/<span class="name">span</span>&gt;</span>... ... ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在CSS文件中统一设置span的格式*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.tip</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#ff9955</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>&lt;span&gt;</code>来组合行内元素，以便通过样式来格式化它们。</li></ul><h2><span id="html类标签">HTML类标签</span></h2><ul><li>使用class标识分类，进行内容格式化。如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--CSS样式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.cities</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>:black;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>:white;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125; </span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">span</span><span class="selector-class">.place</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>:blue;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>:white;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;    </span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--使用class名整体格式化--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  London is the capital city of England. </span><br><span class="line">  It is the most populous city in the United Kingdom, </span><br><span class="line">  with a metropolitan area of over 13 million inhabitants.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;place&quot;</span>&gt;</span>place<span class="tag">&lt;/<span class="name">span</span>&gt;</span>in London<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="html内联框架">HTML内联框架</span></h2><ul><li><p>iframe可以在网页内显示网页。</p></li><li><p>语法：<code>&lt;iframe src=&quot;URL&quot;&gt;&lt;iframe&gt;</code></p></li><li><p>属性</p></li></ul><p>align，可以设置值，规定如何根据周围的元素对齐此框架。不赞成使用，值包括“left”，“right”，“top”，“middle”，“bottom”。</p><p>frameborder，可以设置0或1，规定是否显示框架周围的边框。</p><p>height，可以设置百分比或像素值，规定iframe的高度。</p><p>width，可以设置百分比或像素值，规定iframe的宽度。</p><p>longdesc，可以设置URL，规定一个页面，该页面包含了有关iframe的描述。</p><p>marginheight，可以设置像素值，定义iframe的顶部和底部的边距。</p><p>marginwidth，可以设置像素值，定义iframe的左边和右边的边距。</p><p>name，可以设置文本，规定iframe的名称。</p><p>referrerpolicy，可以设置值，规定iframe的引荐信息。值包括“no-referrer”，“no-referrer-when-downgrade”，“origin”，“origin-when-cross-origin”，“same-origin”，“strict-origin-when-cross-origin”，“unsafe-url”。</p><p>sandbox，可以设置值，启用一系列对<code>&lt;iframe&gt;</code>中内容的额外限制。值包括“”，“allow-forms”，“allow-same-origin”，“allow-scripts”，“allow-top-navigation”。</p><p>scrolling，可以设置值，规定是否在iframe中显示滚动条。值包括“yes”，“no”，“auto”。</p><p>seamless，规定<code>&lt;iframe&gt;</code>看上去像是包含文档的一部分。</p><p>src，可以设置URL，规定iframe中显示的文档的URL。</p><p>srcdoc，可以设置HTML代码，规定在<code>&lt;iframe&gt;</code>中显示的页面的HTML内容。</p><h2><span id="html布局类标签">HTML布局类标签</span></h2><h3><span id="html5语义元素">HTML5语义元素</span></h3><ul><li><code>&lt;header&gt;</code></li></ul><p>定义文档或节的页眉。应该被用作介绍性内容的容器。</p><ul><li><code>&lt;main&gt;</code></li></ul><p>规定文档的主内容。</p><ul><li><code>&lt;mark&gt;</code></li></ul><p>定义重要或强调的文本。</p><ul><li><code>&lt;time&gt;</code></li></ul><p>定义日期&#x2F;时间。</p><ul><li><code>&lt;nav&gt;</code></li></ul><p>定义导航链接的容器。</p><ul><li><code>&lt;section&gt;</code></li></ul><p>定义文档中的节。</p><ul><li><code>&lt;article&gt;</code></li></ul><p>定义独立的自包含文章。应用场景：论坛、博客、新闻……</p><ul><li><code>&lt;aside&gt;</code></li></ul><p>定义内容之外的内容，如侧栏。aside内容应该与周围内容相关。</p><ul><li><code>&lt;footer&gt;</code></li></ul><p>定义文档或节的页脚。页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。</p><ul><li><code>&lt;details&gt;</code></li></ul><p>定义额外的细节。</p><ul><li><code>&lt;figure&gt;</code></li></ul><p>规定自包含内容，比如图示、图表、照片、代码清单等。通过 HTML5，图片和标题能够被组合在<code>&lt;figure&gt;</code>元素中。</p><ul><li><code>&lt;figcaption&gt;</code></li></ul><p>定义<code>&lt;figure&gt;</code>元素的标题。</p><ul><li><code>&lt;summary&gt;</code></li></ul><p>定义details元素的标题。</p><h3><span id="框架">框架</span></h3><ul><li><p>通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。</p></li><li><p>但使用框架开发人员必须同时跟踪更多的HTML文档，并且很难打印整张页面。</p></li></ul><h4><span id="标签">标签</span></h4><ul><li><code>&lt;frameset&gt;</code>，定义如何将窗口分割为框架。每个 frameset 定义了一系列行或列，rows&#x2F;columns 的值规定了每行或每列占据屏幕的面积。</li><li><code>&lt;frame&gt;</code>，定义了放置在每个框架中的 HTML 文档。</li><li>为不支持框架的浏览器添加<code>&lt;noframes&gt;</code>标签。</li><li>假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在<code>&lt;frame&gt;</code>标签中加入：noresize&#x3D;”noresize”。为不支持框架的浏览器添加<code>&lt;noframes&gt;</code>标签。不能将<code>&lt;body&gt;&lt;/body&gt;</code>标签与<code>&lt;frameset&gt;&lt;/frameset&gt;</code>标签同时使用！不过，假如你添加包含一段文本的<code>&lt;noframes&gt;</code>标签，就必须将这段文字嵌套于<code>&lt;body&gt;&lt;/body&gt;</code>标签内。如</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">&quot;25%,50%,25%&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;/xxx/frame_a.html&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;/xxx/frame_b.html&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;/xxx/frame_c.html&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">noframes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>您的浏览器无法处理框架！<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noframes</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="html表单">HTML表单</span></h2><ul><li>HTML表单用于搜集不同类型的用户输入。</li><li><code>&lt;form&gt;</code>元素定义HTML表单。</li><li>表单元素是指不同类型的input元素、复选框、单选按钮、提交按钮等等。</li></ul><h3><span id="form元素属性">form元素属性</span></h3><h4><span id="action属性">action属性</span></h4><ul><li><p>action 属性定义提交表单时要执行的操作。通常，当用户单击“提交”按钮时，表单数据将发送到服务器上的文件中。</p></li><li><p>值为URL。</p></li><li><p>如果省略 action 属性，则将 action 设置为当前页面。</p><h4><span id="target属性">target属性</span></h4></li><li><p>target 属性规定提交表单后在何处显示响应。</p></li><li><p>值包括“_blank”（新窗口），“_self”（当前窗口），“_parent”（父框架），“_top”（窗口的body中），框架名。默认为“_self”。</p><h4><span id="method属性">method属性</span></h4></li><li><p>属性规定在提交表单时所用的 HTTP 方法（GET 或 POST）。</p></li><li><p>表单数据可以作为 URL 变量（使用 method&#x3D;”get”）或作为 HTTP post 事务（使用 method&#x3D;”post”）发送。提交表单数据时，默认的 HTTP 方法是 GET。</p></li><li><p>如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息。当您使用 GET 时，表单数据在页面地址栏中是可见的。GET 最适合少量数据的提交。浏览器会设定容量限制。</p></li><li><p>如果表单正在更新数据，或者包含敏感信息（例如密码）。POST 的安全性更好，因为在页面地址栏中被提交的数据是不可见的。</p><h5><span id="注意事项">注意事项</span></h5></li><li><p>GET<br>以名称&#x2F;值对的形式将表单数据追加到 URL。<br>永远不要使用 GET 发送敏感数据！（提交的表单数据在 URL 中可见！）。<br>URL 的长度受到限制（2048 个字符）。<br>对于用户希望将结果添加为书签的表单提交很有用。<br>GET 适用于非安全数据，例如 Google 中的查询字符串。</p></li><li><p>POST<br>将表单数据附加在 HTTP 请求的正文中（不在 URL 中显示提交的表单数据）。<br>POST 没有大小限制，可用于发送大量数据。<br>带有 POST 的表单提交无法添加书签。</p></li><li><p>如果表单数据包含敏感信息或个人信息，请务必使用 POST！</p><h4><span id="autocomplete属性">autocomplete属性</span></h4></li><li><p>autocomplete 属性规定表单是否应打开自动完成功能。</p></li><li><p>启用自动完成功能后，浏览器会根据用户之前输入的值自动填写值。</p></li><li><p>值为on或off。</p><h4><span id="novalidate属性">novalidate属性</span></h4></li><li><p>novalidate 属性是一个布尔属性。它规定提交时不应验证表单数据。</p></li><li><p>值为自身。</p><h4><span id="accept-charset属性">accept-charset属性</span></h4></li><li><p>accept-charset 属性规定服务器用哪种字符集处理表单数据。</p></li><li><p>常用值有：UTF-8 - Unicode 字符编码，ISO-8859-1 - 拉丁字母表的字符编码，gb2312 - 简体中文字符集。</p><h4><span id="enctype属性">enctype属性</span></h4></li><li><p>enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。</p></li><li><p>表单数据会默认编码为 “application&#x2F;x-www-form-urlencoded”。就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为 ASCII HEX 值）。</p></li><li><p>值包括“application&#x2F;x-www-form-urlencoded”（编码所有），“multipart&#x2F;form-data”（不对字符编码），“text&#x2F;plain”（部分编码）。</p><h4><span id="name属性">name属性</span></h4></li><li><p>name属性规定表单名称，提供了一种在脚本中引用表单的方法。</p></li><li><p>如果要正确地被提交，每个输入字段必须设置一个 name 属性。</p></li><li><p>值为自定义名称。</p><h4><span id="rel属性">rel属性</span></h4></li><li><p>rel 属性规定当前文档和被链接文档之间的关系。</p></li><li><p>值包括“external”（规定引用的文档不是当前站点的一部分），“help”（链接到帮助文档），“license”（链接到文档的版权信息），“next”（集合中的下一个文档），“nofollow”    （链接到未经认可的文档，例如付费链接）（Google 使用 “nofollow” 来指定 Google 搜索蜘蛛不应跟踪该链接），“noopener”，     “noreferrer”（规定如果用户点击该超链接，则浏览器不应发送 HTTP 推荐标头），“opener”，     “prev”（集合中的上一个文档），“search”（链接到文档的搜索工具）。</p></li></ul><h3><span id="input元素输入类型">input元素输入类型</span></h3><h4><span id="文本输入">文本输入</span></h4><ul><li><p><code>&lt;input type=&quot;text&quot;&gt;</code>定义用于文本输入的单行输入字段。</p></li><li><p>表单本身并不可见。还要注意文本字段的默认宽度是 20 个字符。</p><h4><span id="密码输入">密码输入</span></h4></li><li><p><code>&lt;input type=&quot;password&quot;&gt;</code>定义密码字段。</p></li><li><p>password 字段中的字符会被做掩码处理（显示为星号或实心圆）。</p><h4><span id="单选按钮输入">单选按钮输入</span></h4></li><li><p><code>&lt;input type=&quot;radio&quot;&gt;</code>定义单选按钮。</p></li><li><p>通常单选应该有选项，如下是一个单选：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>/&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span> <span class="attr">checked</span>/&gt;</span>女</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4><span id="复选框输入">复选框输入</span></h4><ul><li><p><code>&lt;input type=&quot;checkbox&quot;&gt;</code>定义复选框。</p></li><li><p>复选框允许用户在有限数量的选项中选择零个或多个选项。</p><h4><span id="按钮输入">按钮输入</span></h4></li><li><p><code>&lt;input type=&quot;button&gt;</code>定义按钮。</p><h4><span id="提交按钮">提交按钮</span></h4></li><li><p><code>&lt;input type=&quot;submit&quot;&gt;</code>定义用于向表单处理程序提交表单的按钮。</p></li><li><p>表单处理程序通常是包含用来处理输入数据的脚本的服务器页面。有关处理表单输入的知识，参考ASP或PHP语言。</p></li><li><p>表单处理程序在表单的 action 属性中指定：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--将表单数据提交到xxx.asp页面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;../xxx/xxx.asp&quot;</span>&gt;</span></span><br><span class="line">Name:<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>提交按钮中的value属性值是显示在按钮上的内容。</p><h4><span id="html5新增输入类型">HTML5新增输入类型</span></h4></li><li><p>color<br><code>&lt;input type=&quot;color&quot;&gt;</code>用于应该包含颜色的输入字段。根据浏览器支持，颜色选择器会出现输入字段中。</p></li><li><p>date<br><code>&lt;input type=&quot;date&quot;&gt;</code>用于应该包含日期的输入字段。根据浏览器支持，日期选择器会出现输入字段中。</p></li><li><p>datetime<br><code>&lt;input type=&quot;datetime&quot;&gt;</code>允许用户选择日期和时间（有时区）。根据浏览器支持，日期选择器会出现输入字段中。</p></li><li><p>datetime-local<br><code>&lt;input type=&quot;datetime-local&quot;&gt;</code>允许用户选择日期和时间（无时区）。根据浏览器支持，日期选择器会出现输入字段中。</p></li><li><p>email<br><code>&lt;input type=&quot;email&quot;&gt;</code>用于应该包含电子邮件地址的输入字段。根据浏览器支持，能够在被提交时自动对电子邮件地址进行验证。某些智能手机会识别 email 类型，并在键盘增加 “.com” 以匹配电子邮件输入。</p></li><li><p>month<br><code>&lt;input type=&quot;month&quot;&gt;</code>允许用户选择月份和年份。根据浏览器支持，日期选择器会出现输入字段中。</p></li><li><p>number<br><code>&lt;input type=&quot;number&quot;&gt;</code>用于应该包含数字值的输入字段。能够对数字做出限制。</p></li><li><p>range<br><code>&lt;input type=&quot;range&quot;&gt;</code>用于应该包含一定范围内的值的输入字段。根据浏览器支持，输入字段能够显示为滑块控件。</p></li><li><p>search<br><code>&lt;input type=&quot;search&quot;&gt;</code>用于搜索字段（搜索字段的表现类似常规文本字段）。</p></li><li><p>tel<br><code>&lt;input type=&quot;tel&quot;&gt;</code>用于应该包含电话号码的输入字段。目前只有 Safari 8 支持 tel 类型。</p></li><li><p>time<br><code>&lt;input type=&quot;time&quot;&gt;</code>允许用户选择时间（无时区）。根据浏览器支持，时间选择器会出现输入字段中。</p></li><li><p>url<br><code>&lt;input type=&quot;url&quot;&gt;</code>用于应该包含 URL 地址的输入字段。根据浏览器支持，在提交时能够自动验证 url 字段。某些智能手机识别 url 类型，并向键盘添加 “.com” 以匹配 url 输入。</p></li><li><p>week<br><code>&lt;input type=&quot;week&quot;&gt;</code>允许用户选择周和年。根据浏览器支持，日期选择器会出现输入字段中。</p></li><li><p>image<br><code>&lt;input type=&quot;image&quot;&gt;</code>获取点击图像时的x和y坐标。</p></li></ul><h3><span id="input元素属性">input元素属性</span></h3><ul><li>value，值为自定义字段，规定输入字段的初始值。</li><li>readonly，不需要值，规定输入字段只读不可修改。</li><li>disabled，不需要值，规定输入字段禁用，不可用不可点击不会被提交。</li><li>size，值为字符数，规定输入字段框的尺寸。</li><li>maxlength，值为数字，规定输入字段允许的最大长度。<br>如设置 maxlength 属性，则输入控件不会接受超过所允许数的字符。<br>该属性不会提供任何反馈。如果需要提醒用户，则必须编写 JavaScript 代码。<br>输入限制并非万无一失。JavaScript 提供了很多方法来增加非法输入。如需安全地限制输入，则接受者（服务器）必须同时对限制进行检查。</li><li>autocomplete，值为on或off，规定表单或输入字段是否应该自动完成。当自动完成开启，浏览器会基于用户之前的输入值自动填写值。<br>可以把表单的 autocomplete 设置为 on，同时把特定的输入字段设置为 off，反之亦然。<br>autocomplete 属性适用于<code>&lt;form&gt;</code>以及如下<code>&lt;input&gt;</code>类型：text、search、url、tel、email、password、datepickers、range 以及 color。</li><li>autofocus，布尔属性，如果设置，则规定当页面加载时，<code>&lt;input&gt;</code>元素应该自动获得焦点。</li><li>form，规定<code>&lt;input&gt;</code>元素所属的一个或多个表单。如需引用一个以上的表单，请使用空格分隔的表单 id 列表。<br>即表单外使用<code>&lt;input&gt;</code>标签。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;xxx.php&quot;</span> <span class="attr">id</span>=<span class="string">&quot;form1&quot;</span>&gt;</span></span><br><span class="line">   First name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> Last name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lname&quot;</span> <span class="attr">form</span>=<span class="string">&quot;form1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>formaction，规定当提交表单时处理该输入控件文件的URL。<br>formaction 属性覆盖<code>&lt;form&gt;</code>元素的 action 属性。<br>formaction 属性适用于<code>type=&quot;submit&quot;</code>以及<code>type=&quot;image&quot;</code>。</p></li><li><p>formenctype，规定表单数据提交服务器时编码规则。<br>formenctype 属性覆盖<code>&lt;form&gt;</code>元素的 enctype 属性。<br>formenctype 属性适用于<code>type=&quot;submit&quot;</code>以及<code>type=&quot;image&quot;</code>。</p></li><li><p>formmethod，定义用以向action URL发送表单数据的HTTP方法。<br>formmethod 属性覆盖<code>&lt;form&gt;</code>元素的 method 属性。<br>formmethod 属性适用于<code>type=&quot;submit&quot;</code>以及<code>type=&quot;image&quot;</code>。</p></li><li><p>formnovalidate，布尔属性，设置时，规定提交表单时不对<code>&lt;input&gt;</code>元素进行验证。<br>formnovalidate 属性覆盖<code>&lt;form&gt;</code>元素的 novalidate 属性。<br>formnovalidate 属性可用于<code>type=&quot;submit&quot;</code>。</p></li><li><p>formtarget，规定名称或关键词指示提交表单后何处显示接收到的响应。<br>formtarget 属性会覆盖<code>&lt;form&gt;</code>元素的 target 属性。<br>formtarget 属性可与<code>type=&quot;submit&quot;</code>和<code>type=&quot;image&quot;</code>使用。</p></li><li><p>height和width，规定<code>&lt;input&gt;</code>元素的高度和宽度。<br>height 和 width 属性仅用于<code>&lt;input type=&quot;image&quot;&gt;</code>。</p></li><li><p>list，引用的<code>&lt;datalist&gt;</code>元素中包含了<code>&lt;input&gt;</code>元素的预定义选项。</p></li><li><p>min和max，规定<code>&lt;input&gt;</code>元素的最小值和最大值。<br>min 和 max 属性适用于如需输入类型：number、range、date、datetime、datetime-local、month、time 以及 week。</p></li><li><p>multiple，布尔属性，设置时，规定允许用户在<code>&lt;input&gt;</code>元素中输入一个以上的值。<br>multiple 属性适用于以下输入类型：email 和 file。</p></li><li><p>pattern，规定用于检查<code>&lt;input&gt;</code>元素值的正则表达式。<br>pattern 属性适用于以下输入类型：text、search、url、tel、email、password。</p></li><li><p>placeholder，规定用以描述输入字段预期值的提示（样本值或有关格式的简短描述）。<br>该提示会在用户输入值之前显示在输入字段中。<br>placeholder 属性适用于以下输入类型：text、search、url、tel、email 以及 password。</p></li><li><p>required，布尔属性，设置时，规定在提交表单之前必须填写输入字段。<br>required 属性适用于以下输入类型：text、search、url、tel、email、password、date pickers、number、checkbox、radio、file。</p></li><li><p>step，规定<code>&lt;input&gt;</code>元素的合法数字间隔。<br>step 属性可与 max 以及 min 属性一同使用，来创建合法值的范围。<br>step 属性适用于以下输入类型：number、range、date、datetime、datetime-local、month、time 以及 week。</p><h3><span id="ltselectgt元素"><code>&lt;select&gt;</code>元素</span></h3></li><li><p>定义下拉列表</p></li><li><p><code>&lt;option&gt;</code>元素定义待选择的选项。列表通常会把首个选项显示为被选选项。通过添加 selected 属性来定义预定义选项。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;saab&quot;</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;fiat&quot;</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;audi&quot;</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="textarea元素">textarea元素</span></h3><ul><li>定义多行输入字段（文本域）。</li></ul><h3><span id="button元素">button元素</span></h3><ul><li>定义可点击的按钮。</li></ul><h2><span id="html媒体">HTML媒体</span></h2><ul><li>Web 上的多媒体指的是音效、音乐、视频和动画。</li><li>插件（Plug-in）是扩展浏览器标准功能的计算机程序。</li></ul><h3><span id="html对象">HTML对象</span></h3><h4><span id="object元素">object元素</span></h4><ul><li><p><code>&lt;object&gt;</code>元素定义 HTML 文档中的嵌入式对象。</p></li><li><p>它旨在将插件（例如 Java applet、PDF 阅读器和 Flash 播放器）嵌入网页中，但也可以用于将 HTML 包含在 HTML 中。</p><h4><span id="embed元素">embed元素</span></h4></li><li><p><code>&lt;embed&gt;</code>元素也可定义了 HTML 文档中的嵌入式对象，也可用于在 HTML 中包含 HTML。</p></li><li><p>Web 浏览器长期以来一直支持<code>&lt;embed&gt;</code>元素。但是，它不属于 HTML5 之前的 HTML 规范的一部分。</p></li><li><p><code>&lt;embed&gt;</code>元素没有结束标记。它无法包含替代文本。</p></li></ul><h3><span id="html音频">HTML音频</span></h3><ul><li>使用<code>&lt;embed&gt;</code>元素嵌入MP3文件。<br><code>&lt;embed&gt;</code>标签在 HTML 4 中是无效的。页面无法通过 HTML 4 验证。<br>不同的浏览器对音频格式的支持也不同。<br>如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。<br>如果用户的计算机未安装插件，无法播放音频。<br>如果把该文件转换为其他格式，仍然无法在所有浏览器中播放。</li><li>使用<code>&lt;object&gt;</code>元素嵌入MP3文件。<br>不同的浏览器对音频格式的支持也不同。<br>如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。<br>如果用户的计算机未安装插件，无法播放音频。<br>如果把该文件转换为其他格式，仍然无法在所有浏览器中播放。</li><li>使用HTML5<code>&lt;audio&gt;</code>元素播放音频。<br><code>&lt;audio&gt;</code>标签在 HTML 4 中是无效的。您的页面无法通过 HTML 4 验证。<br>必须把音频文件转换为不同的格式。<br><code>&lt;audio&gt;</code>元素在老式浏览器中不起作用。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;song.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mp3&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;song.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span> /&gt;</span></span><br><span class="line">Your browser does not support this audio format.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>最好的HTML解决方法是<code>&lt;audio&gt;</code>标签与<code>&lt;embed&gt;</code>标签混用。</p></li><li><p>使用JS和播放器播放音频。</p><h5><span id="audio标签属性">audio标签属性</span></h5></li><li><p>autoplay，设置该属性时，音频就绪后马上播放。</p></li><li><p>controls，设置该属性时，显示控件。</p></li><li><p>loop，出现该属性时，音频循环播放。</p></li><li><p>muted，出现该属性时，规定音频静音。</p></li><li><p>preload，出现该属性时，在页面加载时加载音频，预备播放。</p></li><li><p>src，值为URL，播放音频的URL。</p></li></ul><h3><span id="html视频">HTML视频</span></h3><ul><li><p>使用<code>&lt;embed&gt;</code>标签。<br>HTML4 无法识别<code>&lt;embed&gt;</code>标签。您的页面无法通过验证。<br>如果浏览器不支持 Flash，那么视频将无法播放<br>iPad 和 iPhone 不能显示 Flash 视频。<br>如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</p></li><li><p>使用<code>&lt;object&gt;</code>标签。<br>如果浏览器不支持 Flash，将无法播放视频。<br>iPad 和 iPhone 不能显示 Flash 视频。<br>如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</p></li><li><p>使用<code>&lt;video&gt;</code>标签。<br><code>&lt;video&gt; </code>，是 HTML 5 中的新标签，作用是在 HTML 页面中嵌入视频元素。<br>您必须把视频转换为很多不同的格式。<br><code>&lt;video&gt;</code>元素在老式浏览器中无效。<br><code>&lt;video&gt;</code>元素无法通过 HTML 4 和 XHTML 验证</p></li><li><p>最好的HTML解决方法：HTML5+<code>&lt;object&gt;</code>+<code>&lt;embed&gt;</code>。</p><h4><span id="video标签属性">video标签属性</span></h4></li><li><p>autoplay，设置该属性时，视频就绪后马上播放。</p></li><li><p>controls，设置该属性时，显示控件。</p></li><li><p>height，值为像素值，设置播放器高度。</p></li><li><p>width，值为像素值，设置播放器宽度。</p></li><li><p>loop，出现该属性时，视频循环播放。</p></li><li><p>muted，出现该属性时，规定视频静音。</p></li><li><p>poster，值为URL，规定视频下载时现实的图像，或播放按钮前显示的图像。</p></li><li><p>preload，出现该属性时，在页面加载时加载视频，预备播放。</p></li><li><p>src，值为URL，播放音频的URL。</p></li></ul><h2><span id="html5新增元素">HTML5新增元素</span></h2><ul><li><p><code>&lt;datalist&gt;</code><br><code>&lt;datalist&gt;</code>元素为<code>&lt;input&gt;</code>元素规定预定义选项列表。用户会在他们输入数据时看到预定义选项的下拉列表。<code>&lt;input&gt;</code>元素的 list 属性必须引用<code>&lt;datalist&gt;</code>元素的 id 属性</p></li><li><p><code>&lt;keygen&gt;</code></p></li><li><p><code>&lt;output&gt;</code></p><h3><span id="fieldset元素">fieldset元素</span></h3></li><li><p><code>&lt;fieldset&gt;</code>元素组合表单中的相关数据。</p></li><li><p><code>&lt;legend&gt;</code>元素为<code>&lt;fieldset&gt;</code>元素定义标题。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Personal information:<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h1><span id="html-id属性">HTML id属性</span></h1><ul><li><p>HTML id 属性用于HTML 元素指定唯一的id。一个 HTML文档中不能存在多个有相同 id 的元素。</p></li><li><p>id 的语法是：写一个井号 (#)，后跟一个 id 名称。然后，在花括号 {} 中定义 CSS 属性。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#London</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: black;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;London&quot;</span>&gt;</span>My City<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>id对大小写敏感，且至少包含一个字符，不能为空白字符（空格、制表符等）。</p></li><li><p>id还可以用于实现书签。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--先用id创建书签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;C4&quot;</span>&gt;</span>第四章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--接着使用链接元素跳转--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#C4&quot;</span>&gt;</span>跳转到第四章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者跳转到另一页的书签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;test.html#C4&quot;</span>&gt;</span>跳转到第四章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>CSS和JS可以使用id属性选取元素或设置样式。 </li><li>Class 与 ID 的差异<br>同一个类名可以由多个 HTML 元素使用，而一个 id 名称只能由页面中的一个 HTML 元素使用。</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个小巧的Markdown编辑工具</title>
      <link href="/%E8%BD%AF%E4%BB%B6/tools1/"/>
      <url>/%E8%BD%AF%E4%BB%B6/tools1/</url>
      
        <content type="html"><![CDATA[<p>介绍一个小巧方便的编写Markdown语言工具。</p><ol><li><p>什么是Markdown</p></li><li><p>MarkText</p></li><li><p>进阶使用</p></li></ol><p>关键词：Markdown工具</p><span id="more"></span><hr><h1><span id="什么是markdown">什么是Markdown</span></h1><ul><li><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p></li><li><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p></li><li><p>Markdown可用于编写记录笔记、博客、电子书等电子文档。</p></li></ul><h1><span id="marktext">MarkText</span></h1><ul><li>MarkText是一款开源的Markdown工具，可用于编辑输出Markdown文件。本人推荐的是英文语言软件，如何汉化自行研究。</li></ul><p>软件地址：建议安装到非系统盘（非C盘）</p><p><a href="https://github.com/marktext/marktext/releases">MarkText下载 - 官网</a></p><p><a href="https://www.aliyundrive.com/s/CoADkVDj1Sq">MarkText下载 - 个人网盘（Windows64位）</a></p><ul><li>MarkText具有多个明暗主题选择，软件菜单内容明确，主打轻便，是一款很不错的小工具。</li></ul><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%B8%BB%E7%95%8C%E9%9D%A2.jpg" alt="软件界面（明亮主题）"></p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%B8%BB%E7%95%8C%E9%9D%A22.jpg" alt="软件界面（灰暗主题）"></p><ul><li>使用方法</li></ul><p>输入<code>@</code>选择插入的模块，包括段落、分割线、标题、表格、数学公式、引用块、列表等。如果本身对于Markdown语言有一定基础的话，也可直接建立该模块。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%BD%BF%E7%94%A81.jpg" alt="使用过程"></p><p>在编写完内容后，可以直接保存为Markdown文件（<code>.md</code>后缀），也可以导出为PDF文件和HTML文件。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%BF%9D%E5%AD%98.jpg" alt="选择保存"></p><h1><span id="进阶使用">进阶使用</span></h1><ul><li>有时候对于PDF文件，会有显示目录大纲的需求，但是该软件直接导出并不能设置，此时需要借助另一个工具：wkhtmltopdf。</li></ul><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.jpg" alt="带目录的PDF文件"></p><ul><li><strong>wkhtmltopdf</strong></li></ul><p>一款<strong>将HTML文件转化为PDF文件</strong>的小工具，但是其并没有软件UI界面，对小白不友好，但是万能的网络能搜到使用方法，此处针对如何导出带目录的PDF进行介绍。</p><ol><li>下载软件</li></ol><p>下载地址：可能提示有风险，建议安装到非系统盘（非C盘）</p><p><a href="https://wkhtmltopdf.org/downloads.html">wkhtmltopdf下载 - 官网</a></p><p><a href="https://www.aliyundrive.com/s/V4SBUcntBAv">wkhtmltopdf下载 - 个人网盘（Windows64位）</a></p><ol start="2"><li>安装并配置</li></ol><p>安装后，需要记住安装的具体位置，比如我是安装在D盘，位置就是<code>D:\wkhtmltopdf</code>，接着进行系统环境变量的配置。在电脑设置中搜索环境变量，打开编辑页面。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.jpg" alt="配置环境变量"></p><p>具体步骤：编辑→新建→输入安装的位置里面的bin文件夹即<code>D:\wkhtmltopdf\bin</code>→确定所有系统设置窗口。</p><p>（添加错误的环境变量并不会对电脑造成严重伤害，但不要胡乱删除环境变量）</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%90%8E.jpg" alt="配置环境变量后"></p><p>再接着确认环境变量是否配置成功：按快捷键<code>win+r</code>，输入cmd，打开黑窗口，在窗口内输入<code>wkhtmltopdf -V</code>（查询wkhtmltopdf的版本），如果出现类似于版本号的数字，则说明添加环境变量成功。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_cmd.jpg" alt="配置成功"></p><ol start="3"><li>软件使用</li></ol><p>在cmd黑窗口切换到想要HTML文件转换为PDF文件的位置，直接输入<code>F:</code>切换到不同的盘，输入<code>cd xx</code>可以进入不同文件夹。如果不知道自己是什么路径，可以先进入所在盘，再打开文件所在文件夹，在地址栏点击获得路径，然后复制粘贴到黑窗口进入。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E8%BF%9B%E5%85%A5%E6%96%87%E4%BB%B6%E5%A4%B9.jpg" alt="进入工作文件夹"></p><p>接着回到MarkText软件，将文件导出为HTML文件，保存在特定文件夹，该文件夹应该跟cmd黑窗口进入的文件夹一样。举例时，我将该文件保存为<code>test.html</code>文件在<code>F:\14.Books</code>文件夹。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E5%AF%BC%E5%87%BAHTML.jpg" alt="导出HTML"></p><p>再回到黑窗口，使用命令<code>wkhtmltopdf 目的文件名字 新文件名字</code>转换，我这里应该是<code>wkhtmltopdf test.html test.pdf</code>。等待转换成功。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8A%9F.jpg" alt="转换成功"></p><p>此时回到文件夹，就可以看到转换完成的带目录的PDF文件。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_test.jpg" alt="转换成功的PDF文件"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个用过的导航页</title>
      <link href="/%E7%BD%91%E9%A1%B5/%E5%AF%BC%E8%88%AA%E9%A1%B5/"/>
      <url>/%E7%BD%91%E9%A1%B5/%E5%AF%BC%E8%88%AA%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>介绍两个我常用的导航页。导航页就是一个网站的目录，其包含了很多常用其他网站的快捷方式。</p><ol><li><p>果汁导航页</p></li><li><p>青柠起始页</p></li></ol><ul><li>附设置浏览器起始页</li></ul><p>关键词：导航页</p><span id="more"></span><hr><ol><li>果汁导航</li></ol><p>果汁导航页包括互联网搜索功能，还有各种生活学习用到的网页快捷方式。每层目录下还收纳了很多相关网站，包括影视、知识、新闻、等网站，丰富度很高，也很容易因为内容太多眼花缭乱忘记了有这么样的功能。更多功能可以自己探索发现收藏。可登录使用也可不登录使用。</p><p>地址：<a href="http://guozhivip.com/">果汁导航 - guozhivip.com</a></p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E6%9E%9C%E6%B1%81%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA.png" alt="果汁导航"></p><ol start="2"><li>青柠起始页</li></ol><p>一个简约的起始页，具有搜索功能，当搜索框聚焦时，背景具有毛玻璃效果。点击时钟可以到达另一页，此页可以添加一些常用的网站快捷方式（需登录），自定义程度高。丰富度不高，简约型网站。</p><p>地址：<a href="https://limestart.cn/">青柠起始页 - limestart.cn</a></p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E9%9D%92%E6%9F%A0%E8%B5%B7%E5%A7%8B%E9%A1%B5.jpg" alt="青柠起始页主页"></p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E9%9D%92%E6%9F%A0%E8%B5%B7%E5%A7%8B%E9%A1%B51.jpg" alt="青柠起始页附页"></p><ul><li>附：设置为浏览器起始页</li></ul><p>以Edge浏览器为例，打开设置页面，选择<code>开始、主页和新建标签页</code>，将启动时页面改为想要的导航页，更方便自己浏览器使用。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E8%AE%BE%E7%BD%AE.jpg" alt="设置"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 网页 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 导航页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记1</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cnetwork1/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cnetwork1/</url>
      
        <content type="html"><![CDATA[<p>计算机网络：引言+物理层+数据链路层</p><p>关键词：物理层、数据链路层</p><span id="more"></span><hr><!-- toc --><ul><li><a href="#%E5%BC%95%E8%A8%80">引言</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9C%A8%E4%BF%A1%E6%81%AF%E6%97%B6%E4%BB%A3%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">计算机网络在信息时代中的作用</a></li><li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0">互联网概述</a><ul><li><a href="#%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BD%91%E7%BB%9C">网络的网络</a></li><li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%8F%91%E5%B1%95%E7%9A%84%E4%B8%89%E9%98%B6%E6%AE%B5">互联网基础结构发展的三阶段</a></li><li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%A5%E4%BD%9C">互联网的标准化工作</a></li></ul></li><li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%90">互联网的组成</a><ul><li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86">互联网的边缘部分</a><ul><li><a href="#%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F">客户-服务器方式</a></li><li><a href="#%E5%AF%B9%E7%AD%89%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">对等连接方式</a></li></ul></li><li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86">互联网的核心部分</a><ul><li><a href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">电路交换</a></li><li><a href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">分组交换</a></li></ul></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%B1%BB%E5%88%AB">计算机网络的类别</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89">计算机网络的定义</a></li><li><a href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%88%AB%E7%9A%84%E7%BD%91%E7%BB%9C">不同类别的网络</a></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD">计算机网络的性能</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">计算机网络的性能指标</a><ul><li><a href="#%E9%80%9F%E7%8E%87">速率</a></li><li><a href="#%E5%B8%A6%E5%AE%BD">带宽</a></li><li><a href="#%E5%90%9E%E5%90%90%E9%87%8F">吞吐量</a></li><li><a href="#%E6%97%B6%E5%BB%B6">时延</a><ul><li><a href="#%E5%8F%91%E9%80%81%E6%97%B6%E5%BB%B6">发送时延</a></li><li><a href="#%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6">传播时延</a></li><li><a href="#%E5%A4%84%E7%90%86%E6%97%B6%E5%BB%B6">处理时延</a></li><li><a href="#%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6">排队时延</a></li></ul></li><li><a href="#%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF">时延带宽积</a></li><li><a href="#%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4rtt">往返时间RTT</a></li><li><a href="#%E5%88%A9%E7%94%A8%E7%8E%87">利用率</a></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9D%9E%E6%80%A7%E8%83%BD%E7%89%B9%E5%BE%81">计算机网络的非性能特征</a></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机网络的体系结构</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%A2%E6%88%90">计算机网络体系结构的形成</a></li><li><a href="#%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%92%E5%88%86%E5%B1%82%E6%AC%A1">协议与划分层次</a></li><li><a href="#%E5%85%B7%E6%9C%89%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">具有五层协议的体系结构</a></li><li><a href="#%E5%AE%9E%E4%BD%93-%E5%8D%8F%E8%AE%AE-%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%82%B9">实体、协议、服务和服务访问点</a></li><li><a href="#tcpip-%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">TCP&#x2F;IP 的体系结构</a></li></ul></li></ul></li><li><a href="#%E7%89%A9%E7%90%86%E5%B1%82">物理层</a><ul><li><a href="#%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">物理层的基本概念</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">数据通信的基础知识</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A8%A1%E5%9E%8B">数据通信系统的模型</a><ul><li><a href="#%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD">常用术语</a></li></ul></li><li><a href="#%E6%9C%89%E5%85%B3%E4%BF%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">有关信道的几个基本概念</a></li><li><a href="#%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F">信道的极限容量</a></li></ul></li><li><a href="#%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">物理层下面的传输媒体</a><ul><li><a href="#%E5%AF%BC%E5%BC%95%E5%9E%8B%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">导引型传输媒体</a><ul><li><a href="#%E5%8F%8C%E7%BB%9E%E7%BA%BF">双绞线</a></li><li><a href="#%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86">同轴电缆</a></li><li><a href="#%E5%85%89%E7%BC%86">光缆</a></li></ul></li><li><a href="#%E9%9D%9E%E5%AF%BC%E5%BC%95%E5%9E%8B%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">非导引型传输媒体</a></li></ul></li><li><a href="#%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">信道复用技术</a><ul><li><a href="#%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8-%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8%E5%92%8C%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8">频分复用、时分复用和统计时分复用</a><ul><li><a href="#%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8fdmfrequency-division-multiplexing">频分复用FDM（Frequency Division Multiplexing）</a></li><li><a href="#%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8tdmtime-division-multiplexing">时分复用TDM（Time Division Multiplexing）</a></li><li><a href="#%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8statistic-tdm">统计时分复用（Statistic TDM）</a></li></ul></li><li><a href="#%E6%B3%A2%E5%88%86%E5%A4%8D%E7%94%A8wavelength-division-multiplexing">波分复用（Wavelength Division Multiplexing）</a></li><li><a href="#%E7%A0%81%E5%88%86%E5%A4%8D%E7%94%A8code-division-multiplexing">码分复用（Code Division Multiplexing）</a><ul><li><a href="#%E7%A0%81%E5%88%86%E5%A4%8D%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E8%AE%A1%E7%AE%97">码分复用的应用计算</a></li></ul></li></ul></li><li><a href="#%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F">数字传输系统</a></li><li><a href="#%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF">宽带接入技术</a><ul><li><a href="#adsl%E6%8A%80%E6%9C%AF">ADSL技术</a></li><li><a href="#%E5%85%89%E7%BA%A4%E5%90%8C%E8%BD%B4%E6%B7%B7%E5%90%88%E7%BD%91hfchybrid-fiber-coax%E7%BD%91">光纤同轴混合网（HFC（Hybrid Fiber Coax）网）</a></li><li><a href="#fttxfiber-to-the-%E6%8A%80%E6%9C%AF">FTTx（Fiber To The ……）技术</a></li></ul></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">使用点对点信道的数据链路层</a><ul><li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%92%8C%E5%B8%A7">数据链路和帧</a></li><li><a href="#%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">三个基本问题</a><ul><li><a href="#%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">封装成帧</a></li><li><a href="#%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">透明传输</a></li><li><a href="#%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6">差错控制</a><ul><li><a href="#crc%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8Ccyclic-redundancy-check">CRC循环冗余校验（Cyclic Redundancy Check）</a><ul><li><a href="#crc%E7%A0%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">CRC码的基本思想</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0">如何构造</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%A3%80%E9%94%99%E7%BA%A0%E9%94%99">如何检错纠错</a></li></ul></li></ul></li></ul></li></ul></li><li><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEppppoint-to-point-protocol">点对点协议PPP（Point-to-Point Protocol）</a><ul><li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9">PPP协议的特点</a></li><li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F">PPP协议的帧格式</a><ul><li><a href="#%E5%B8%A7%E5%90%84%E5%AD%97%E6%AE%B5%E7%9A%84%E6%84%8F%E4%B9%89">帧各字段的意义</a></li><li><a href="#%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85">字节填充</a></li><li><a href="#%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85">零比特填充</a></li></ul></li><li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81">PPP协议的工作状态</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E9%80%9A%E4%BF%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">使用广播通信的数据链路层</a><ul><li><a href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">局域网的数据链路层</a><ul><li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%87%E5%87%86">以太网的两个标准</a></li><li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8">适配器的作用</a></li></ul></li><li><a href="#csmacd%E5%8D%8F%E8%AE%AE">CSMA&#x2F;CD协议</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BA%BF%E5%99%A8%E7%9A%84%E6%98%9F%E5%BD%A2%E6%8B%93%E6%89%91">使用集线器的星形拓扑</a></li><li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87">以太网的信道利用率</a><ul><li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8F%82%E6%95%B0%CE%B1">以太网参数α</a></li><li><a href="#%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BCs_max">信道利用率的最大值$S_{max}$</a></li></ul></li><li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84mac%E5%B1%82">以太网的MAC层</a><ul><li><a href="#mac%E5%B1%82%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80">MAC层的硬件地址</a><ul><li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A3%80%E6%9F%A5mac%E5%9C%B0%E5%9D%80">适配器检查MAC地址</a></li></ul></li><li><a href="#mac%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F">MAC帧的格式</a><ul><li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91v2%E6%A0%87%E5%87%86%E7%9A%84mac%E5%B8%A7%E6%A0%BC%E5%BC%8F">以太网V2标准的MAC帧格式</a></li><li><a href="#ieee8023mac-%E5%B8%A7%E6%A0%BC%E5%BC%8F">IEEE802.3MAC 帧格式</a></li><li><a href="#%E6%97%A0%E6%95%88mac%E5%B8%A7">无效MAC帧</a></li><li><a href="#%E5%B8%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E9%97%B4%E9%9A%94">帧的最小间隔</a></li></ul></li></ul></li></ul></li><li><a href="#%E6%89%A9%E5%B1%95%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91">扩展的以太网</a><ul><li><a href="#%E5%9C%A8%E7%89%A9%E7%90%86%E5%B1%82%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91">在物理层扩展以太网</a></li><li><a href="#%E5%9C%A8%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%9B%B4%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95">在数据链路层扩展以太网(更常用的方法)</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E7%BD%91%E6%A1%A5">使用网桥</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA">使用以太网交换机</a><ul><li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%8A%9F%E8%83%BD">以太网交换机的自学习功能</a></li><li><a href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE">交换机使用生成树协议</a></li><li><a href="#%E4%BB%8E%E6%80%BB%E7%BA%BF%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%88%B0%E6%98%9F%E5%BD%A2%E4%BB%A5%E5%A4%AA%E7%BD%91">从总线以太网到星形以太网</a></li></ul></li></ul></li><li><a href="#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91">虚拟局域网</a><ul><li><a href="#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F">虚拟局域网使用的以太网帧格式</a></li></ul></li></ul></li><li><a href="#%E9%AB%98%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91">高速以太网</a><ul><li><a href="#100base-t%E4%BB%A5%E5%A4%AA%E7%BD%91">100BASE-T以太网</a></li><li><a href="#%E5%90%89%E6%AF%94%E7%89%B9%E4%BB%A5%E5%A4%AA%E7%BD%91">吉比特以太网</a></li><li><a href="#10%E5%90%89%E6%AF%94%E7%89%B9%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%92%8C%E6%9B%B4%E5%BF%AB%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91">10吉比特以太网和更快的以太网</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%A4%AA%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5">使用以太网进行宽带接入</a></li></ul></li></ul></li></ul><!-- tocstop --><h1><span id="引言">引言</span></h1><h2><span id="计算机网络在信息时代中的作用">计算机网络在信息时代中的作用</span></h2><ul><li>数字化、网络化、信息化</li><li>三大类网络：电信网络、有线电视网络、计算机网络<br>“三网融合”概念</li><li>网络是信息社会的命脉和发展知识经济的重要基础</li><li>互联网具有两个重要基本特点：连通性（Connectivity）、共享（Sharing）</li></ul><h2><span id="互联网概述">互联网概述</span></h2><h3><span id="网络的网络">网络的网络</span></h3><ul><li>互联网Internet</li><li>计算机网络，由若干结点（node）和连接这些结点的链路（link）组成</li><li>互连网，通过路由器把网络互连起来，构成覆盖范围更大的计算机网络</li><li>网络的网络，network of networks</li><li>与网络相连的计算机常称为主机。</li><li>Internet指互联网或因特网，internet泛指多个计算机网络互连而成的网络。</li></ul><h3><span id="互联网基础结构发展的三阶段">互联网基础结构发展的三阶段</span></h3><ul><li>一、从单个网络ARPANET向互联网发展的过程</li><li>二、建成了三级结构的互联网<br>主干网、地区网、校园网（企业网）</li><li>三、逐渐形成了多层次ISP结构的互联网<br>ISP，Internet Service Provider。<br>ISP也分成不同层次的ISP：主干ISP、地区ISP和本地ISP</li></ul><h3><span id="互联网的标准化工作">互联网的标准化工作</span></h3><ul><li>制定互联网的正式标准要经过三阶段：互联网草案、建议标准、互联网标准</li></ul><h2><span id="互联网的组成">互联网的组成</span></h2><ul><li>边缘部分：由所欲连接在互联网上的主机组成。</li><li>核心部分：由大量网络和连接这些网络的路由器组成。</li></ul><h3><span id="互联网的边缘部分">互联网的边缘部分</span></h3><ul><li>处在互联网边缘的部分就是连接在互联网上的所有的主机，这些主机又称为端系统（end system）。<br>端系统在功能上可能有很大的差别。<br>主机A的某个进程和主机B上的另一个进程进行通信，简称计算机之间的通信。</li><li>端系统之间的通信方式分为两类：<br>客户-服务器方式（C&#x2F;S方式）<br>对等方式（P2P方式）</li></ul><h4><span id="客户-服务器方式">客户-服务器方式</span></h4><ul><li>客户（client）和服务器（server）都是通信中所涉及的两个应用进程。</li><li>客户是服务请求方，服务器是服务提供方。</li><li>客户程序必须知道服务器程序的地址。</li><li>服务器程序不需要直到客户程序的地址。</li><li>客户与服务器通信关系建立后，通信是双向的。</li></ul><h4><span id="对等连接方式">对等连接方式</span></h4><ul><li>peer-to-peer，P2P</li><li>通信时不区分服务请求方还是服务提供方。</li><li>需要运行P2P程序。</li></ul><h3><span id="互联网的核心部分">互联网的核心部分</span></h3><ul><li>互联网的核心部分是由许多网络和把他们互连起来的路由器组成。</li><li>在网络核心部分起特殊作用的是路由器（router）。<br>路由器实现分组交换（packet switching）的关键构件。</li><li>互联网核心部分中的路由器之间一般用高速链路相连接。</li><li>路由器的用途是用来转发分组的，即进行分组交换的。</li></ul><h4><span id="电路交换">电路交换</span></h4><ul><li>N部电话机只需要N(N-1)&#x2F;2对电线直接连接就能够互相通话。</li><li>每一部电话直接连接到交换机上，而交换机使用交换的方法，让用户彼此间方便通信，这种方式就是电路交换。<br>此处交换的含义是转接。</li><li>特点：<font color="red">面向连接</font>的。</li><li>电路交换三阶段：建立连接、通信、释放连接。</li><li>缺点：计算机数据具有突发性，传送计算机数据时，通信线路的利用率很低。</li></ul><h4><span id="分组交换">分组交换</span></h4><ul><li>采用<font color="red">存储转发</font>技术。<br>在发送端，先把较长的报文划分成较短的、固定长度的数据段。<br>每一个数据段前面添加上首部构成分组（packet）。<br>在接收端，收到分组后剥去首部还原成报文。</li><li>每一个分组的首部都含有地址等控制信息。</li><li>分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一结点交换机。</li><li>每个分组在互联网中独立地选择传输路径。</li><li><font color="blue">优点</font><br>高效：在分组传输过程中动态分配传输带宽，对通信链路是逐段占用。<br>灵活：为每一个分组独立地选择最适合的转发路由。<br>迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组。<br>可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。</li><li>问题<br>分组在各结点存储转发时需要排队，造成一定时延。<br>分组必须携带的首部也造成一定的开销。</li></ul><h2><span id="计算机网络的类别">计算机网络的类别</span></h2><h3><span id="计算机网络的定义">计算机网络的定义</span></h3><ul><li>计算机网络主要是由一些通用的、可编程的硬件（包含CPU）互连而成的，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</li></ul><h3><span id="不同类别的网络">不同类别的网络</span></h3><ol><li>按照网络的作用分为进行分类：<br>广域网WAN（Wide Area Network）、城域网MAN（Metropolitan Area Network）、局域网LAN（Local Area Network）、个人局域网PAN（Personal Area Network）</li><li>按照网络的使用者进行分类：<br>公用网（public network）、专用网（private network）</li><li>用来把用户接入到互联网的网络：接入网（Access Network），又称为本地接入网或居民接入网。</li></ol><h2><span id="计算机网络的性能">计算机网络的性能</span></h2><h3><span id="计算机网络的性能指标">计算机网络的性能指标</span></h3><h4><span id="速率">速率</span></h4><ul><li>比特是计算机中的数量的单位。比特是一个二进制数字。</li><li>速率指的是数据的传送速率，也称数据率或比特率。</li><li>速率的单位是bit&#x2F;s、kbit&#x2F;s、Mbit&#x2F;s等。</li><li>速率往往是额定速率，非实际速率。</li></ul><h4><span id="带宽">带宽</span></h4><ul><li>带宽表示网络中某通道传送数据的能力，在单位时间内网络中某信道所能通过的最高数据率。</li><li>带宽的单位就是数据率的单位。</li></ul><h4><span id="吞吐量">吞吐量</span></h4><ul><li>吞吐量表示单位时间内通过某个网络（信道、接口）的数据量。</li><li>用于对现实世界中网络的一种测量。</li></ul><h4><span id="时延">时延</span></h4><ul><li>时延是指数据从网络的一端传送到另一端的时间。<br>有时也称为延迟或迟延。</li><li>时延由发送时延、传播时延、处理时延、排队时延组成。</li></ul><h5><span id="发送时延">发送时延</span></h5><ul><li>发送时延是发送数据时数据帧从结点进入到传输媒体所需要的时间。<br>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送给完毕所需的时间。<br>$$<br>发送时延&#x3D;\frac {数据帧长度(bit)}{发送频率(bit&#x2F;s)}<br>$$</li></ul><h5><span id="传播时延">传播时延</span></h5><ul><li>传播时延是电磁波在信道中传播一定距离所需要的时间。<br>$$<br>传播时延&#x3D;\frac {信道长度(m)}{电磁波在信道上的传播速率(m&#x2F;s)}<br>$$</li></ul><h5><span id="处理时延">处理时延</span></h5><ul><li>主机或路由器在收到分组时，需要花费时间进行处理的时间。</li></ul><h5><span id="排队时延">排队时延</span></h5><ul><li>分组在经过网络传输时，要经过许多的路由器。但分组在进入路由器后要先输入队列中排队等待处理。在路由器确定了转发接口后，还要输出队列中排队等候转发。</li></ul><h4><span id="时延带宽积">时延带宽积</span></h4><ul><li>时延带宽积是传播时延和带宽相乘。</li></ul><h4><span id="往返时间rtt">往返时间RTT</span></h4><ul><li>往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。<br>$$<br>发送时间&#x3D;\frac {数据长度}{发送速率}<br>$$</li></ul><h4><span id="利用率">利用率</span></h4><ul><li>分为信道利用率和网络利用率</li><li>信道利用率指某通道有百分之几的时间是被利用的。</li><li>网络利用率是全网络的信道利用率的加权平均值。</li><li>信道利用率增大时，该信道引起的时延也迅速增加。</li><li>令$D_0$表示网络空闲时的时延，$D$表示网络当前的时延，$U$为利用率。<br>$$<br>D&#x3D;\frac {D_0}{1-U}<br>$$</li></ul><h3><span id="计算机网络的非性能特征">计算机网络的非性能特征</span></h3><ul><li>费用、质量、标准化、可靠性、可拓展性和升级性、易于管理和维护。</li></ul><h2><span id="计算机网络的体系结构">计算机网络的体系结构</span></h2><h3><span id="计算机网络体系结构的形成">计算机网络体系结构的形成</span></h3><ul><li>计算机网络是个非常复杂的系统。</li><li>相互通信的两个计算机系统必须高度协调工作。</li><li>“分层”可将庞大而复杂的问题，转化为若干较小的局部问题。</li><li>1974年，IBM公司宣布了系统网络体系结构SNA。<br>按照分层方法制定。</li><li>由于网络体系结构不同，不同公司的设备很难互相连通。</li><li>开放系统互连基本参考模型（OSI&#x2F;RM）</li></ul><h3><span id="协议与划分层次">协议与划分层次</span></h3><ul><li>为网络中的数据交换而建立的规则，标准或约定称为网络协议。</li><li>网络协议三个组成要素：语法、语义、同步。<br>语法：数据与控制信息的结构或格式。<br>语义：需要发出何种控制信息，完成何种动作或做出何种相应。<br>同步：时间实现顺序的详细说明。</li><li>协议的两种形式：一种是使用便于人来阅读和理解的文字描述；另一种是使用让计算机能够理解的程序代码。<br>必须能够对网络上的信息交换过程做出精确的解释。</li><li>协议结构应该是层次性的。</li><li>分层的好处：各层之间是独立的；灵活性好；结构上可分割开；易于实现和维护；能促进标准化工作。</li><li>分层各层完成的主要功能：<br>差错控制：使相应层次对等方的通信更加可靠。<br>流量控制：发送端发送速率必须使接收端来得及接收。<br>分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。<br>复用和分用：发送端几个高层会话复用一条底层的连接，在接收端在进行分用。<br>连接建立和释放：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li></ul><h3><span id="具有五层协议的体系结构">具有五层协议的体系结构</span></h3><ul><li>计算机的网络体系结构是计算机网络的各层及其协议的集合。</li><li>OSI的七层协议：7应用层、6表示层、5会话层、4运输层、3网络层、2数据链路层、1物理层。</li><li>TCP&#x2F;IP是四层体系结构：应用层、运输层、网际层、网络接口层。</li><li>五层协议：5应用层（Application layer）、4运输层（Transport layer）、3网络层（Network layer）、2数据链路层（Data link layer）、1物理层（Physical layer）。<br>运输层最重要的协议是TCP和UDP协议。<br>网络层最重要的协议是IP协议。</li><li>假定主机1的应用进程$AP_1$向主机2的应用进程$AP_2$传送数据。$AP_1$先将数据交给本主机的应用层。应用层加上必要控制信息$H_5$就变成了下一层的数据单元。运输层收到数据单元，加上本层的控制信息$H_4$，再交给网络层，称为网络层的数据单元。以此类推。在数据链路层后，控制信息被分成两部分，分别加到数据链路层数据单元的首部$H_2$和尾部$T_2$；而物理层是比特流的传送，不需加上控制信息。传送比特流时应从首部开始传送。当比特流离开主机1经网络的物理媒体传送到路由器时，经过每一层去除控制信息，最后交到$AP_2$。</li></ul><h3><span id="实体-协议-服务和服务访问点">实体、协议、服务和服务访问点</span></h3><ul><li>实体表示任何可发送或接收信息的硬件或软件进程。</li><li>协议时控制两个对等实体进行通信的规则的集合。<br>协议的实现保证了能够向上一层提供服务。<br>下面协议对上面的服务用户是透明不可见的。本层用户只能看见服务而看不见下层的协议。</li><li>协议是“水平的”，控制对等实体之间通信的规则。</li><li>服务是“垂直的”，由下层向上层通过层间接口提供的。</li><li>同一系统相邻两层的实体进行交互的地方，称为服务访问点SAP。</li></ul><h3><span id="tcpx2fip-的体系结构">TCP&#x2F;IP 的体系结构</span></h3><ul><li>TCP&#x2F;IP协议族的特点是上下两头大而中间小：应用层和网络接口层都有很多种协议，而中间的IP层很小。</li><li>这种很像沙漏计时器形状的TCP&#x2F;IP协议族表明：TCP&#x2F;IP协议可以为各式各样的应用提供服务。</li><li>TCP&#x2F;IP协议允许IP协议在各式各样的网络构成的互联网上运行。</li></ul><h1><span id="物理层">物理层</span></h1><h2><span id="物理层的基本概念">物理层的基本概念</span></h2><ul><li><p>物理层考虑传输数据比特流。</p></li><li><p>物理层的作用要尽可能屏蔽掉不同传输媒体和通信手段的差异。</p></li><li><p>用于物理层的协议被称为物理层规程。</p></li><li><p>物理层的主要任务：确定与传输媒体的接口的一些特性。</p></li></ul><p>机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。</p><p>电气特性：指明在接口电缆的各条线上出现的电压范围。</p><p>功能特性：指明某条线上出现的某一电平的电压表示何种意义。</p><p>过程特性：指明对于不同功能的各种可能事件的出现顺序。</p><h2><span id="数据通信的基础知识">数据通信的基础知识</span></h2><h3><span id="数据通信系统的模型">数据通信系统的模型</span></h3><ul><li>一个数据通信系统分为三部分：源系统（发送端、发送方）、传输系统（传输网络）和目的系统（接收端、接收方）。</li></ul><h4><span id="常用术语">常用术语</span></h4><ul><li><p>数据data——运送消息的实体。</p></li><li><p>信号signal——数据的电气的或电磁的表现。</p></li><li><p>模拟数据analogous data——表示时间上和幅度取值上是连续的。</p></li><li><p>数字数据digital data——表示在时间上离散的，在幅值上是经过量化的数据。</p></li><li><p>模拟信号analogous signal——代表消息的参数的取值是连续的。</p></li><li><p>数字信号digital signal——代表消息的参数的取值是离散的。</p></li><li><p>码元code——在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p></li><li><p>信道——一般用来表示向某一方向传送信息的媒体。</p></li><li><p>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。</p></li><li><p>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送或接收。</p></li><li><p>双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。</p></li><li><p>串行传输：数据的二进制代码在一条物理信道上将数据一位位地依次传输。</p></li><li><p>并行传输：数据以成组的方式在多条并行信道上同时传输。</p></li><li><p>基带信号（基本频带信号）——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p></li></ul><p>基带信号往往包含低频成分，甚至直流成分，而许多信道并不能传输这种低频分量或直流分量，所以对基带信号进行调制。</p><ul><li>调制分为两大类：</li></ul><ol><li>基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍为基带信号。这种过程称为编码（coding）。<br>常用编码方式：</li></ol><p>不归零制：正电平代表1，负电平代表0。</p><p>归零制：正脉冲代表1，负脉冲代表0。</p><p>曼彻斯特编码：位周期中心的向上跳变代表0，位周期中心向下跳变代表1.可反过来定义。</p><p>差分曼彻斯特编码：每一位的中心处始终都有跳变。位开始边界有跳变代表0，而位开始边界没有跳变代表1。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/cnetwork_%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.jpg" alt="编码方式"></p><ol start="2"><li>带通调制：使用载波（carrier）进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道）。</li></ol><p>带通信号：经过载波调制后的信号。</p><p>最基本的二元制调制方法：</p><p>调幅（AM）：载波的振幅随基带数字信号而变化。</p><p>调频（FM）：载波的频率随基带数字信号而变化。</p><p>调相（PM）：载波的初始相位随基带数字信号而变化。</p><h3><span id="有关信道的几个基本概念">有关信道的几个基本概念</span></h3><h3><span id="信道的极限容量">信道的极限容量</span></h3><ul><li><p>码元传输速率越高或信号传输距离越远或传输媒体质量越差，在信道的输出端波形的失真就越严重。</p></li><li><p>限制码元在信道上的传输速率：信道能够通过的频率范围、信噪比。</p></li></ul><ol><li>信道能够通过的频率范围</li></ol><p>码元的传输速率有上限，否则出现码间串扰的问题。如果信道的频带越宽，也就是能够通过的信号高频分量越多，可以用更高速率传送码元而不出现码间串扰。</p><ol start="2"><li>信噪比</li></ol><p>噪声存在于所有电子设备和通信信道中。噪声随机产生，会使接收端对码元的判决产生错误。</p><p>信噪比就是信号的平均功率和噪声的平均功率之比，记作$S&#x2F;N$，度量单位为分贝（dB）。</p><p>$$<br>信噪比（dB）&#x3D;10log_{10}(\frac SN)（dB）<br>$$</p><p>香农公式：极限、无差错的信息传输速率</p><p>$$<br>信道极限信息传输速率C&#x3D;Wlog_2(1+\frac SN)（bit&#x2F;s）<br>$$<br>W为信道带宽，Hz为单位；S为信道内所传信号的平均功率；N为信道内部的高斯噪声功率。</p><p>香农公式表明：</p><p>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法实现无差错传输。若W和S&#x2F;N没有上限，则C也没有上限。实际信道传输速率远比香农公式算出来的低。</p><h2><span id="物理层下面的传输媒体">物理层下面的传输媒体</span></h2><ul><li>传输媒体也称为传输介质或传输媒介。</li></ul><h3><span id="导引型传输媒体">导引型传输媒体</span></h3><ul><li>电磁波被导引沿着固体媒体传播。</li></ul><h4><span id="双绞线">双绞线</span></h4><ul><li><p>最常用</p></li><li><p>模拟传输和数字传输皆可，通信距离为几到十几公里。</p></li><li><p>分为屏蔽双绞线STP和无屏蔽双绞线UTP。</p></li><li><p>根据绞合分为3类线和5类线。</p></li><li><p>对于传送数据，最常用的UTP是5类线。</p></li></ul><h4><span id="同轴电缆">同轴电缆</span></h4><ul><li><p>很好的抗干扰特性，广泛用于传输较高速率的数据。</p></li><li><p>同轴电缆的带宽取决于电缆质量。</p></li><li><p>50Ω同轴电缆——LAN&#x2F;数字传输常用</p></li><li><p>75Ω同轴电缆——有线电视&#x2F;模拟传输常用</p></li></ul><h4><span id="光缆">光缆</span></h4><ul><li><p>光纤是光纤通信的传输媒体。</p></li><li><p>光纤通信系统的传输带宽远远大于目前其他传输媒体的带宽。</p></li><li><p>多模光纤：存在多条不同角度入社的光线在一条光纤中传输。</p></li><li><p>单模光纤：光纤直径减少到只有一个光的波长，光线可以一直向前传播而不会产生多次反射。</p></li><li><p>光波优点：通信容量非常大；传输损耗小，中继距离长；抗雷电和电磁干扰好；无串音干扰，保密性好；体积小，重量轻。</p></li></ul><h3><span id="非导引型传输媒体">非导引型传输媒体</span></h3><ul><li><p>就是指自由空间，这样的电磁波传输也被称为无线传输。</p></li><li><p>短波通信（高频通信）通信质量差、传输速率低。</p></li><li><p>微波主要以直线传播。</p></li><li><p>传统微波：地面微波接力通信和卫星通信。</p></li></ul><h2><span id="信道复用技术">信道复用技术</span></h2><ul><li>复用（multiplexing）是通信技术中的基本概念。它允许用户使用一个共享的信道进行通信，降低成本，提高利用率。</li></ul><h3><span id="频分复用-时分复用和统计时分复用">频分复用、时分复用和统计时分复用</span></h3><h4><span id="频分复用fdmfrequency-division-multiplexing">频分复用FDM（Frequency Division Multiplexing）</span></h4><ul><li><p>将整个带宽分为多份，用户在分配到一定频带后，通信过程自始至终都占用这个频带。</p></li><li><p>频分复用的所有用户在同样时间占用不同的带宽资源。（“带宽”指的是频率带宽而不是数据的发送频率）</p></li></ul><h4><span id="时分复用tdmtime-division-multiplexing">时分复用TDM（Time Division Multiplexing）</span></h4><ul><li><p>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用的份额相等。</p></li><li><p>时分复用可能会造成线路资源的浪费。由于计算机数据的突发性，用户对分配到的子信道的利用率不高。</p></li></ul><h4><span id="统计时分复用statistic-tdm">统计时分复用（Statistic TDM）</span></h4><ul><li>STDM帧按需动态分配时隙。</li></ul><h3><span id="波分复用wavelength-division-multiplexing">波分复用（Wavelength Division Multiplexing）</span></h3><ul><li>光的频分复用，使用一根光纤传播。</li></ul><h3><span id="码分复用code-division-multiplexing">码分复用（Code Division Multiplexing）</span></h3><ul><li><p>在发送端将不同的用户信息采用相互正交的扩频码序列进行调制后再发送，在接收端采用相关解调来恢复原始数据。它是一种共享信道的方法，每个用户可在同一时间使用同样的频带进行通信，但使用基于码型的分割信道的方法。每个用户分配一个地址码，各个码型互不重叠，通信各方之间不会相互干扰，且抗干拢能力强。</p></li><li><p>常用名词码分多址CDMA（Code Division Multiple Access）</p></li><li><p>码片序列（chip sequence），在实用的系统中使用的是伪随机码序列。</p></li></ul><p>一个简单的码分复用的例子是在CDMA中，每个比特时间再划分为m个短的间隔，称为码片。通常m值为64或128。每个站被指派一个唯一的mbit码片序列。码片序列实现了扩频。</p><ul><li>CMDA的重要特点：每个站分配的码片序列不仅必须各不相同，并且还必须互相正交。</li></ul><h4><span id="码分复用的应用计算">码分复用的应用计算</span></h4><ul><li><p>一个站如果要发送比特1，则发送它自己的m bit码片序列，如果要发送0，则发送该码片序列的二进制反码。按照惯例将码片中的0写成<code>-1</code>，将1写成<code>+1</code>。</p></li><li><p>例如，假设有两个用户A和B，他们分别被分配了不同的码片序列：A的码片序列为<code>+1+1+1-1-1+1-1-1</code>，B的码片序列为<code>+1-1-1+1-1+1+1-1</code>。当A要发送比特0时，它会发送<code>-1-1-1+1+1-1+1+1</code>；当B要发送比特0时，它会发送<code>-1+1+1-1+1-1-1+1</code>。这样，在接收端就可以根据接收到的信号和已知的各用户的码片序列来解调并恢复原始数据。</p></li><li><p>当收到的码片序列存在大于1的值，说明该码片序列是混合叠加得到的，接收端收到的混合信号是各个站发送的码片序列之和。接收端用相同的码片序列进行<strong>规格化内积</strong>，就可以将不属于本码片序列的其他信号全部去除，只接受本码片序列所携带的信息。（即使多用户同时通信时，其信号电压会相互叠加或抵消。）</p></li></ul><p>通过<br>$$<br>S·T&#x3D;\frac 1m\sum^m_{i&#x3D;1}S_iT_i<br>$$</p><p>计算规格化内积，其中结果为+1，说明这个站发送比特1；结果为-1，说明这个站发送比特0；结果为0，说明这个站没有发送信息。</p><ul><li>例：共有4个站进行码分多址CDMA通信，4个站的码片序列为：<code>A：(-1 -1 -1 +1 +1 -1 +1 +1) 、B：(-1 -1 +1 -1 +1 +1 +1 -1)、C：(-1 +1 -1 +1 +1 +1 -1 -1) 、D：(-1 +1 -1 -1 -1 -1 +1 -1)</code>。现收到这样的码片序列：<code>( +1 -3 +3 -1 +1 +1 +1 +1)</code>，求发送站及发送的数据。</li></ul><p>由$S·T&#x3D;\frac 1m\sum^m_{i&#x3D;1}S_iT_i$计算$S·T_1&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{1i}&#x3D;1$，所以A站发送的是<code>1</code>；$S·T_2&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{2i}&#x3D;-1$，所以B站发送的是<code>0</code>；$S·T_3&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{3i}&#x3D;1$，所以C站没有发送数据；$S·T_4&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{4i}&#x3D;1$，所以D站发送的是<code>1</code>。</p><h2><span id="数字传输系统">数字传输系统</span></h2><ul><li><p>长途干线大都采用时分复用PCM的数字传输方式。</p></li><li><p>脉码调制PCM体制最初是为了在电话局之间的中继线上传送多路电话。</p></li><li><p>PCM有两个标准，北美的24路PCM（T1）和欧洲的30路PCM（E1）。我国采用E1标准。</p></li><li><p>旧的数字传输系统存在缺点：导致速率标准不统一，不是同步传输。</p></li><li><p>同步光纤网SONET（Synchronous Optical Network）</p></li></ul><p>SONET为光纤传输系统定义了同步传输的线路速率等级结构。</p><ul><li>同步数字系列SDH（Synchronous Digital Hierarchy）</li></ul><p>SDH一般可以跟SONET称为同义词，不同的点是SDH速率更快。</p><h2><span id="宽带接入技术">宽带接入技术</span></h2><h3><span id="adsl技术">ADSL技术</span></h3><ul><li>非对称数字用户线（Asymmetric Digital Subscriber Line）技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。</li></ul><p>把0~4kHz低端频谱留给传统电话，而把原来没有利用的高端频谱留给用户上网使用。</p><ul><li>ADSL的传输距离取决于数量和用户线的线径。</li></ul><p>用户线越细，信号传输时的衰减就越大。</p><ul><li><p>ADSL所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。</p></li><li><p>ADSL的特点</p></li></ul><ol><li><p>上行和下行带宽做成不对称的。上行指从用户到ISP，下行指从ISP到用户。</p></li><li><p>ADSL在用户线（铜线）的两端各安装一个ADSL调制解调器。</p></li><li><p>我国目前采用离散多音调DMT（Discrete Multi-Tone）调制技术。“多音调”就是“多载波”或“多子信道”。</p></li></ol><ul><li>ADSL的数据率</li></ul><p>ADSL采用自适应调制技术使用户线能够传送尽可能高的数据率。</p><p>ADSL不能保证固定的数据率。</p><ul><li><p>DSL：数字用户线。</p></li><li><p>HDSL：高速数字用户线。</p></li><li><p>SDSL：1对线的数字用户线。</p></li><li><p>VDSL：甚高速数字用户线。</p></li><li><p>RADSL：速率自适应DSL。</p></li></ul><h3><span id="光纤同轴混合网hfchybrid-fiber-coax网">光纤同轴混合网（HFC（Hybrid Fiber Coax）网）</span></h3><ul><li><p>HFC是目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网。</p></li><li><p>HFC网对CATV网进行了改造。</p></li></ul><p>HFC网将原CATV网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。</p><ul><li><p>用户接口盒UIB（User Interface Box），连接在同轴电缆和用户的电视机之间。</p></li><li><p>电缆调制解调器（Cable Modem），电缆调制解调器是为HFC网而使用的调制解调器。</p></li></ul><h3><span id="fttxfiber-to-the-技术">FTTx（Fiber To The ……）技术</span></h3><ul><li>FTTx是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。</li></ul><p>如：Fiber To The Home，FTTH，光纤到户；Fiber To The Building，FTTB，光纤到楼……</p><h1><span id="数据链路层">数据链路层</span></h1><ul><li><p>数据链路层使用的信道：点对点信道；广播信道。</p></li><li><p>点对点信道：使用一对一的点对点通信方式。</p></li><li><p>广播信道：使用一对多的广播通信方式。</p></li></ul><h2><span id="使用点对点信道的数据链路层">使用点对点信道的数据链路层</span></h2><h3><span id="数据链路和帧">数据链路和帧</span></h3><ul><li>链路（link）是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</li></ul><p>一条链路只是一条通路的一个组成部分。</p><ul><li>数据链路（data link）除了物理线路外，还必须有通信协议来控制这些数据的传输。</li></ul><p>若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p><ul><li><p>另外的术语：物理链路和逻辑链路，逻辑链路&#x3D;物理链路+协议。</p></li><li><p>点对点信道的数据链路层的协议数据单元是帧，数据链路层传送的是帧。</p></li></ul><p>数据链路层像个数字管道，在这条管道上传输的数据单位是帧。</p><ul><li>点对点信道的数据链路层在进行通信时的主要步骤如下：</li></ul><ol><li><p>结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。</p></li><li><p>结点A把封装好的帧发送给结点B的数据链路层。</p></li><li><p>若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报交给上面的网络层；否则丢弃这个帧。</p></li></ol><h3><span id="三个基本问题">三个基本问题</span></h3><h4><span id="封装成帧">封装成帧</span></h4><ul><li><p>封装成帧就是在一段数据的前后分别添加首部和尾部，这样构成一个帧。</p></li><li><p>首部和尾部具有许多控制信息，一个重要作用就是进行帧定界。</p></li><li><p>每一种数据链路层协议都规定了所能传送的帧的数据部分长度上限——最大传送单元MTU。</p></li></ul><table><thead><tr><th>帧开始</th><th>IP数据报</th><th>帧结束</th></tr></thead><tbody><tr><td>帧首部</td><td>帧的数据部分$\leq MTU$</td><td>帧尾部</td></tr></tbody></table><ul><li>用控制字符进行帧定界。</li></ul><p>控制字符<code>SOH</code>（Start Of Header），表示帧的首部开始。控制字符<code>EOT</code>（End of Transmission），表示帧的结束。</p><p>具有明确的帧定界符才是完整的帧。</p><h4><span id="透明传输">透明传输</span></h4><ul><li>透明传输：不管所传数据是什么样的比特组合，都能在链路上传输。</li></ul><p><strong>“透明”表示：某一个实际存在的事物看起来却好像不存在一样。</strong></p><p>由于帧的开始和结束的标记使用专门指明的控制字符，因此，所传输的数据中任何8比特的组合一定不允许和用作帧定界的控制字符的比特编码一样。否则会出现帧定界的错误。当遇到数据中碰巧出现字符“EOT”时就传不过去。数据中的“EOT”被接收端错误地解释为“传输结束”的控制字符，而在其后面的数据因找不到“SOH”被接收端当作无效帧而丢弃。</p><ul><li>解决透明传输：字节填充或字符填充。<br>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。如果转义字符也出现在数据中，那么仍在转义字符的前面插入一个转义字符。</li></ul><h4><span id="差错控制">差错控制</span></h4><ul><li><p>产生比特差错：1和0的变换。</p></li><li><p>误码率：传输错误的比特占所传输比特总数的比率。</p></li></ul><p>误码率与信噪比关系很大。</p><ul><li>循环冗余检验CRC，能够实现无比特差错传输。</li></ul><h5><span id="crc循环冗余校验cyclic-redundancy-check">CRC循环冗余校验（Cyclic Redundancy Check）</span></h5><h6><span id="crc码的基本思想">CRC码的基本思想</span></h6><ul><li><p>数据发送接受方约定一个“除数”（二进制）。</p></li><li><p>K个信息位和R个校验位作为“被除数”，添加校验位后需保证除法的余数为0。</p></li></ul><table><thead><tr><th align="center">信息位</th><th align="center">校验位</th></tr></thead><tbody><tr><td align="center">K位</td><td align="center">R位</td></tr></tbody></table><ul><li>收到数据后，进行除法检查余数是否为0。</li></ul><h6><span id="如何构造">如何构造</span></h6><ul><li>假设生成多项式为$G(x)&#x3D;x^3+x^2+1$，信息码为101001，求对应CRC码。</li></ul><table><thead><tr><th align="center">信息位</th><th align="center">校验位</th></tr></thead><tbody><tr><td align="center">K位</td><td align="center">R位</td></tr></tbody></table><ol><li>确定K、R以及生成多项式对应的二进制编码。</li></ol><p>由生成多项式$G(x)&#x3D;1·x^3+1·x^2+0·x+1·x^0$，得对应的二进制编码为1101。</p><p>$K&#x3D;信息码长度&#x3D;6$，$R&#x3D;生成多项式最高次幂&#x3D;3$，CRC位数<code>N=K+R=9</code>。</p><ol start="2"><li>移位</li></ol><p>信息码左移<code>R</code>位，低位补0。</p><ol start="3"><li>相除</li></ol><p>对移位后的信息码，用生成多项式进行模2除法，产生余数。</p><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/cnetwork_1.jpg" alt="CRC过程"></p><p>得到对应CRC码：<code>101001001</code></p><h6><span id="如何检错纠错">如何检错纠错</span></h6><ul><li><p>如发送：<code>101001001</code>记为$C_9C_8C_7C_6C_5C_4C_3C_2C_1$。</p></li><li><p>接收方：<code>101001001</code>用<code>1101</code>进行模2除，余数为<code>000</code>代表没有出错。</p></li><li><p>接收方：<code>101001011</code>用<code>1101</code>进行模2除，余数为<code>010</code>代表出错。</p></li></ul><table><thead><tr><th align="center">接受</th><th align="center">余数</th><th align="center">出错位</th></tr></thead><tbody><tr><td align="center">10100100<font color="red">0</font></td><td align="center">001</td><td align="center">1</td></tr><tr><td align="center">1010010<font color="red">1</font>1</td><td align="center">010</td><td align="center">2</td></tr><tr><td align="center">101001<font color="red">1</font>01</td><td align="center">100</td><td align="center">3</td></tr><tr><td align="center">10100<font color="red">0</font>001</td><td align="center">101</td><td align="center">4</td></tr><tr><td align="center">1010<font color="red">1</font>1001</td><td align="center">111</td><td align="center">5</td></tr><tr><td align="center">101<font color="red">1</font>01001</td><td align="center">011</td><td align="center">6</td></tr><tr><td align="center">10<font color="red">0</font>001001</td><td align="center">110</td><td align="center">7</td></tr><tr><td align="center">1<font color="red">1</font>1001001</td><td align="center">001</td><td align="center">8</td></tr><tr><td align="center"><font color="red">0</font>01001001</td><td align="center">010</td><td align="center">9</td></tr></tbody></table><ul><li>K个信息位，R个校验位，若生成多项式选择得当，且$2^R\geq K+R+1$，则CRC码可纠正1位错。</li></ul><p>上述例子中，总位数有9位，而校验位只有3位，$2^3&#x3D;8$，则不能表示所有的错误位置。</p><ul><li>理论上可以得出CRC校验码的特点：</li></ul><ol><li><p>可检测出所有奇数个错误；</p></li><li><p>可检测出所有双比特的错误；</p></li><li><p>可检测出所有小于等于校验位长度的连续错误。</p></li></ol><ul><li><p>在数据后面添加上冗余码称为帧检验序列FCS。</p></li><li><p>CRC是一种常用的检错方法，而FCS是添加在数据后面的冗余码。</p></li><li><p>仅用循环冗余检验CRC差错检测技术只能做到无差错接受。</p></li></ul><p>凡是接收端数据链路层接受的帧，都能以非常接近1的概率认为这些帧在传输过程中没有产生差错。</p><p>无比特差错和无传输差错是不同的概念。</p><h2><span id="点对点协议ppppoint-to-point-protocol">点对点协议PPP（Point-to-Point Protocol）</span></h2><h3><span id="ppp协议的特点">PPP协议的特点</span></h3><ul><li><p>用户计算机和ISP进行通信时所使用的数据链路层协议就是PPP协议。</p></li><li><p>PPP协议应该满足的需求</p></li></ul><ol><li><p>简单——首要要求。</p></li><li><p>封装成帧——必须规定特殊的字符作为帧定界符。</p></li><li><p>透明性——必须保证数据传输的透明性。</p></li><li><p>多种网络协议——能够在同一条物理链路上同时支持多种网络层协议。</p></li><li><p>多种类型网络——能够在多种类型网络上使用。</p></li><li><p>差错检测——必须能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p></li><li><p>检测连接状态——能够即使自动检测出链路是否处于正常工作状态。</p></li><li><p>最大传送单元——必须对每一种类型的点对点链路设置最大传送单元MTU的标准默认值，促进各种实现之间的互操作性。</p></li><li><p>网络层地址协商——必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。</p></li><li><p>数据压缩协商——必须提供一种方法来协商使用数据压缩算法。</p></li></ol><ul><li>PPP协议不需要的功能</li></ul><ol><li><p>纠错</p></li><li><p>流量控制</p></li><li><p>序号</p></li><li><p>多点线路</p></li><li><p>半双工或单工线路</p></li></ol><ul><li>PPP协议组成部分：</li></ul><ol><li><p>一个将IP数据报封装到串行链路的方法。</p></li><li><p>链路控制协议LCP（Link Control Protocol）。</p></li><li><p>网络控制协议NCP（Network Control Protocol）。</p></li></ol><h3><span id="ppp协议的帧格式">PPP协议的帧格式</span></h3><h4><span id="帧各字段的意义">帧各字段的意义</span></h4><ul><li><p>PPP帧首部和尾部分别为4个字段和2个字段。</p></li><li><p>首部</p></li></ul><p>标志字段F（Flag），规定为<code>0x7E</code>，是PPP帧的定界符，占用1个字节；</p><p>地址字段A，规定为<code>0xFF</code>，占用1个字节；</p><p>控制字段C，规定为<code>0x03</code>，占用1个字节；</p><p>协议占用2个字节。当协议字段为<code>0x0021</code>时，PPP帧的信息字段就是IP数据报。当协议字段为<code>0xC021</code>时，则信息字段是PPP链路控制协议LCP的数据。当协议字段为<code>0x8021</code>时，表示这是网络层的控制数据。</p><ul><li><p>信息字段的长度是可变的，不超过1500字节。</p></li><li><p>尾部第一个字段是使用CRC的帧检验序列FCS，第二个字段是标志字段F。</p></li></ul><h4><span id="字节填充">字节填充</span></h4><ul><li>当信息字段中出现和标志字段一样的比特<code>0x7E</code>组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。当</li></ul><p>PPP使用异步传输时，它把转义字符定义为<code>0x7D</code>即<code>01111101</code>，并使用字节填充。</p><ul><li>RFC1662规定了填充方法：</li></ul><ol><li><p>把信息字段中出现的每一个<code>0x7E</code>字节转变成为2字节序列<code>0x7D,0x5E</code>。</p></li><li><p>若信息字段中出现了一个<code>0x7D</code>的字节（即出现了和转义字符一样的比特组合），则把<code>0x7D</code>转变为2字节序列<code>0x7D,0x5D</code>。</p></li><li><p>若信息字段中出现了ASCII码的控制字符（数值小于<code>0x20</code>的字符），则在该字符前加入一个<code>0x7D</code>字节，同时将该字符的编码加以改变。如出现了<code>0x03</code>（在控制字符中是“传输结束”ETX）就要把它转变为2字节序列<code>0x7D,0x23</code>。<br>发送端进行了修改，但接收端在收到数据在进行于发送端字节填充相反的变换。</p></li></ol><h4><span id="零比特填充">零比特填充</span></h4><ul><li><p>零比特填充的具体做法：在发送端，先扫描整个信息字段，只要发现有5个连续1，则立即填入一个0（防止被认为是标志字段F）。接收端在收到一个帧时，先找到标志字段F以确认一个帧的边界，接着再用硬件对其中的比特流进行扫描，当发现5个连续的1时，就把这5个连续1后的一个0删除，还原成原来的信息比特流。</p></li><li><p>上述方法保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。</p></li></ul><h3><span id="ppp协议的工作状态">PPP协议的工作状态</span></h3><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/cnetwork1_2.jpg" alt="PPP工作状态"></p><ul><li>PPP协议有5个工作状态：</li></ul><ol><li><p>链路静止（Link Dead）：PPP链路的起始和终止状态永远是链路静止，这个阶段发生在链接失败，或一方被告知断开连接（例如，用户已经完成了他或她的拨号连接）。</p></li><li><p>链路建立（LCP 连接建立）（Link Establishment Phase）：发送者与接收者之间建立连接。</p></li><li><p>鉴别用户身份（身份验证）（Authentication Phase）：使用用户名和口令对建立的链接进行身份验证，确定对方的身份是否合法。</p></li><li><p>网络层协议（NCP 建立）（Network-Layer Protocol Phase）：在建立的PPP链路上，根据具体需要选择所要使用的网络层协议，并为该协议建立NCP（网络控制协议）。</p></li><li><p>链路终止（LCP连接终止）（Link Termination Phase）：链路连接的关闭及资源的释放。</p></li></ol><ul><li><p>当用户拨号接入ISP时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。PC 机向路由器发送一系列的链路控制协议 LCP 分组（封装成多个 PPP 帧)这些分组及其响应选择一些PPP参数，并进行网络层配置，网络控制程序NCP 给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</p></li><li><p>PPP协议不是纯粹的数据链路层的协议，还包括物理层和网络层的内容。</p></li><li><p>当用户个人电脑通过调制解调器呼叫路由器时，路由器就能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP就进入“链路建立”（Link Establish）状态，其目的是建立链路层的LCP连接。这时LCP开始协商一些配置选项，即发送LCP的配置请求帧（Configure-Request）。这是个 PPP帧，其协议字段置为 LCP 对应的代码，而信息字段包含特定的配置请求。</p></li><li><p>链路的另一端可以发送以下几种响应中的一种：</p></li></ul><ol><li><p>配置确认帧（Configure-Ack）所有选项都接受。</p></li><li><p>配置否认帧（Configure-Nak）所有选项都理解但不能接受。</p></li><li><p>配置拒绝帧（Configure-Reject）选项有的无法识别或不能接受，需要协商。</p></li></ol><ul><li><p>LCP配置选项包括链路上的最大帧长、所使用的<strong>鉴别协议</strong>（authentication protocol）的规约（如果有的话），以及不使用PPP帧中的地址和控制字段（因为这两个字段的值是固定的，没有任何信息量，可以在PPP帧的首部中省略这两个字节）。协商结束后双方就建立了 LCP链路，接着就进入“<strong>鉴别</strong>”（Authenticate）状态。在这一状态，只允许传送LCP协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用口令鉴别协议PAP（Password Authentication Protocol），则需要发起通信的一方发送身份标识符和口令。系统可允许用户重试若干次。如果需要有更好的安全性，则可使用更加复杂的口令握手鉴别协议 CHAP <strong>（Challenge-Handshake Authentication Protocol）。若鉴别身份失败，则转到“</strong>链路终止<strong>”（Link Terminate）状态。若鉴别成功，则进入“</strong>网络层协议**”（Network-Layer Protocol）状态。</p></li><li><p>在“<strong>网络层协议</strong>”状态，PPP链路的两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个PPP协议进行通信。</p></li><li><p>如果在PPP链路上运行的是IP协议，则对PPP链路的每一端配置IP协议模块（如分配 IP 地址）时就要使用 NCP 中支持 IP的协议——<strong>IP 控制协议 IPCP</strong> （IP Control Protocol）。IPCP 分组也封装成PPP帧（其中的协议字段为<code>0x8021</code>）在PPP链路上传送。在低速链路上运行时，双方还可以协商使用压缩的TCP和IP首部，以减少在链路上发送的比特数。</p></li><li><p>当网络层配置完毕后，链路就进入可进行数据通信的“<strong>链路打开</strong>”（Link Open）状态。链路的两个 PPP端点可以彼此向对方发送分组。两个 PPP端点还可发送<strong>回送请求</strong>LCP分组（Echo-Request）和<strong>回送回答</strong>LCP分组（Echo-Reply），以检查链路的状态。</p></li><li><p>数据传输结束后，可以由链路的一端发出终止请求LCP分组（Terminate-Request）请求终止链路连接，在收到对方发来的终止确认 LCP 分组（Terminate-Ack）后，转到“<strong>链路终止</strong>”状态。如果链路出现故障，也会从“<strong>链路打开</strong>”状态转到“<strong>链路终止</strong>”状态。当调制解调器的载波停止后，则回到“<strong>链路静止</strong>”的状态。</p></li></ul><h2><span id="使用广播通信的数据链路层">使用广播通信的数据链路层</span></h2><h3><span id="局域网的数据链路层">局域网的数据链路层</span></h3><ul><li><p>特点：网络为一个单位所拥有；地理范围和站点数目有限。</p></li><li><p>局域网具有如下主要优点：</p></li></ul><ol><li><p>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</p></li><li><p>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</p></li><li><p>提高了系统的可靠性、可用性和残存性。</p></li></ol><ul><li>共享信道：静态划分信道和动态媒体接入控制。</li></ul><p>静态划分信道包括频分复用、时分复用、波分复用和码分复用灯，但代价较高不适合局域网使用。动态媒体接入控制又称多点接入，特点是信道并非在用户通信时固定分配给用户。</p><ul><li>动态媒体接入又分为随机接入和受控接入。</li></ul><p>随机接入的特点是所有用户可随机地发送信息，但如果恰巧多用户同时发送信息时，出现信息碰撞冲突，所以要有解决碰撞的网络协议。受控接入的特点是用户不能随机地发送信息而必须服从一定的控制，这类典型代表有分散控制的令牌环局域网和集中控制的多点线路探询（又称轮询）。</p><h4><span id="以太网的两个标准">以太网的两个标准</span></h4><ul><li><p>以太网的两个标准：DIX Ethernet V2和IEEE 802.3。</p></li><li><p>IEEE802委员会把局域网的数据链路层拆成两个子层：逻辑链路控制LLC（Logical Link Control）和媒体接入控制MAC（Medium Access Control）。与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种传输媒体和MAC子层的局域网对LLC子层来说都是透明的。</p></li></ul><h4><span id="适配器的作用">适配器的作用</span></h4><ul><li><p>计算机与外界局域网的连接时通过通信适配器（adapter）进行的。</p></li><li><p>适配器本来是一块网络接口板，又称为通信适配器或网络接口卡NIC，或“网卡”。</p></li><li><p>重要功能：串行&#x2F;并行转换；数据缓存；安装设备驱动程序；实现以太网协议。</p></li></ul><h3><span id="csmax2fcd协议">CSMA&#x2F;CD协议</span></h3><ul><li>以太网采用广播方式发送。</li></ul><p>总线上的每一个工作的计算机都能检测到发送的数据信号。但由于数据帧首部写入地址匹配问题，只有某个计算机才能接收。</p><ul><li>以太网采用两种重要措施</li></ul><ol><li>采用较为灵活的无连接的工作方式。</li></ol><p>不必先建立连接就可以直接发送数据。对发送的数据帧不进行编号，也不要求对方发回确认。</p><p>以太网提供的服务时不可靠的交付，即尽最大努力的交互。</p><p>当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。</p><p>如果发现了数据帧丢失了一些数据，于是把这些数据重新传递给以太网进行重传，但以太网并不知道这是重传帧，而是当作新的数据帧来发送。</p><ol start="2"><li>以太网发送的数据都是用曼彻斯特编码。</li></ol><p>曼彻斯特编码的缺点是：它所占的频带宽度比原始的基带信号增加了一倍。</p><ul><li><p>CSMA&#x2F;CD含义： 载波监听多点接入&#x2F;碰撞检测（Carrier Sense Multiple Access with Collision Detection）。</p></li><li><p>“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。</p></li><li><p>“载波监听”是指每一个站在发送数据之前先要检测总线上是否有其他计算机在发送数据，如果有，则暂时不发送数据，以免发生碰撞。</p></li></ul><p>总线上并没有什么“载波”。因此，“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</p><ul><li>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。“碰撞检测”也成为“冲突检测”。</li></ul><p>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将增大。当适配器检测到的信号电压变化幅度超过一定的门限值，就认为总线上至少有两个站同时在发送数据。</p><ul><li><p>为什么要进行碰撞检测？<br>由于电磁波在总线上的传播速率是有限的。 碰撞的结果是两个帧都变得无用。</p></li><li><p>使用CSMA&#x2F;CD协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</p></li><li><p>争用期</p></li></ul><p>最先发送数据帧的站，在发送数据帧后至多经过时间$2τ$就可知道发送的数据帧是否遭受了碰撞。以太网的端到端往返时延$2τ$称为争用期或碰撞窗口。经过争用期后还没有检测到碰撞，才能肯定此次发送不会发生碰撞。</p><p>10Mbit&#x2F;s以太网取51.2μs为争用期长度。对于10Mbit&#x2F;s以太网，在争用期可发送512bit，即64字节。这意味着以太网在发送数据时，若前64字节没有发送冲突，则后续的数据就不会发送冲突。</p><p>如果发生冲突，一定在发送前64字节之内。由于冲突而终止发送，此时发送出去的数据一定小于64字节。<strong>以太网规定了最短有效帧长为64字节</strong>，凡长度小于64字节的帧都是由于冲突而异常终止的无效帧。</p><ul><li>最短帧长计算</li></ul><p>$$<br>最短帧长 &#x3D; 争用期长度 × 数据传输速率<br>$$</p><p>$$<br>争用期长度是指端到端传输时延 τ 的两倍。<br>$$</p><p>$$<br>最短帧长 &#x3D; 2τ × 数据传输速率<br>$$</p><ul><li>二进制指数类型退避算法</li></ul><p>发送碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能在发送数据。基本退避时间取为争用期$2τ$。从整数集合$[0,1,…,(2^k-1)]$中随机取出一个数，记为$r$。重传所需时延就是$r$倍的基本退避时间。</p><p>参数$k$计算：$k&#x3D;Min[重传次数,10]$，当$k\leq 10$时，参数$k$等于重传次数。</p><p>当重传达16次仍不能成功时丢弃此帧，并向高层报告。</p><ul><li>强化碰撞</li></ul><p>一旦发生了碰撞：立即停止发送数据；再继续发送32比特或48比特的人为干扰信号。</p><ul><li>CSMA&#x2F;CD协议的要点</li></ul><ol><li><p>准备发送。在发送之前，必须先检测信道。</p></li><li><p>检测信道。若检测到信道忙，应不停检测，一直等待信道转为空闲。若检测到信道空闲，并在96比特时间内保持空闲（保证了帧间最小间隔），就发送这个帧。</p></li><li><p>检查碰撞。在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里有两种可能性。</p></li></ol><p>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做，回到步骤1。</p><p>发送失败：在争用期内检测到碰撞。这是立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法。等待r倍512比特时间后，返回到步骤2，继续检测信道。但若重传达16次仍不成功，则停止重传而向上报错。</p><h3><span id="使用集线器的星形拓扑">使用集线器的星形拓扑</span></h3><ul><li>物理上是星型，逻辑上是总线型。</li></ul><p>为了降低成本，最初由粗的同轴电缆变成细的同轴电缆最后变成无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收；</p><ul><li><p>采用双绞线的以太网采用星形拓扑，在星形中心则增加了一种可靠性非常高的设备，叫作集线器（hub）。</p></li><li><p>1990年，IEEE制定星形以太网10BASE-T的标准802.3i。10表示速度10Mbit&#x2F;s，BASE指的是连接线上的信号是基带信号，T代表双绞线。</p></li></ul><p>使用无屏蔽双绞线，采用星形拓扑。每个站需要两队双绞线用于发送和接收。双绞线两端使用RJ-45插头。</p><ul><li>集线器的一些特点</li></ul><p>逻辑上仍是一个总线网，各工作站使用的还是CSMA&#x2F;CD协议，并共享逻辑上的总线，在同一时刻至多只允许一个站发送数据。</p><ol><li><p>能够扩展网络：集线器可以将多个网络设备连接在一起，扩展网络的范围和接入设备的数量。</p></li><li><p>传输速率较慢：集线器的传输速率较慢，一般为10Mbps或100Mbps，无法满足高速数据传输的需求。</p></li><li><p>无法分割网络：集线器不具备分割网络的能力，所有连接的设备共享同一个网络地址。</p></li><li><p>无法过滤数据：集线器无法过滤数据包，所有的数据包都会被广播到所有连接的设备上。</p></li><li><p>便宜易用：集线器的价格较为低廉，且使用简单，适合小型网络的搭建。</p></li><li><p>可靠性较低：由于集线器无法检测网络中的故障点，不进行碰撞检测，一旦出现故障，整个网络将会受到影响。</p></li></ol><h3><span id="以太网的信道利用率">以太网的信道利用率</span></h3><ul><li>以太网的信道利用率是指在一定时间内，实际传输数据的时间与总时间的比值。</li></ul><p>由于在以太网中，传输数据需要占用一定的时间，而且在传输数据时可能会出现冲突、重传等情况，因此实际传输数据的时间会比总时间要短，信道利用率也就相应地降低。</p><ul><li><p>以太网总的信道利用率并不能达到100%。</p></li><li><p>假设发送帧需要的时间是$T_0$，则成功发送一个帧需要占用信道的时间是$T_0+τ$，多一个单程端到端时延$τ$。因此必须经过时间$T_0+τ$后以太网的媒体才完全进入空闲状态，才能允许其他站发送数据。</p></li></ul><table><thead><tr><th align="center">争用期</th><th align="center">争用期</th><th align="center">……</th><th align="center">争用期</th><th align="center">发送成功</th><th align="center"></th></tr></thead><tbody><tr><td align="center">$2τ$</td><td align="center">$2τ$</td><td align="center"></td><td align="center">$2τ$</td><td align="center">$T_0$</td><td align="center">$τ$</td></tr></tbody></table><p>前面争用期时间为发生碰撞的情况，后面从发送成功到一个$τ$时间为占用信道时间。</p><h4><span id="以太网参数α">以太网参数α</span></h4><ul><li><p>定义参数$α$，以太网单程端到端时延$τ$与帧发送时间$T_0$之比，$α&#x3D;\frac t {T_0}$。当$α\rightarrow 0$，表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。$α$越大，表明争用期所占的比例增大，每发生一次碰撞浪费许多信道资源，使得信道利用率明显降低。</p></li><li><p>从式子可得当数据率一定时，以太网的连线的长度受到限制，同时以太网的帧长不能太短。</p></li></ul><h4><span id="信道利用率的最大值s_max">信道利用率的最大值$S_{max}$</span></h4><ul><li>使用非常理想化的考虑，计算极限信道利用率：</li></ul><p>$$<br>S_{max}&#x3D;\frac {T_0}{T_0+τ}&#x3D;\frac 1 {1+a}<br>$$</p><p>只有参数$α$远小于1才能得到尽可能高的极限信道利用率。若参数$α$远大于1，则极限信道利用率就远小于1，而此时实际的信道利用率就更小。当以太网的利用率达到30%时就已经处于重载的情况。</p><h3><span id="以太网的mac层">以太网的MAC层</span></h3><h4><span id="mac层的硬件地址">MAC层的硬件地址</span></h4><ul><li>MAC地址（Media Access Control Address），又称硬件地址或物理地址，是用于唯一标识网络设备的地址。在计算机网络中，MAC地址是以太网协议中的一个重要参数，用于识别数据包发送者和接收者。</li></ul><p>MAC地址，实际上就是适配器地址或适配器标识符EUI-48。</p><p>802标准所说的“地址”严格说应该是每一个站的“名字”或标识符。</p><ul><li>MAC地址由48位二进制数表示，通常被表示为12个十六进制数，每两个十六进制数之间用冒号或短横线隔开。MAC地址由两部分组成：厂商代码和设备标识符。</li></ul><p>厂商代码是由IEEE（Institute of Electrical and Electronics Engineers）注册管理机构分配的，占用24位二进制数。设备标识符是由厂商自己分配的，占用24位二进制数。</p><p>IEEE规定地址字段的第一字节最低位为I&#x2F;G位。I&#x2F;G表示Individual&#x2F;Group。当I&#x2F;G位&#x3D;0，地址字段表示一个单站地址；当I&#x2F;G位&#x3D;1，地址字段表示一个组地址。所有48位都为1，地址字段是广播地址。</p><p>IEEE规定地址字段的第一字节最低位为G&#x2F;L位。G&#x2F;L表示Global&#x2F;Local。当G&#x2F;L位&#x3D;0，是全球管理（保证在全球没有相同的地址），厂商向IEEE购买的OUI都属于全球管理。当G&#x2F;L位&#x3D;1，是本地管理，这时用户可任意分配网络上的地址。</p><ul><li>MAC地址是<strong>唯一</strong>的，每个网络设备都会被分配一个唯一的MAC地址。MAC地址通常被写在设备的网卡上，由网卡芯片固化在硬件中。在以太网中，MAC地址被用于识别数据包发送者和接收者。</li></ul><p>当一个数据包从源设备发送到目的设备时，数据包中会包含源MAC地址和目的MAC地址。网络设备通过比对数据包中的目的MAC地址和自己的MAC地址，来判断是否接收该数据包。如果目的MAC地址与设备的MAC地址相同，设备就会接收该数据包并进行处理，否则就会忽略该数据包。<br>总之，MAC地址是网络设备的一个重要标识，它是由网络设备的物理硬件决定的，一般情况下不会改变。它在网络通信中起到了重要的作用。</p><h5><span id="适配器检查mac地址">适配器检查MAC地址</span></h5><ul><li><p>适配器（Network Adapter）是计算机中用于连接计算机与网络之间的设备，也称为网卡（Network Interface Card）。在计算机网络中，适配器通常用于接收和发送网络数据包。</p></li><li><p>适配器通常具有一个硬件地址，也称为MAC地址。检查MAC地址是指在数据包到达适配器时，适配器会首先检查数据包中的目的MAC地址是否与自己的MAC地址相同。</p></li></ul><p>相同，接收该数据包并将其传递给计算机进行处理。</p><p>不同，忽略该数据包。</p><ul><li><p>“发往本站的帧”包括：单播帧（一对一，即收到的帧的MAC地址与本站硬件地址相同）、广播帧（一对全体，即发送给本局域网上所有站点的帧，全1地址）和多播帧（一对多，即发送给本局域网一部分站点的帧）。</p></li><li><p>所有的适配器都至少能够识别前两种帧，即能识别单播地址和广播地址。</p></li><li><p>只有目的地址才能使用广播地址和多播地址。</p></li></ul><h4><span id="mac帧的格式">MAC帧的格式</span></h4><ul><li>常用的以太网MAC帧格式有两种标准：DIX Ethernet V2标准（以太网V2标准）和IEEE的802.3标准。</li></ul><h5><span id="以太网v2标准的mac帧格式">以太网V2标准的MAC帧格式</span></h5><p>以太网的帧最短是64字节，而现在目的地址，原地址，类型和FCS占了18字节，所以IP数据报有效数据最小是46字节。</p><table><thead><tr><th align="center">前同步码</th><th align="center">SFD</th><th align="center">目的地址</th><th align="center">源地址</th><th align="center">类型</th><th align="center">数据（IP数据报）</th><th align="center">FCS</th></tr></thead><tbody><tr><td align="center">7byte</td><td align="center">1byte</td><td align="center">6byte</td><td align="center">6byte</td><td align="center">2byte</td><td align="center">46~1500byte</td><td align="center">4byte</td></tr></tbody></table><p>从目的地址到FCS为一个以太网MAC帧。</p><ol><li><p>前导码（前同步码）（Preamble）：7个字节的前导码，用于标识一个数据帧的开始，具体内容为1010……1010。</p></li><li><p>帧起始定界符（Start Frame Delimiter，SFD）：1个字节的帧起始定界符，用于标识前导码的结束，内容为10101011。</p></li><li><p>目的MAC地址（Destination MAC Address）：6个字节的目的MAC地址，表示接收数据包的设备的MAC地址。</p></li><li><p>源MAC地址（Source MAC Address）：6个字节的源MAC地址，表示发送数据包的设备的MAC地址。</p></li><li><p>以太网类型（Ethernet Type）：2个字节的以太网类型字段，用于指示数据帧中携带的数据的类型。常见的以太网类型有IP协议、ARP协议等。</p></li><li><p>数据（Data）：46~1500个字节的数据，用于携带传输的信息。当数据字段的长度小于46字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的MAC帧长不小于64字节。</p></li><li><p>帧校验序列（Frame Check Sequence，FCS）：4个字节的帧校验序列，用于检测数据帧是否出错。FCS是通过CRC算法生成的，它包含了整个数据帧的数据内容。当传输媒体的误码率为$1×10^{-8}$时，MAC子层可使未检测到的差错小于$1×10^{-14}$。</p></li></ol><h5><span id="ieee8023mac-帧格式">IEEE802.3MAC 帧格式</span></h5><ol><li><p>前导码（Preamble）：7个字节的前导码，用于标识一个数据帧的开始，具体内容为1010……1010。</p></li><li><p>帧起始定界符（Start Frame Delimiter，SFD）：1个字节的帧起始定界符，用于标识前导码的结束，内容为10101011。</p></li><li><p>目的MAC地址（Destination MAC Address）：6个字节的目的MAC地址，表示接收数据包的设备的MAC地址。</p></li><li><p>源MAC地址（Source MAC Address）：6个字节的源MAC地址，表示发送数据包的设备的MAC地址。</p></li><li><p>长度&#x2F;类型（Length&#x2F;Type）：2个字节的长度&#x2F;类型字段，用于指示数据帧中携带的数据的类型。如果该字段的值小于等于1500，则表示该字段指示了数据的长度；否则，表示该字段指示了数据的类型，例如IP协议、ARP协议等。</p></li><li><p>数据（Data）：46~1500个字节的数据，用于携带传输的信息。</p></li><li><p>帧校验序列（Frame Check Sequence，FCS）：4个字节的帧校验序列，用于检测数据帧是否出错。FCS是通过CRC算法生成的，它包含了整个数据帧的数据内容。</p></li><li><p>帧间隔（Interframe Gap，IFG）：12个字节的帧间隔，用于在两个数据帧之间进行时序的调整，以保证数据传输的稳定性。</p></li></ol><ul><li>与以太网V2MAC帧格式相似，区别在于：</li></ul><ol><li>IEEE 802.3规定的MAC帧的第三个字段是“长度&#x2F;类型”。</li></ol><p>当这个字段值大于0x0600时（相当于十进制的1536），就表示“类型”。这样的帧和以太网V2 MAC 帧完全一样。</p><p>当这个字段值小于0x0600时才表示“长度”。</p><ol start="2"><li>当“长度&#x2F;类型”字段值小于0x0600时，数据字段必须装入上面的逻辑链路控制LLC子层的LLC帧。</li></ol><p>现在市场上流行的都是以太网V2的MAC帧，但大家也常常称为IEEE 802.3标准的MAC帧。</p><h5><span id="无效mac帧">无效MAC帧</span></h5><ul><li><p>数据字段的长度与长度字段的值不一致；</p></li><li><p>帧的长度不是整数个字节；</p></li><li><p>用收到的帧检验序列FCS查出有差错;</p></li><li><p>数据字段的长度不在46~1500字节之间。</p></li><li><p>有效的MAC帧长度为64~1518字节之间。</p></li><li><p>对于检查出的无效MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</p></li></ul><h5><span id="帧的最小间隔">帧的最小间隔</span></h5><ul><li>帧间最小间隔为9.6 μs，相当于96 bit的发送时间。</li></ul><p>一个站在检测到总线开始空闲后，还要等待9.6μs才能再次发送数据。</p><p>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p><h2><span id="扩展的以太网">扩展的以太网</span></h2><h3><span id="在物理层扩展以太网">在物理层扩展以太网</span></h3><ul><li><p>使用光纤扩展</p></li><li><p>使用集线器扩展</p></li></ul><p>集线器集联：使网络中计算机增加，变成一个大的冲突域，冲突域数量变少了，但是数量增加了，会造成效率降低。（越多效率越低，不适合使用超过30个集线器）</p><p>优点：使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。扩大了以太网覆盖的地理范围。</p><p>缺点：碰撞域增大了，但总的吞吐量并未提高。如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</p><h3><span id="在数据链路层扩展以太网更常用的方法">在数据链路层扩展以太网(更常用的方法)</span></h3><ul><li>早期使用网桥，现在使用以太网交换机。</li></ul><h4><span id="使用网桥">使用网桥</span></h4><ul><li><p>在数据链路层扩展局域网是使用网桥。使用网桥可以拓展以太网的覆盖范围和提高网络性能。网桥是一种数据链路层设备，它可以连接多个以太网段，将它们组成一个逻辑上的单一网络。网桥通过学习每个网络中的MAC地址，将数据包从一个网络转发到另一个网络，从而实现不同网络之间的通信。</p></li><li><p>网桥工作在数据链路层，他根据MAC帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到对应的接口，或把它丢弃。</p></li><li><p>使用网桥拓展以太网的步骤如下：</p></li></ul><ol><li><p>确定网络拓扑结构：首先需要确定网络中存在的以太网段，以及它们之间的连接方式和拓扑结构。根据网络拓扑结构，选择合适的网桥类型和数量。</p></li><li><p>配置网桥参数：将网桥接入网络中，配置网桥的参数，如MAC地址、IP地址、子网掩码等。这些参数可以通过网桥设备的管理接口进行配置。</p></li><li><p>学习MAC地址：网桥通过学习每个以太网段中的MAC地址，建立MAC地址表，记录每个MAC地址所在的网络段。当网桥收到一个数据包时，它会查询MAC地址表，将数据包转发到目标网络段中的设备。</p></li><li><p>转发数据包：当网桥接收到一个数据包时，它会首先检查目标MAC地址所在的网络段是否与源MAC地址所在的网络段相同。如果目标MAC地址不在同一网络段中，则网桥会将数据包转发到目标网络段中；否则，网桥会将数据包丢弃。<br>使用网桥可以将多个以太网段组成一个逻辑上的单一网络，提高网络的可靠性和性能。同时，网桥还可以隔离不同的网络段，防止网络中的广播风暴和冲突，提高网络的安全性和稳定性。</p></li></ol><ul><li>网桥的自学习算法：</li></ul><p>若从A发出的帧从接口x进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到A。网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面。在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。</p><ul><li>好处</li></ul><p>过滤了通信量；扩大了物理范围；提高了可靠性；可互联不同的物理层，不同MAC子层和不同速率。</p><ul><li>坏处</li></ul><p>存储转发增加了时延；在MAC地址子层并没有流量控制功能；具有不同MAC子层的网段桥接在一起时时延更大；网桥值适合于用户数不太多和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。</p><h4><span id="使用以太网交换机">使用以太网交换机</span></h4><ul><li><p>以太网交换机实质上就是一个多接口的网桥，通常都有十几个或更多的接口。</p></li><li><p>每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。</p></li><li><p>以太网交换机的交换方式：存储转发方式、直通（cutthrough）方式</p></li><li><p>以太网交换机的特点：</p></li></ul><ol><li><p>高性能：以太网交换机采用硬件转发方式，能够实现高速数据传输和低延迟。通过交换机的缓存和转发能力，可以提高网络的吞吐量和性能。</p></li><li><p>灵活性：以太网交换机支持多种接口类型和速率，可以适应不同的网络环境和需求。同时，交换机还支持多种协议和网络服务，如VLAN、QoS等，提供更加灵活的网络配置和管理方式。</p></li><li><p>自学习：交换机可以自动学习网络中每个设备的MAC地址，并建立MAC地址表，记录设备的物理地址和端口号。当交换机收到一个数据包时，它会查询MAC地址表，将数据包转发到目标设备的端口上。</p></li><li><p>分割冲突域：以太网交换机将每个端口作为一个独立的冲突域，可以防止网络中的冲突和广播风暴。这种方式可以提高网络的可靠性和稳定性。</p></li><li><p>透明性：以太网交换机对网络上的设备和协议是透明的，不会影响设备之间的通信和网络协议的运行。同时，交换机还支持多种网络协议，如TCP&#x2F;IP、UDP、ICMP等，提供更加灵活的网络应用方式。</p></li></ol><h5><span id="以太网交换机的自学习功能">以太网交换机的自学习功能</span></h5><ul><li>以太网交换机的自学习功能的具体操作流程</li></ul><ol><li><p>当交换机接收到一个新的数据帧时，它会检查该帧的目标MAC地址，并将该地址与其端口关联起来，将该地址记录到其转发表中。</p></li><li><p>如果转发表中已经有了目标MAC地址的条目，则交换机可以直接将数据帧发送到对应的端口，而无需对所有端口进行广播。</p></li><li><p>如果转发表中没有目标MAC地址的条目，则交换机会将数据帧广播到所有连接的端口上，并记录下发送这个数据帧的源MAC地址和相应的端口信息。</p></li><li><p>一旦交换机确定了结构记录在转发表中的目标地址所对应的端口，它就只向那一个端口发送数据帧。</p></li><li><p>当交换机接收到新的数据帧时，它会再次更新转发表，删除多余或错误的信息，并学习记录新的MAC地址和端口信息。</p></li></ol><h5><span id="交换机使用生成树协议">交换机使用生成树协议</span></h5><ul><li><p>IEEE802.1D标准制定了一个生成树协议STP，用于消除兜圈子死循环现象。</p></li><li><p>生成树协议（Spanning Tree Protocol，STP）是一种用于以太网交换机网络中避免环路的协议。STP通过建立一棵生成树，保证网络中只有一条主干路径，从而避免数据包在网络中不断循环，造成网络拥塞和死锁。</p><ul><li>生成树算法（Spanning Tree Algorithm）是用于实现生成树协议的具体算法，最常用的是经典的 IEEE 802.1D 标准，该标准定义了以下步骤：</li></ul></li></ul><ol><li><p>选举根桥：在网络中，选举一个交换机作为根桥。根桥的选择通常是根据交换机的优先级和MAC地址来确定的。</p></li><li><p>计算路径开销：每个交换机计算到根桥的路径开销，路径开销包括端口的开销和链路的开销。其中，端口的开销是指端口的优先级和状态，链路的开销是指链路的带宽和延迟等因素。</p></li><li><p>选举根端口：每个非根交换机选举一个根端口，选举原则是选择路径开销最小的端口作为根端口。如果有多个端口开销相等，则根据端口的优先级和MAC地址来选择。</p></li><li><p>选举指定端口：每个交换机选举一个指定端口，指定端口是指连接网络中某个设备的端口。选举原则是选择路径开销次小的端口作为指定端口。如果有多个端口开销相等，则根据端口的优先级和MAC地址来选择。</p></li><li><p>阻塞端口：在生成树中，如果存在环路，则需要选择一些端口进行阻塞，从而避免数据包在网络中不断循环。阻塞端口是指连接到环路上的端口，选举原则是选择路径开销最大的端口进行阻塞。</p></li></ol><h5><span id="从总线以太网到星形以太网">从总线以太网到星形以太网</span></h5><ul><li><p>从总线以太网到星形以太网是以太网架构的演进历程，总线以太网是最早的以太网架构，所有设备共享同一条传输介质。而星形以太网采用了集线器&#x2F;交换机来分割网络，将每个设备连接到一个中心节点，从而提高了网络的可靠性和性能。</p></li><li><p>总线以太网使用CSMA&#x2F;CD协议，以半双工方式工作，存在碰撞问题。而以太网交换机实现的星形以太网以全双工方式工作，不存在碰撞问题，但由于帧结构未改变，仍采用以太网的帧结构，所以还叫做以太网。</p></li></ul><h3><span id="虚拟局域网">虚拟局域网</span></h3><ul><li><p>虚拟局域网（Virtual Local Area Network，VLAN）是一种将物理网络划分为多个逻辑网络的技术。VLAN可以通过软件配置来实现，无需更改物理网络拓扑结构，从而方便网络管理和配置。</p></li><li><p>VLAN可以将一组网络设备划分为一个独立的逻辑网络，不同的VLAN之间可以相互隔离，从而提高网络安全性和灵活性。例如，可以将某个部门的计算机划分到一个VLAN中，使得该部门的计算机只能与该VLAN中的其他设备进行通信，而无法与其他VLAN中的设备通信。</p></li><li><p>VLAN的实现可以基于端口、MAC地址、IP地址等多种方式，常见的实现方式包括：</p></li></ul><ol><li><p>基于端口：将交换机的端口划分到不同的VLAN中，不同VLAN之间通过路由器进行通信。</p></li><li><p>基于MAC地址：将设备的MAC地址作为VLAN的标识符，相同VLAN中的设备拥有相同的MAC地址前缀。</p></li><li><p>基于IP地址：将设备的IP地址作为VLAN的标识符，相同VLAN中的设备拥有相同的IP地址前缀。</p></li></ol><ul><li>VLAN的优点包括：</li></ul><ol><li><p>提高网络安全性：不同的VLAN之间可以相互隔离，从而避免未经授权的访问和攻击。</p></li><li><p>灵活性高：可以根据不同的需求和场景，灵活地划分不同的VLAN，从而提高网络的灵活性和可扩展性。</p></li><li><p>管理和配置方便：VLAN的管理和配置可以通过软件进行，无需更改物理网络拓扑结构，从而方便网络管理和配置。<br>综上所述，VLAN是一种将物理网络划分为多个逻辑网络的技术，可以提高网络安全性和灵活性，方便网络管理和配置。</p></li></ol><ul><li>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</li></ul><h4><span id="虚拟局域网使用的以太网帧格式">虚拟局域网使用的以太网帧格式</span></h4><ul><li>虚拟局域网（VLAN）使用的以太网帧格式与普通的以太网帧格式基本一致，但在帧头和帧尾中加入了VLAN标记。下面是VLAN使用的以太网帧格式：</li></ul><ol><li><p>目的MAC地址（6个字节）：表示帧的接收方的MAC地址。</p></li><li><p>源MAC地址（6个字节）：表示帧的发送方的MAC地址。</p></li><li><p>VLAN标记（4个字节）：包含802.1Q标记类型和标记控制信息。</p></li></ol><p>VLAN标记的前两个字节总是设置为0x8100（即二进制10000001 00000000），称为IEEE802.1Q标记类型。</p><p>当数据链路层检测到MAC帧的源地址字段后面的两个字节值为0x8100时，就知道现在插入了4字节的VLAN标记。于是就接着检查后面两个字节的内容。后面的两个字节，前3位时用户优先级字段，接着的一位时规范格式提示符CFI（Canonical Format Indicator），最后12位时该虚拟局域网VLAN标识符VID（VLAN ID）唯一标志这个以太网帧属于哪一个VLAN。</p><ol start="4"><li><p>类型&#x2F;长度字段（2个字节）：表示帧中上层协议的类型或数据长度。</p></li><li><p>数据字段（46~1500个字节）：表示上层协议的数据。</p></li><li><p>帧校验序列（FCS）（4个字节）：对整个帧进行校验，用于检测传输错误。</p></li><li><p>帧尾（1个字节）：表示帧的结束。</p></li></ol><h2><span id="高速以太网">高速以太网</span></h2><ul><li>高速以太网（High-Speed Ethernet)是一种以太网技术，用于实现高速数据传输。</li></ul><h3><span id="100base-t以太网">100BASE-T以太网</span></h3><ul><li><p>100BASE-T是一种以太网技术，也被称为快速以太网。它可以在100Mbps的传输速度下运行，并且使用双绞线作为物理媒介来传输数据。</p></li><li><p>100BASE-T以太网使用了交织的4B&#x2F;5B编码方案来将字节转换为信号。这种编码方案可以保证数据传输的稳定性和可靠性。它还使用了基带传输技术，即直接将数字信号发送到传输媒介上，避免了模拟信号的转换，从而提高了传输效率。</p></li><li><p>在100BASE-T以太网中，数据通过RJ-45插座连接到双绞线上，双绞线再连接到集线器或交换机等网络设备上。由于采用了CSMA&#x2F;CD协议，所以多台计算机可以同时使用同一个以太网来进行通信。</p></li><li><p>100Base-T以太网的物理层标准</p></li></ul><table><thead><tr><th align="center">名称</th><th align="center">媒体</th><th align="center">网段的最大长度</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">100BASE-TX</td><td align="center">铜缆</td><td align="center">100m</td><td align="center">两对UTP5类线或屏蔽双绞线STP</td></tr><tr><td align="center">100BASE-T4</td><td align="center">铜缆</td><td align="center">100m</td><td align="center">4对UTP3类线或5类线</td></tr><tr><td align="center">100BASE-FX</td><td align="center">光缆</td><td align="center">2000m</td><td align="center">两根光纤，发送和接收各一根</td></tr></tbody></table><ul><li>特点</li></ul><p>可以实现全双工通信(注意，如果交换机上某一路连接着集线器(半双工)，则这一路不能实现全双工)而无冲突，此时不使用CSMA&#x2F;CD协议。</p><p>MAC帧格式不变，仍是802.3 标准。</p><p>最短帧长度不变，但是一个网段的最大电缆长度减少到100m。</p><p>帧间间隔从9.6微秒缩小到0.96微秒。</p><h3><span id="吉比特以太网">吉比特以太网</span></h3><ul><li><p>允许在1 Gb&#x2F;s下全双工或半双工工作方式。</p></li><li><p>使用802.3标准的帧格式。</p></li><li><p>在半双工下使用CSMA&#x2F;CD协议。</p></li><li><p>当吉比特以太网在全双工方式时，不用载波延伸和分组冲突。</p></li><li><p>与10Base-T和100Base-T技术向后兼容。</p></li><li><p>1000Base-X以太网的物理层：</p></li></ul><table><thead><tr><th align="center">名称</th><th align="center">媒体</th><th align="center">网段最大长度</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">1000BASE-SX</td><td align="center">光缆</td><td align="center">550m</td><td align="center">多模光纤（50和62.5μm）</td></tr><tr><td align="center">1000BASE-LX</td><td align="center">光缆</td><td align="center">5000m</td><td align="center">单模光纤（10μm）多模光纤（50和62.5μm）</td></tr><tr><td align="center">1000BASE-CX</td><td align="center">铜缆</td><td align="center">25m</td><td align="center">使用2对屏蔽双绞线电缆STP</td></tr><tr><td align="center">1000BASE-T</td><td align="center">铜缆</td><td align="center">100m</td><td align="center">使用4对UTP5类线</td></tr></tbody></table><h3><span id="10吉比特以太网和更快的以太网">10吉比特以太网和更快的以太网</span></h3><ul><li><p>MAC帧格式不变，仍是802.3 标准。</p></li><li><p>使用光纤而不是铜线。</p></li><li><p>只能工作在全双工方式，没有争用问题。</p></li><li><p>它的出现使工作范围从局域网扩大到城域网和广域网，实现了端到端的以太网传输。</p></li><li><p>优点：技术成熟；互操作性好；广域网中使用以太网便宜；统一的帧格式。</p></li><li><p>40GB&#x2F;100GB以太网物理层标准</p></li></ul><table><thead><tr><th align="center">物理层</th><th align="center">40GB以太网</th><th align="center">10GB以太网</th></tr></thead><tbody><tr><td align="center">在背板上传输至少超过1m</td><td align="center">40GBASE-KR4</td><td align="center"></td></tr><tr><td align="center">在铜缆上传输至少超过7m</td><td align="center">40GBASE-CR4</td><td align="center">100GBASE-CR10</td></tr><tr><td align="center">在多模光纤上传输至少超过10m</td><td align="center">40GBASE-SR4</td><td align="center">100GBASE-SR10，100GBASE-SR4</td></tr><tr><td align="center">在单模光纤上传输至少超过10km</td><td align="center">40GBASE-LR4</td><td align="center">100GBASE-LR4</td></tr><tr><td align="center">在单模光纤上传输至少超过40km</td><td align="center">40GBASE-ER4</td><td align="center">100GBASE-ER4</td></tr></tbody></table><ul><li>以太网时可扩展的（速率从100Mbit&#x2F;s到100Gbit&#x2F;s）、灵活的（多媒体、全&#x2F;半双工、共享&#x2F;交换）、易于安装、稳健性好。</li></ul><h3><span id="使用以太网进行宽带接入">使用以太网进行宽带接入</span></h3><ul><li>以太网是一种计算机局域网技术，它可以通过使用特定的物理介质（如双绞线或光纤）将计算机设备连接到互联网服务提供商（ISP）的网络中。在宽带接入方案中，以太网通常用于将用户家庭或办公室内的路由器或调制解调器与ISP提供的宽带调制解调器相连接。这种连接方式可以提供高速、可靠的互联网连接，并且可以支持多个用户同时访问互联网。在以太网上实现宽带接入需要使用特定的协议和技术，例如动态主机配置协议（DHCP）、传输控制协议&#x2F;互联网协议（TCP&#x2F;IP）和数据包交换技术等。</li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物理层 </tag>
            
            <tag> 数据链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个博客</title>
      <link href="/%E6%97%A5%E5%B8%B8/1/"/>
      <url>/%E6%97%A5%E5%B8%B8/1/</url>
      
        <content type="html"><![CDATA[<p>博客建成：Hello World</p><span id="more"></span><ul><li>前言</li></ul><p>之前常常看博客学习内容，想着自己也可以做一个博客，记录自己的学习内容。所以此博客随之诞生。取名Fingsinz’s space。</p><ul><li>用途</li></ul><p>我想着，这个博客分为几个栏目，可以记录我的学习笔记，可以分享我平常使用体验较好的软件网站，甚至可以分享我毫无营养的日常……看看侧栏，于是分成了主页、日常、比较、好物分享、归档、关于几个模块。我还增加了搜索功能，便于搜索关键词。</p><ul><li>更多</li></ul><p>我并不是主攻前端方向，学习到的知识也较为浅薄，所以该博客还有很大改进空间。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
