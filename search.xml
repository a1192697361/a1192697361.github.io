<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一个博客</title>
    <url>/%E6%97%A5%E5%B8%B8/1/</url>
    <content><![CDATA[<p>博客建成：Hello World</p>
<span id="more"></span>

<ul>
<li>前言</li>
</ul>
<p>之前常常看博客学习内容，想着自己也可以做一个博客，记录自己的学习内容。所以此博客随之诞生。取名Fingsinz’s space。</p>
<ul>
<li>用途</li>
</ul>
<p>我想着，这个博客分为几个栏目，可以记录我的学习笔记，可以分享我平常使用体验较好的软件网站，甚至可以分享我毫无营养的日常……看看侧栏，于是分成了主页、日常、比较、好物分享、归档、关于几个模块。我还增加了搜索功能，便于搜索关键词。</p>
<ul>
<li>更多</li>
</ul>
<p>我并不是主攻前端方向，学习到的知识也较为浅薄，所以该博客还有很大改进空间。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>Qt5.14.2项目打包成软件记录</title>
    <url>/%E6%97%A5%E5%B8%B8/10/</url>
    <content><![CDATA[<p>介绍如何将Qt项目打包成软件发布</p>
<p>关键词：C++、Qt</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#1%E7%BC%96%E8%AF%91%E5%87%BAexe%E6%96%87%E4%BB%B6">1.编译出.exe文件</a></li>
<li><a href="#2%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE">2.打包项目</a></li>
</ul>
<!-- tocstop -->

<h1><span id="1编译出exe文件">1.编译出.exe文件</span></h1><p>打开需要打包的项目，在左下角选择合适的构建部件和版本，版本要选择<code>Release</code>，至于64bit还是32bit看需求。</p>
<p>选择后点击锤子编译项目，此处我以<code>MinGWx64,Release</code>编译。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_qt.jpg" alt="选择构建部件和版本"></p>
<p>点击左侧的项目，查看构建目录（项目目录跟构建目录尽量别带中文）。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_qt2.jpg" alt="查看构建目录"></p>
<p>打开构建目录，发现出现一个.exe文件。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_exe.jpg" alt="编译出.exe文件"></p>
<h1><span id="2打包项目">2.打包项目</span></h1><p>将刚才构建出来的.exe文件复制到一个新的文件夹（目录尽量不带中文），该目录作为软件的工作目录。比如我复制到<code>F:\test\HelloWorld1.0</code>，软件工作目录就是这个文件夹，test目录下的一个新建文件夹。</p>
<p>接着打开Qt的安装目录下的bin文件夹，找到<code>windeployqt.exe</code>，复制其路径，我的<code>windeployqt.exe</code>位于<code>D:\Qt\5.14.2\mingw73_64\bin</code>。</p>
<p>回到软件的工作目录（新建的文件夹），在地址栏输入cmd打开命令提示符，按格式输入：</p>
<p><code>windeployqt文件路径 发布软件的路径</code></p>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">D:\Qt\5.14.2\mingw73_64\bin\windeployqt.exe HelloWorld.exe</span><br></pre></td></tr></table></figure>

<p>慢慢等待打包完成。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/10_finish.jpg" alt="打包完成"></p>
<p>之后就可以直接打开软件工作目录下的exe执行。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Python源代码打包成.exe文件记录</title>
    <url>/%E6%97%A5%E5%B8%B8/12/</url>
    <content><![CDATA[<p>使用auto-py-to-exe将.py打包成.exe</p>
<p>关键词：Python</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#%E5%AE%89%E8%A3%85auto-py-to-exe">安装auto-py-to-exe</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8auto-py-to-exe">使用auto-py-to-exe</a></li>
</ul>
<!-- tocstop -->

<h1><span id="安装auto-py-to-exe">安装auto-py-to-exe</span></h1><p>打开cmd命令提示符，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install auto-py-to-exe</span><br></pre></td></tr></table></figure>

<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/12_download.jpg" alt="下载auto-py-to-exe"></p>
<p>等待下载完成……</p>
<h1><span id="使用auto-py-to-exe">使用auto-py-to-exe</span></h1><p>下载安装完成后，选择文件夹作为输出文件夹，我的选择的路径为 <code>F:\</code>，在此路径打开cmd命令提示符或者通过cmd命令进入到该路径。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/12_cmd.jpg" alt="cmd窗口"></p>
<p>输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auto-py-to-exe</span><br></pre></td></tr></table></figure>

<p>即可打开打包窗口。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/12_use.jpg" alt="打包窗口"></p>
<ul>
<li><p>脚本位置：选择需要打包的.py文件</p>
</li>
<li><p>单文件&#x2F;单目录：选择打包的形式，选择将依赖整体打包成一个.exe还是依赖库分离+.exe文件</p>
</li>
<li><p>控制台窗口：自行选择</p>
</li>
<li><p>图标、附加文件、高级、设置：自行选择</p>
</li>
</ul>
<p>我的打包结果：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/12_result.jpg" alt="单文件打包结果"></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/12_result1.jpg" alt="单目录打包结果"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio2022的C++项目打包成软件记录</title>
    <url>/%E6%97%A5%E5%B8%B8/11/</url>
    <content><![CDATA[<p>介绍如何将VS的C++项目打包</p>
<p>关键词：C++</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#1%E7%BC%96%E8%AF%91%E5%87%BAexe%E6%96%87%E4%BB%B6">1.编译出.exe文件</a></li>
<li><a href="#2%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE">2.打包项目</a></li>
</ul>
<!-- tocstop -->

<h1><span id="1编译出exe文件">1.编译出.exe文件</span></h1><p>选择Release生成，我在此是<code>Realease x64</code>编译。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_vs.jpg" alt="编译"></p>
<h1><span id="2打包项目">2.打包项目</span></h1><p>将刚才构建出来的.exe文件复制到一个新的文件夹（目录尽量不带中文），该目录作为软件的工作目录。比如我复制到F:\test\HelloWorld1.0，软件工作目录就是这个文件夹，test目录下的一个新建文件夹。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_exe.jpg" alt="软件工作目录"></p>
<p>打开Visual Studio的安装目录，找到<code>dumpbin.exe</code>并复制其路径，可以按照下面的路径查找：<br><code>E:\Microsoft_Visual_Studio\VS\VC\Tools\MSVC\14.36.32532\bin\Hostx64\x64</code></p>
<p>回到软件工作目录，在地址栏输入cmd打开命令提示符，按格式输入：<br><code>dumpbin.exe路径 /dependents 发布软件的路径</code></p>
<p>如：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">Microsoft_Visual_Studio</span>\<span class="title">VS</span>\<span class="title">VC</span>\<span class="title">Tools</span>\<span class="title">MSVC</span>\14.36.32532\<span class="title">bin</span>\<span class="title">Hostx64</span>\<span class="title">x64</span>\<span class="title">dumpbin.exe</span> /<span class="title">dependents</span> <span class="title">HelloWorld.exe</span></span></span><br></pre></td></tr></table></figure>

<p>接着将出现的.dll文件找出来，推荐使用<a href="https://www.voidtools.com/zh-cn/downloads/">Everything软件</a>搜索，选择路径上对应的平台（x86或x64），复制到软件的工作目录即可。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_dependents.jpg" alt="软件依赖"></p>
<p>如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/11_last.jpg" alt="完整的软件工作目录"></p>
<p>这样即可直接点击.exe文件运行。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>如何暂停Windows的系统升级</title>
    <url>/%E6%97%A5%E5%B8%B8/13/</url>
    <content><![CDATA[<p>关闭Windows的自动更新</p>
<p>关键词：Windows</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#1%E4%BF%AE%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BC%96%E8%BE%91%E5%99%A8">1.修改注册表编辑器</a></li>
<li><a href="#2%E6%89%93%E5%BC%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE">2.打开系统设置</a></li>
<li><a href="#3%E6%81%A2%E5%A4%8D%E6%9B%B4%E6%96%B0">3.恢复更新</a></li>
</ul>
<!-- tocstop -->

<h1><span id="1修改注册表编辑器">1.修改注册表编辑器</span></h1><p>按住 <code>Win</code> + <code>R</code> 输入 <code>regedit</code> 进入注册表编辑器。</p>
<p>找到 <code>HKEY_LOCAL_MACHINE → SOFTWARE → Microsoft → WindowsUpdate → UX → Settings</code></p>
<p>点击右边空白处，选择新建DWORD（32位）值，重命名为 <code>FightSettingsMaxPauseDays</code> ，</p>
<p>双击打开，选择十进制，输入想要暂停的最大天数，我这里输入 <code>8888</code> 。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/13_1.jpg" alt="添加新项"></p>
<h1><span id="2打开系统设置">2.打开系统设置</span></h1><p>按住 <code>Win</code> + <code>I</code> 打开系统设置，搜索 <code>Windows更新</code> ，进入Windows更新设置，在暂停更新处选择最大值即可。</p>
<p>Windows 10的暂停更新在 <code>Windows 更新设置 → 高级选项 → 暂停更新</code></p>
<p>效果如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/13_2.jpg" alt="暂停8888天"></p>
<h1><span id="3恢复更新">3.恢复更新</span></h1><p>直接点击继续更新即可。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>记录Keil_C51和Keil_MDK的安装</title>
    <url>/%E6%97%A5%E5%B8%B8/2/</url>
    <content><![CDATA[<p>介绍Keil_C51和Keil_MDK的安装</p>
<p>关键词：Keil</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFkeil-c51%E5%92%8Ckeil-mdk">什么是Keil C51和Keil MDK</a></li>
<li><a href="#keil-c51">Keil C51</a><ul>
<li><a href="#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F">下载安装程序</a></li>
<li><a href="#%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B">安装过程</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E8%BD%AF%E4%BB%B6">启动软件</a></li>
</ul>
</li>
<li><a href="#keil-mdk">Keil MDK</a><ul>
<li><a href="#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F-1">下载安装程序</a></li>
<li><a href="#%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B-1">安装过程</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E8%BD%AF%E4%BB%B6-1">启动软件</a></li>
</ul>
</li>
<li><a href="#keil-key-generator">Keil Key Generator</a></li>
</ul>
<!-- tocstop -->

<h1><span id="什么是keil-c51和keil-mdk">什么是Keil C51和Keil MDK</span></h1><ul>
<li><p>Keil是一家公司名称，也是一款软件名称。Keil 有四大软件（IDE），包括 MDK、C51、C251、C166。</p>
</li>
<li><p>Keil C51和MDK是针对不同类型MCU的两款集成开发工具。</p>
</li>
</ul>
<h1><span id="keil-c51">Keil C51</span></h1><h2><span id="下载安装程序">下载安装程序</span></h2><p><a href="https://www.keil.com/download/product/">Keil官网下载</a></p>
<h2><span id="安装过程">安装过程</span></h2><p>像正常软件安装一样，按需要更改安装的磁盘，建立新的文件夹空间安装，个人信息随便填，等待安装完成。</p>
<p>此次我安装路径设置为<code>G:\Keil_C51</code>中。</p>
<h2><span id="启动软件">启动软件</span></h2><p>UV4可执行文件位于：<code>G:\Keil_C51\UV4</code></p>
<h1><span id="keil-mdk">Keil MDK</span></h1><h2><span id="下载安装程序">下载安装程序</span></h2><p><a href="https://www.keil.com/download/product/">Keil官网下载</a></p>
<h2><span id="安装过程">安装过程</span></h2><p>像正常软件安装一样，按需要更改安装的磁盘，建立新的文件夹空间安装本体和Pack文件，个人信息随便填，等待安装完成。</p>
<p>此次我将本体路径设置为<code>G:\Keil_MDK</code>中，Pack路径设置为<code>G:\Keil_MDK\</code>。</p>
<h2><span id="启动软件">启动软件</span></h2><p>UV4可执行文件位于：<code>G:\Keil_MDK\UV4</code></p>
<h1><span id="keil-key-generator">Keil Key Generator</span></h1><p><a href="https://blog.csdn.net/qq_22329595/article/details/108703002">参考此博客</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Keil</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建一个自己的简单博客</title>
    <url>/%E6%97%A5%E5%B8%B8/4/</url>
    <content><![CDATA[<p>简单几步，基于Hexo搭建一个属于自己的简单博客</p>
<p>关键词：Hexo、博客</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#%E5%B7%A5%E5%85%B7%E5%87%86%E5%A4%87">工具准备</a><ul>
<li><a href="#1-nodejs">1. Nodejs</a></li>
<li><a href="#2-git">2. Git</a></li>
<li><a href="#3-%E9%AA%8C%E8%AF%81nodejs%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F">3. 验证Nodejs是否安装成功</a></li>
<li><a href="#4-cnpm">4. cnpm</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E8%A3%85hexo">安装Hexo</a></li>
<li><a href="#%E5%BC%80%E5%A7%8B%E5%BB%BA%E9%80%A0%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2">开始建造你的博客</a><ul>
<li><a href="#1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%B0%BD%E9%87%8F%E4%B8%8D%E5%86%8D%E7%A7%BB%E5%8A%A8">1. 创建一个新的文件夹，尽量不再移动。</a></li>
<li><a href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%9A%E5%AE%A2">2. 初始化博客</a></li>
<li><a href="#3-%E6%9F%A5%E7%9C%8B%E5%8D%9A%E5%AE%A2">3. 查看博客</a></li>
<li><a href="#4-%E7%BB%99%E5%8D%9A%E5%AE%A2%E4%B8%8B%E8%BD%BD%E4%B8%BB%E9%A2%98next">4. 给博客下载主题——Next</a></li>
<li><a href="#5-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">5. 修改配置文件</a></li>
</ul>
</li>
<li><a href="#%E7%BC%96%E5%86%99%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%8D%9A%E5%AE%A2">编写你的第一条博客</a></li>
<li><a href="#%E9%83%A8%E7%BD%B2%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%88%B0github">部署你的博客到Github</a><ul>
<li><a href="#1-%E5%9C%A8%E5%8D%9A%E5%AE%A2%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%93%E5%BC%80git-bash%E8%BE%93%E5%85%A5%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%91%BD%E4%BB%A4%E6%8E%A5%E7%9D%80%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BD%A0%E7%9A%84%E5%AF%86%E9%92%A5">1. 在博客根目录打开Git Bash，输入下面的命令，接着会出现你的密钥。</a></li>
<li><a href="#2-%E5%9C%A8github%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BB%E5%A4%B4%E5%83%8F-settings-ssh-and-gpg-keys-new-ssh-key%E6%8E%A5%E7%9D%80%E6%8A%8A%E5%AF%86%E9%92%A5%E5%A4%8D%E5%88%B6%E4%B8%8A%E5%8E%BB">2. 在Github页面点击头像-&gt;Settings-&gt;SSH and GPG keys-&gt;New SSH key，接着把密钥复制上去。</a></li>
<li><a href="#3-%E5%86%8D%E5%9C%A8git-bash%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%B8%8B%E9%9D%A2%E5%91%BD%E4%BB%A4">3. 再在Git Bash中执行下面命令。</a></li>
<li><a href="#4-%E7%82%B9%E5%87%BB%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93%E5%9C%A8%E5%B7%A6%E4%B8%8A%E8%A7%92%E7%9A%84clone-or-download%E4%B8%AD%E7%82%B9%E5%87%BBuse-ssh%E5%A4%8D%E5%88%B6git%E5%BC%80%E5%A4%B4%E7%9A%84%E5%9C%B0%E5%9D%80">4. 点击项目仓库，在左上角的Clone or download中点击Use SSH，复制git开头的地址。</a></li>
<li><a href="#5-%E6%89%93%E5%BC%80%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%89%BE%E5%88%B0deploy%E4%B8%80%E8%A1%8C%E6%8C%89%E7%85%A7%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%8C%87%E7%A4%BA%E4%BF%AE%E6%94%B9">5. 打开博客配置文件，找到deploy一行，按照下面的指示修改。</a></li>
<li><a href="#6-%E5%9C%A8%E5%8D%9A%E5%AE%A2%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%89%93%E5%BC%80git-bash%E5%88%86%E5%88%AB%E6%89%A7%E8%A1%8C%E4%B8%8B%E5%88%97%E5%91%BD%E4%BB%A4">6. 在博客根目录打开Git Bash，分别执行下列命令。</a></li>
<li><a href="#7-%E5%AE%89%E8%A3%85%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6">7. 安装上传插件。</a></li>
<li><a href="#8-%E4%BD%BF%E7%94%A8%E4%B8%8B%E9%9D%A2%E6%8C%87%E4%BB%A4%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2">8. 使用下面指令上传博客。</a></li>
<li><a href="#9-%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93%E9%80%89%E6%8B%A9%E4%B8%8A%E6%96%B9%E7%9A%84settings%E6%89%BE%E5%88%B0pages%E5%9C%A8source%E5%A4%84%E9%80%89%E6%8B%A9deploy-from-a-branch-%E4%B9%8B%E5%90%8E%E5%B0%B1%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9D%80%E4%BE%BF%E6%98%AF%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80">9. 打开项目仓库，选择上方的Settings，找到Pages，在Source处选择Deploy from a branch。之后就会出现一个网站地址，便是博客地址。</a></li>
</ul>
</li>
<li><a href="#%E6%B3%A8">注</a></li>
</ul>
<!-- tocstop -->

<h1><span id="工具准备">工具准备</span></h1><h2><span id="1-nodejs">1. Nodejs</span></h2><p>Nodejs简单来说就是运行在服务端的JavaScript，博客交互需要用到Nodejs。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/4_NodejsDonwload.png" alt="Nodejs下载页面"></p>
<p>选择合适的软件版本下载，<a href="https://nodejs.cn/download/">下载地址：https://nodejs.cn/download/</a></p>
<p>下载完成后按正常流程安装，可安装在非系统盘，记得选择“Add to PATH”配置PATH环境变量。我的Nodejs安装在<code>E:\Nodejs</code>中。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/4_Node.png" alt="选择"></p>
<p>注：为了软件安装简洁可控，还需要对Nodejs的内容（Cache和global）进行规划，具体可参考<a href="https://juejin.cn/post/7227434605392642104">nodejs的安装及详细环境配置</a>或<a href="https://blog.csdn.net/Ouchieve_111/article/details/70878090">修改项目默认node_modules路径</a>或<a href="https://blog.csdn.net/scorpio_meng/article/details/83314675">node安装后的设置(node_global和node_cache) - windows</a>，或自行搜索。</p>
<h2><span id="2-git">2. Git</span></h2><p>Git是一个分布式版本控制系统，简单理解为它可以帮助我们管理文件各种版本，博客的更新之类的。</p>
<p><a href="https://git-scm.com/">下载地址：https://git-scm.com/</a></p>
<p>下载完成后按正常流程安装，可安装在非系统盘，其他选项可以保持默认。我的Git安装在<code>E:\Git</code>中。</p>
<h2><span id="3-验证nodejs是否安装成功">3. 验证Nodejs是否安装成功</span></h2><p>在桌面鼠标右键，选择菜单中的Git Bash Here。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/4_%E5%8F%B3%E9%94%AE.jpg" alt="右键菜单"></p>
<p>在弹出的窗口中输入以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>若出现了对应的版本号，则说明安装成功。若不出现版本号，则检查Nodejs的安装过程，或者必应搜索相关帮助。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/4_%E9%AA%8C%E8%AF%81.png" alt="验证Nodejs安装"></p>
<h2><span id="4-cnpm">4. cnpm</span></h2><p>上面的<code>npm -v</code>查看了npm的版本，可以简单理解为npm是一种下载工具。而npm下载一般是通过国外网络下载，速度比较慢。因此需要先通过npm安装cnpm（国内下载），之后就是用cnpm代替npm。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>通过查询版本号验证是否安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>

<h1><span id="安装hexo">安装Hexo</span></h1><p>Hexo是一种博客框架，通过它可以将简单的Markdown语言转化为带装饰的网页。</p>
<p>通过下面命令安装Hexo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>也可以通过查询版本号确认Hexo是否安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo -V</span><br></pre></td></tr></table></figure>

<p>Hexo的常用命令：<code>hexo -s</code>本地查看博客，<code>hexo g</code>生成博客，<code>hexo clean</code>删除当前博客所有网页页面。</p>
<h1><span id="开始建造你的博客">开始建造你的博客</span></h1><h2><span id="1-创建一个新的文件夹尽量不再移动">1. 创建一个新的文件夹，尽量不再移动。</span></h2><p>如我在F盘创建了一个文件夹叫<code>15.Blog</code>，就在15.Blog文件夹下右键选择Git Bash。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/4_%E5%8D%9A%E5%AE%A21.png"></p>
<h2><span id="2-初始化博客">2. 初始化博客</span></h2><p>在窗口中输入命令，等待完成。（如果运行至<code>Install dependencies</code>卡住，可以<code>Ctrl + C</code>结束命令）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h2><span id="3-查看博客">3. 查看博客</span></h2><p>在窗口中输入命令，查看博客的初始页面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h2><span id="4-给博客下载主题next">4. 给博客下载主题——Next</span></h2><p>点击<a href="https://hexo.io/themes/">此处</a>寻找合适的主题，以Next为例，因为该主题基础、自定义程度高。</p>
<p>可以用git指令将Github的主题压缩包下载到博客的<code>themes/</code>文件夹中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 复制的地址 themes/主题名字</span><br></pre></td></tr></table></figure>

<p>上面指令意思是将指定地址的内容克隆到本地<code>themes/</code>文件夹并命名为指定名字。<br>也可以直接下载压缩包粘贴至<code>themes/</code>文件夹中。</p>
<h2><span id="5-修改配置文件">5. 修改配置文件</span></h2><p>在博客的根目录中有一个名为<code>_config</code>的文本文件，在主题目录也有一个名为<code>_config</code>的文本文件，此处做区分，前者为博客配置文件，后者为主题配置文件。</p>
<p>打开博客配置文件，可以根据<a href="https://hexo.io/zh-cn/docs/configuration">官方配置介绍</a>进行修改个性化博客。<br>将博客配置文件中<code>themes</code>一行填入刚下载的next主题，即可使用该主题。在博客目录打开Git Bash，输入<code>hexo s</code>可以查看博客。</p>
<p>注意：有些主题你更换之后是暂时无法预览的，因为有的主题还需要安装它需要的依赖。</p>
<h1><span id="编写你的第一条博客">编写你的第一条博客</span></h1><p>在博客根目录打开Git Bash，输入下面的指令即可创建文章。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;文章名字&quot;</span></span><br></pre></td></tr></table></figure>

<p>每次生成的文章都固定在你的博客根目录下面的<code>source/_posts</code>下，并以Markdown文件形式编写保存。</p>
<h1><span id="部署你的博客到github">部署你的博客到Github</span></h1><p>首先需要有一个Github账号，并且新建仓库名为<code>用户名+.github.io</code>。</p>
<p>接着需要进行一系列的密钥绑定：</p>
<h2><span id="1-在博客根目录打开git-bash输入下面的命令接着会出现你的密钥">1. 在博客根目录打开Git Bash，输入下面的命令，接着会出现你的密钥。</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “your_email@youremail.com“</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<h2><span id="2-在github页面点击头像-gtsettings-gtssh-and-gpg-keys-gtnew-ssh-key接着把密钥复制上去">2. 在Github页面点击头像-&gt;Settings-&gt;SSH and GPG keys-&gt;New SSH key，接着把密钥复制上去。</span></h2><h2><span id="3-再在git-bash中执行下面命令">3. 再在Git Bash中执行下面命令。</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>接着提示<code>Are you sure you want to continue connecting (yes/no/[fingerprint])? </code>，输入yes回车即可。</p>
<h2><span id="4-点击项目仓库在左上角的clone-or-download中点击use-ssh复制git开头的地址">4. 点击项目仓库，在左上角的Clone or download中点击Use SSH，复制git开头的地址。</span></h2><h2><span id="5-打开博客配置文件找到deploy一行按照下面的指示修改">5. 打开博客配置文件，找到deploy一行，按照下面的指示修改。</span></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">	repo: 复制到的地址</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>

<h2><span id="6-在博客根目录打开git-bash分别执行下列命令">6. 在博客根目录打开Git Bash，分别执行下列命令。</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure>

<h2><span id="7-安装上传插件">7. 安装上传插件。</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h2><span id="8-使用下面指令上传博客">8. 使用下面指令上传博客。</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h2><span id="9-打开项目仓库选择上方的settings找到pages在source处选择deploy-from-a-branch-之后就会出现一个网站地址便是博客地址">9. 打开项目仓库，选择上方的Settings，找到Pages，在Source处选择Deploy from a branch。之后就会出现一个网站地址，便是博客地址。</span></h2><h1><span id="注">注</span></h1><p>如有纰漏，可同步参考<a href="https://www.cnblogs.com/huanhao/p/hexobase.html">此篇博客</a>或自行搜索他人教程相互参考。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 10下安装CUDA、TensorRT记录</title>
    <url>/%E6%97%A5%E5%B8%B8/5/</url>
    <content><![CDATA[<p>GPU：NVIDIA GeFOrce GTX 1050</p>
<p>关键词：深度学习、YOLOv5、TensorRT、C++推演</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#%E4%B8%80-%E4%B8%8B%E8%BD%BDcuda">一、下载CUDA</a><ul>
<li><a href="#1%E7%A1%AE%E5%AE%9A%E9%80%82%E9%85%8D%E6%9C%AC%E6%9C%BA%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%9A%84cuda%E7%89%88%E6%9C%AC">1.确定适配本机显卡驱动的CUDA版本</a></li>
<li><a href="#2%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84cuda">2.下载对应版本的CUDA</a></li>
<li><a href="#3%E5%AE%89%E8%A3%85cuda">3.安装CUDA</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E4%B8%8B%E8%BD%BDcudnn%E5%8C%85">二、下载cuDNN包</a><ul>
<li><a href="#1%E9%80%89%E6%8B%A9%E9%80%82%E9%85%8Dcuda%E7%9A%84%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%9A%84cudnn%E5%8C%85">1.选择适配CUDA的版本下载对应的cuDNN包</a></li>
<li><a href="#2%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E4%BD%8D%E7%BD%AE%E8%A7%A3%E5%8E%8Bcudnn%E5%8E%8B%E7%BC%A9%E5%8C%85">2.选择合适的位置解压cuDNN压缩包</a></li>
<li><a href="#3%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6">3.复制文件</a></li>
<li><a href="#4%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F">4.验证是否成功</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89-%E4%B8%8B%E8%BD%BDtensorrt%E5%8C%85">三、下载TensorRT包</a><ul>
<li><a href="#1%E9%80%89%E6%8B%A9%E9%80%82%E9%85%8Dcuda%E7%89%88%E6%9C%AC%E7%9A%84tensorrt%E5%8C%85%E4%B8%8B%E8%BD%BD">1.选择适配CUDA版本的TensorRT包下载</a></li>
<li><a href="#2%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E4%BD%8D%E7%BD%AE%E8%A7%A3%E5%8E%8Btensorrt%E5%8E%8B%E7%BC%A9%E5%8C%85">2.选择合适的位置解压TensorRT压缩包</a></li>
<li><a href="#3%E5%AE%89%E8%A3%85tensorrt">3.安装TensorRT</a></li>
<li><a href="#4%E9%AA%8C%E8%AF%81tensort">4.验证TensoRT</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="一-下载cuda">一、下载CUDA</span></h1><h2><span id="1确定适配本机显卡驱动的cuda版本">1.确定适配本机显卡驱动的CUDA版本</span></h2><p>系统搜索打开NVIDIA控制面板，点击帮助，选择系统信息-&gt;组件，找到CUDA字样。此处我的CUDA适配版本为<code>12.0</code>。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/5_CUDA%E7%89%88%E6%9C%AC.jpg" alt="CUDA版本查看"></p>
<h2><span id="2下载对应版本的cuda">2.下载对应版本的CUDA</span></h2><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">下载地址 - NVIDIA官网</a></p>
<h2><span id="3安装cuda">3.安装CUDA</span></h2><p>点击下载的安装exe文件，可以更改文件安装位置，记住文件安装位置。此处我的安装位置是<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code>。</p>
<h1><span id="二-下载cudnn包">二、下载cuDNN包</span></h1><h2><span id="1选择适配cuda的版本下载对应的cudnn包">1.选择适配CUDA的版本下载对应的cuDNN包</span></h2><p><a href="https://developer.nvidia.com/rdp/cudnn-archive">下载地址 - NVIDIA官网</a></p>
<h2><span id="2选择合适的位置解压cudnn压缩包">2.选择合适的位置解压cuDNN压缩包</span></h2><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/5_cuDNN.jpg" alt="解压cuDNN后的文件"></p>
<h2><span id="3复制文件">3.复制文件</span></h2><p>cuDNN属于是CUDA的一个补丁包，因此无需安装。需要将<code>bin</code>、<code>include</code>、<code>lib</code>文件夹中的相关文件拷贝到CUDA安装位置的<code>bin</code>、<code>include</code>、<code>lib的x64</code>文件夹中。</p>
<p>我的CUDA安装位置是：<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code>。</p>
<h2><span id="4验证是否成功">4.验证是否成功</span></h2><p><code>Win + R</code>输入cmd打开cmd窗口。<br>直接输入盘符如<code>F:</code>跳转到F盘，<code>cd</code>进入到具体地址。<br>比如我的CUDA安装在<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code>，<br>那么进入到<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\extras\demo_suite</code></p>
<p>接着在cmd窗口输入下面的指令分别运行两个exe文件，结果出现PASS（如图）则验证成功。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">bandwidthTest.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/5_cuDNN%E9%AA%8C%E8%AF%81.jpg" alt="第一个exe运行结果"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">deviceQuery.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/5_cuDNN%E9%AA%8C%E8%AF%812.jpg" alt="第二个exe运行结果"></p>
<h1><span id="三-下载tensorrt包">三、下载TensorRT包</span></h1><h2><span id="1选择适配cuda版本的tensorrt包下载">1.选择适配CUDA版本的TensorRT包下载</span></h2><p>进入<a href="https://developer.nvidia.com/nvidia-tensorrt-download">官网</a>，选择较新的大版本，再选择适合自己安装的CUDA版本下载。</p>
<p>我在此处下载Windows的支持CUDA12.0的版本。</p>
<h2><span id="2选择合适的位置解压tensorrt压缩包">2.选择合适的位置解压TensorRT压缩包</span></h2><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/5_TensorRT.jpg" alt="解压TensorRT后的文件"></p>
<h2><span id="3安装tensorrt">3.安装TensorRT</span></h2><ul>
<li>将TensorRT的<code>include</code>文件夹中文件复制到CUDA安装位置的<code>include</code>文件夹。</li>
</ul>
<p>我的操作是：<code>copy \TensorRT-8.6.1.6\include → NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include</code></p>
<ul>
<li><p>将TensorRT的<code>lib</code>中所有lib文件复制到CUDA安装位置的<code>lib\x64</code>文件夹</p>
</li>
<li><p>将TensorRT的<code>lib</code>中所有dll文件复制到CUDA安装位置的<code>bin</code>文件夹</p>
</li>
</ul>
<h2><span id="4验证tensort">4.验证TensoRT</span></h2><p>检查系统环境变量中是否有包含了CUDA的bin文件夹，没有则添加。</p>
<p>使用Visual Studio打开sampleMNIST示例，即打开<code>../TensorRT-8.6.1.6\samples\sampleOnnxMNIST</code>文件夹中的sln文件，必要时对项目属性的常规、VC++目录、C&#x2F;C++里面的环境进行配置，添加依赖。<a href="https://blog.csdn.net/shanglianlm/article/details/92847719">参考</a></p>
<p>右键项目，点击重新生成。可以点击不调试运行测试。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>YOLOv5</tag>
        <tag>TensorRT</tag>
        <tag>C++推演</tag>
      </tags>
  </entry>
  <entry>
    <title>使用阿里云对象存储OSS实现图床</title>
    <url>/%E6%97%A5%E5%B8%B8/3/</url>
    <content><![CDATA[<p>注册登录阿里云👉开启对象存储👉配置Key👉放心上传</p>
<p>关键词：对象存储OSS</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#1%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE%E5%BA%8A">1.什么是图床</a></li>
<li><a href="#2%E5%BC%80%E5%90%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1">2.开启对象存储服务</a></li>
<li><a href="#3%E4%BD%BF%E7%94%A8picgo%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0">3.使用PicGo工具进行图片上传</a></li>
</ul>
<!-- tocstop -->

<h1><span id="1什么是图床">1.什么是图床</span></h1><p>图床是一种概念，顾名思义用于网络上存放图片。当网站图片过多时，整个网站的存储大小会变得较大，负担也变得较大。为了减轻负担，可以选择把图片置于一种存储容器（图床）中，之后显示图片就只需引用网络链接即可。</p>
<h1><span id="2开启对象存储服务">2.开启对象存储服务</span></h1><p> 进入<a href="https://cn.aliyun.com/">阿里云官网</a>，点击右上角控制台，搜索对象存储OSS。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/3_1.png" alt="阿里云页面"></p>
<p>选择创建Bucket，设置建议如下：</p>
<ul>
<li>Bucket名称：自定义</li>
<li>地域：选择距离自己较近的</li>
<li>存储类型：默认不动</li>
<li>存储荣誉类型：默认不动</li>
<li>读写权限：公共读</li>
</ul>
<p>创建成功后可在Bucket列表查看。</p>
<h1><span id="3使用picgo工具进行图片上传">3.使用PicGo工具进行图片上传</span></h1><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/">下载地址</a></p>
<p>下载后选择合适的盘符安装，打开软件。<br>初始时可能不显示界面，需要去系统任务栏右键软件图标，选择打开主窗口。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/3_2.png" alt="软件打开"></p>
<p>接着选择图床设置，此处使用阿里云OSS。</p>
<p>回到阿里云OSS控制台，移动至右上角悬浮，点击AccessKey管理。创建一个新AccessKey，复制并粘贴到PicGo中。</p>
<p>配置参数建议如下：</p>
<ul>
<li>设定KeyID：AccessKey中复制得来</li>
<li>设定KeySecret：AccessKey中复制得来</li>
<li>设定Bucket：你Bucket得名字</li>
<li>设定存储区域：OSS选择的地域</li>
<li>设定存储路径：图片上传至OSS的文件夹或路径</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/3_3.png" alt="配置Key"></p>
<p>配置完成后即可上传图片，在PicGo的相册中可以获得图片的连接，可在HTML或者Markdown等文件中调用。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>对象存储OSS</tag>
      </tags>
  </entry>
  <entry>
    <title>C++报错：表达式必须含有常量值</title>
    <url>/%E6%97%A5%E5%B8%B8/6/</url>
    <content><![CDATA[<p>关于在Visual Studio 2022使用C++ 20语法的表达式开辟数组空间报错</p>
<p>关键词：C++</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0">错误原因</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B">错误示例</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
</ul>
<!-- tocstop -->

<h1><span id="错误原因">错误原因</span></h1><ol>
<li><p>c++中不允许使用变量作为数组的长度定义数组，必须为常量值，c++中所有的内存需求都是在程序执行前通过定义的常量来确定的。</p>
</li>
<li><p>声明为const或constexpr的表达式在编译时计算结果不是常数。</p>
</li>
<li><p>编译器必须能够在表达式被使用时确定表达式的值。</p>
</li>
</ol>
<h1><span id="错误示例">错误示例</span></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示范1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>, c = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> d[a * b * c]; <span class="comment">// error</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示范2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>, c = <span class="number">5</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> tmp = a * b * c;</span><br><span class="line">	<span class="type">int</span> d[tmp]; <span class="comment">// error，如错误原因2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示范3</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> array_size; <span class="comment">// error</span></span><br><span class="line">    <span class="type">int</span> size_array[array_size];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> test::array_size = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<h1><span id="解决方案">解决方案</span></h1><p>使用<code>new</code>进行动态内存分配，<strong>记得通过<code>delete</code>回收分配的内存</strong>，如上述代码改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>, c = <span class="number">5</span>;</span><br><span class="line">	<span class="type">int</span> *d = <span class="keyword">new</span> <span class="type">int</span>[a * b * c];</span><br><span class="line">	<span class="keyword">delete</span>[] d;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于new分配内存的使用：</p>
<ol>
<li>单变量分配</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type *p = <span class="keyword">new</span> Type;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">Type *p = <span class="keyword">new</span> <span class="built_in">Type</span>(<span class="number">2</span>); <span class="comment">//动态分配内存并初始化</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>一维数组申请</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type *p = <span class="keyword">new</span> Type[n];</span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br><span class="line"></span><br><span class="line">Type *p = <span class="keyword">new</span> Type[n]();<span class="comment">//动态分配内存并初始化全部为0</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>二维数组申请</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type **p = <span class="keyword">new</span> Type *[m];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">	p[i] = <span class="keyword">new</span> Type[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv5由pt文件转onnx文件报错解决</title>
    <url>/%E6%97%A5%E5%B8%B8/7/</url>
    <content><![CDATA[<p>ONNX: export failure ❌ 5.9s: Unsupported ONNX opset version: 17</p>
<p>关键词：深度学习、YOLOv5、onnx</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#%E6%8A%A5%E9%94%99%E7%AA%97%E5%8F%A3">报错窗口</a></li>
<li><a href="#%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0">报错原因</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
</ul>
<!-- tocstop -->

<h1><span id="报错窗口">报错窗口</span></h1><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/7_error.png" alt="报错"></p>
<h1><span id="报错原因">报错原因</span></h1><p>export.py文件中parse_opt()函数设置的opset版本错误。</p>
<h1><span id="解决方案">解决方案</span></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找到parse_opt()函数中的此行，将default值改为12</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--opset&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">12</span>, <span class="built_in">help</span>=<span class="string">&#x27;ONNX: opset version&#x27;</span>)</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>YOLOv5</tag>
        <tag>onnx</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下Python3.11.4的安装记录</title>
    <url>/%E6%97%A5%E5%B8%B8/8/</url>
    <content><![CDATA[<p>记录一次安装Python</p>
<p>关键词：Python</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#%E4%B8%8B%E8%BD%BDpython%E5%AE%89%E8%A3%85%E5%8C%85">下载Python安装包</a></li>
<li><a href="#%E5%AE%89%E8%A3%85python">安装Python</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95python">测试Python</a></li>
<li><a href="#%E9%99%84%E6%9B%B4%E6%94%B9python%E7%9A%84pip%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84">附：更改Python的pip安装路径</a></li>
</ul>
<!-- tocstop -->

<h1><span id="下载python安装包">下载Python安装包</span></h1><p><a href="https://www.python.org/downloads/windows/">官网</a>选择尽量较新的Python版本下载。</p>
<h1><span id="安装python">安装Python</span></h1><p>打开下载的Python安装包，选择<code>Customize installation</code>客制化安装，记得勾选下面的“Add python.exe to PATH”。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py1.jpg" alt="安装步骤1"></p>
<p>接着默认勾选：</p>
<ul>
<li>pip：包管理器，下载包时使用。建议勾选上</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py2.jpg" alt="安装步骤2"></p>
<p>再接着更改安装路径，建议安装在非系统盘。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py3.jpg" alt="安装步骤3"></p>
<p>等待安装完成即可。</p>
<h1><span id="测试python">测试Python</span></h1><p>按下<code>Win+R</code>输入<code>cmd</code>打开命令窗口，输入下面命令验证是否安装成功。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python -V</span><br></pre></td></tr></table></figure>

<p>如果出现版本号，即为安装成功。</p>
<h1><span id="附更改python的pip安装路径">附：更改Python的pip安装路径</span></h1><p>建议将pip安装的包放至非系统盘。进入Python的安装路径，如我的在<code>D:\Pyhton\Lib</code>，寻找文件<code>site.py</code>，使用记事本打开。使用<code>ctrl+f</code>查找关键字<code>USER_SITE</code>等字，将路径更改为自定义的路径。我更改情况如下图。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py.jpg" alt="更改路径"></p>
<p>更改路径后，打开cmd，使用下面指令安装numpy包。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure>

<p>安装成功后，再使用下面指令查看numpy包的安装位置。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip show numpy</span><br></pre></td></tr></table></figure>

<p>我成功更改pip的安装路径，新下载的numpy包位于<code>D:\Pyhton\Lib\site-packages</code>。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/8_py4.jpg" alt="更改路径后"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio2022的OpenCV4.5.2和CUDA12.0项目配置</title>
    <url>/%E6%97%A5%E5%B8%B8/9/</url>
    <content><![CDATA[<p>记录一次环境配置</p>
<p>关键词：深度学习、OpenCV、CUDA</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#opencv%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">OpenCV的环境配置</a><ul>
<li><a href="#opencv%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">OpenCV下载安装</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0opencv%E5%88%B0%E7%B3%BB%E7%BB%9Fpath%E5%8F%98%E9%87%8F">添加OpenCV到系统Path变量</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0opencv%E7%8E%AF%E5%A2%83%E5%88%B0vs%E9%A1%B9%E7%9B%AE">添加OpenCV环境到VS项目</a><ul>
<li><a href="#vc%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AEopencv">VC++目录配置OpenCV</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E9%85%8D%E7%BD%AEopencv">链接器配置OpenCV</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#cuda%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">CUDA环境配置</a><ul>
<li><a href="#cuda%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">CUDA下载安装</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0cuda%E7%8E%AF%E5%A2%83%E5%88%B0vs%E9%A1%B9%E7%9B%AE">添加CUDA环境到VS项目</a><ul>
<li><a href="#vc%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AEcuda">VC++目录配置CUDA</a></li>
<li><a href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E9%85%8D%E7%BD%AEcuda">链接器配置CUDA</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E9%A3%8E%E6%A0%BC">配置源码文件风格</a></li>
</ul>
</li>
<li><a href="#%E6%B5%8B%E8%AF%95cuda%E4%BB%A3%E7%A0%81">测试CUDA代码</a></li>
<li><a href="#cuda%E7%8E%AF%E5%A2%83%E7%9A%84%E4%B8%80%E4%BA%9B%E7%A2%B0%E5%A3%81">CUDA环境的一些碰壁</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="opencv的环境配置">OpenCV的环境配置</span></h1><h2><span id="opencv下载安装">OpenCV下载安装</span></h2><p>前往官网选择适合的OpenCV版本下载，并安装到合适的位置。</p>
<p><a href="https://opencv.org/releases/">官网下载OpenCV</a></p>
<p>我的OpenCV安装在：<code>D:\opencv4.5.2</code></p>
<h2><span id="添加opencv到系统path变量">添加OpenCV到系统Path变量</span></h2><p>打开编辑系统环境变量，点击右下方的环境变量，在系统变量中找到PATH项，点击编辑添加OpenCV目录下的bin文件夹。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_opencv2PATH.jpg" alt="添加OpenCV至PATH"></p>
<p>至于添加的是vc14还是vc15，参照下表</p>
<table>
<thead>
<tr>
<th align="center">VS版本</th>
<th align="center">VC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">VS2015</td>
<td align="center">VC14</td>
</tr>
<tr>
<td align="center">VS2017及以上</td>
<td align="center">VC15</td>
</tr>
</tbody></table>
<h2><span id="添加opencv环境到vs项目">添加OpenCV环境到VS项目</span></h2><p>右键项目，选择最下方属性，打开属性配置窗口，选择是Debug模式或Release模式配置。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_vs1.jpg" alt="VS项目配置窗口"></p>
<h3><span id="vc目录配置opencv">VC++目录配置OpenCV</span></h3><ol>
<li><strong>点击包含目录</strong>，在包含目录中把OpenCV目录下的include文件夹添加。</li>
</ol>
<p>此处我的添加是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\opencv4.5.2\build\include\opencv2</span><br><span class="line">D:\opencv4.5.2\build\include</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>点击库目录</strong>，在库目录中把OpenCV的lib文件添加，此处路径藏得比较深，参考我的添加。</li>
</ol>
<p>此处我的添加是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\opencv4.5.2\build\x64\vc15\lib</span><br></pre></td></tr></table></figure>

<h3><span id="链接器配置opencv">链接器配置OpenCV</span></h3><ol>
<li><strong>点击输入，再点击附加依赖项</strong>，将OpenCV的lib文件添加，lib文件存放在上面库目录的文件夹中。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opencv_world452.lib</span><br><span class="line">opencv_world452d.lib</span><br></pre></td></tr></table></figure>

<p>注意，此处文件名带<code>d</code>的为Debug版本的依赖项，不带<code>d</code>的为Release版本的依赖项。<br>在配置Debug版本时把带<code>d</code>的文件放在不带<code>d</code>的文件之上，<br>在配置Release版本时把不带<code>d</code>的文件放在带<code>d</code>的文件之上。</p>
<h1><span id="cuda环境配置">CUDA环境配置</span></h1><h2><span id="cuda下载安装">CUDA下载安装</span></h2><p><a href="http://fingsinz.space/%E6%97%A5%E5%B8%B8/5/">参考此条博客</a></p>
<p>我的CUDA目录在：<code>G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0</code></p>
<h2><span id="添加cuda环境到vs项目">添加CUDA环境到VS项目</span></h2><p>配置为x64平台。</p>
<p>右键项目→生成依赖项→生成自定义→勾选“CUDA xxx”。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_cuda.jpg" alt="生成依赖项"></p>
<h3><span id="vc目录配置cuda">VC++目录配置CUDA</span></h3><ol>
<li><strong>点击包含目录</strong>，在包含目录中把OpenCV目录下的include文件夹添加。</li>
</ol>
<p>此处我的添加是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>点击库目录</strong>，在库目录中把OpenCV的lib文件夹添加。</li>
</ol>
<p>此处我的添加是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\lib\x64</span><br></pre></td></tr></table></figure>

<h3><span id="链接器配置cuda">链接器配置CUDA</span></h3><ol>
<li><strong>点击常规，再点击附加库目录</strong>，添加下面的目录。<em>似乎不配置这一条也可以</em></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(CUDA_PATH_V12_0)\lib\$(Platform)</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Debug配置下：</span><br><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\lib\Win32</span><br><span class="line">Release配置下：</span><br><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\lib\x64</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>点击输入，再点击附加依赖项</strong>，将CUDA的lib文件添加，输入下面的内容。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\lib\x64\*.lib</span><br></pre></td></tr></table></figure>

<h3><span id="配置源码文件风格">配置源码文件风格</span></h3><p>右键源文件，可以添加新建项中选择“CUDA C&#x2F;C++ File”。<br>右键“xxx.cu”源文件，点击属性，选择配置属性中的常规，从项类型中找到“CUDA C&#x2F;C++”。</p>
<h2><span id="测试cuda代码">测试CUDA代码</span></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cuda_runtime.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;device_launch_parameters.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">cudaError_t <span class="title">addWithCuda</span><span class="params">(<span class="type">int</span> *c, <span class="type">const</span> <span class="type">int</span> *a, <span class="type">const</span> <span class="type">int</span> *b, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">addKernel</span><span class="params">(<span class="type">int</span> *c, <span class="type">const</span> <span class="type">int</span> *a, <span class="type">const</span> <span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = threadIdx.x;</span><br><span class="line">    c[i] = a[i] + b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> arraySize = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a[arraySize] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b[arraySize] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="type">int</span> c[arraySize] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add vectors in parallel.</span></span><br><span class="line">    cudaError_t cudaStatus = <span class="built_in">addWithCuda</span>(c, a, b, arraySize);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;addWithCuda failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#123;1,2,3,4,5&#125; + &#123;10,20,30,40,50&#125; = &#123;%d,%d,%d,%d,%d&#125;\n&quot;</span>,</span><br><span class="line">        c[<span class="number">0</span>], c[<span class="number">1</span>], c[<span class="number">2</span>], c[<span class="number">3</span>], c[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cudaDeviceReset must be called before exiting in order for profiling and</span></span><br><span class="line">    <span class="comment">// tracing tools such as Nsight and Visual Profiler to show complete traces.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaDeviceReset</span>();</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaDeviceReset failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper function for using CUDA to add vectors in parallel.</span></span><br><span class="line"><span class="function">cudaError_t <span class="title">addWithCuda</span><span class="params">(<span class="type">int</span> *c, <span class="type">const</span> <span class="type">int</span> *a, <span class="type">const</span> <span class="type">int</span> *b, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *dev_a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *dev_b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *dev_c = <span class="number">0</span>;</span><br><span class="line">    cudaError_t cudaStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Choose which GPU to run on, change this on a multi-GPU system.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaSetDevice</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaSetDevice failed!  Do you have a CUDA-capable GPU installed?&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate GPU buffers for three vectors (two input, one output)    .</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_c, size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMalloc failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_a, size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMalloc failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_b, size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMalloc failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy input vectors from host memory to GPU buffers.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMemcpy</span>(dev_a, a, size * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMemcpy failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMemcpy</span>(dev_b, b, size * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMemcpy failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Launch a kernel on the GPU with one thread for each element.</span></span><br><span class="line">    addKernel&lt;&lt;&lt;<span class="number">1</span>, size&gt;&gt;&gt;(dev_c, dev_a, dev_b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for any errors launching the kernel</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaGetLastError</span>();</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;addKernel launch failed: %s\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(cudaStatus));</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cudaDeviceSynchronize waits for the kernel to finish, and returns</span></span><br><span class="line">    <span class="comment">// any errors encountered during the launch.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaDeviceSynchronize</span>();</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaDeviceSynchronize returned error code %d after launching addKernel!\n&quot;</span>, cudaStatus);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy output vector from GPU buffer to host memory.</span></span><br><span class="line">    cudaStatus = <span class="built_in">cudaMemcpy</span>(c, dev_c, size * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyDeviceToHost);</span><br><span class="line">    <span class="keyword">if</span> (cudaStatus != cudaSuccess) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cudaMemcpy failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Error:</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_c);</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_a);</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cudaStatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/9_result.jpg" alt="测试结果"></p>
<h2><span id="cuda环境的一些碰壁">CUDA环境的一些碰壁</span></h2><ol>
<li><p>我的CUDA安装在一个可移动固态硬盘（G盘）中，可能导致了我的CUDA项目只能位于G盘使用，复制粘贴到电脑的盘会出现问题。</p>
</li>
<li><p>如果出现了大段指令无法运行，像下面的错误显示，可以复制命令（引号部分）到cmd运行，查看更详细的报错原因。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// VS报错如下</span><br><span class="line">严重性	代码	说明	项目	文件	行	禁止显示状态</span><br><span class="line">错误	MSB3721	命令“&quot;G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\bin\nvcc.exe&quot; -gencode=arch=compute_52,code=\&quot;sm_52,compute_52\&quot; --use-local-env -ccbin &quot;E:\Microsoft_Visual_Studio\VS\VC\Tools\MSVC\14.33.31629\bin\HostX64\x64&quot; -x cu   -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include  -G   --keep-dir x64\Debug  -maxrregcount=0  --machine 64 --compile -cudart static  -g  -D_DEBUG -D_CONSOLE -D_UNICODE -DUNICODE -Xcompiler &quot;/EHsc /W3 /nologo /Od /FdG:\Data\Coding_Master\yolov5-trt\bin\immediate\x64\Debug\vc143.pdb /FS /Zi /RTC1 /MDd &quot; -o G:\Data\Coding_Master\yolov5-trt\bin\x64\File.cu.obj &quot;G:\Data\Coding_Master\yolov5-trt\File.cu&quot;”已退出，返回代码为 1。	yolov5-trt	E:\Microsoft_Visual_Studio\VS\MSBuild\Microsoft\VC\v170\BuildCustomizations\CUDA 12.0.targets	794</span><br><span class="line"></span><br><span class="line">// 复制命令部分，即下面部分到cmd输入</span><br><span class="line">&quot;G:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\bin\nvcc.exe&quot; -gencode=arch=compute_52,code=\&quot;sm_52,compute_52\&quot; --use-local-env -ccbin &quot;E:\Microsoft_Visual_Studio\VS\VC\Tools\MSVC\14.33.31629\bin\HostX64\x64&quot; -x cu   -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include -IG:\NVIDIA_GPU_Computing_Toolkit_CUDA_v12.0\include  -G   --keep-dir x64\Debug  -maxrregcount=0  --machine 64 --compile -cudart static  -g  -D_DEBUG -D_CONSOLE -D_UNICODE -DUNICODE -Xcompiler &quot;/EHsc /W3 /nologo /Od /FdG:\Data\Coding_Master\yolov5-trt\bin\immediate\x64\Debug\vc143.pdb /FS /Zi /RTC1 /MDd &quot; -o G:\Data\Coding_Master\yolov5-trt\bin\x64\File.cu.obj &quot;G:\Data\Coding_Master\yolov5-trt\File.cu&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>还遇到一些其他的坑可以自行必应。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>OpenCV</tag>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML语言学习记录</title>
    <url>/HTML/HTML/</url>
    <content><![CDATA[<p>HTML：基础</p>
<p>关键词：HTML</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#html%E5%89%8D%E8%A8%80">HTML前言</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFhtml">什么是HTML？</a></li>
<li><a href="#html5">HTML5</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E5%BC%8Fweb%E8%AE%BE%E8%AE%A1">响应式Web设计</a></li>
<li><a href="#html%E6%A0%87%E5%87%86%E5%AD%97%E7%AC%A6%E9%9B%86">HTML标准字符集</a></li>
<li><a href="#html%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E5%99%A8%E4%B8%8E%E8%B7%AF%E5%BE%84">HTML统一资源定位器与路径</a></li>
<li><a href="#xhtml">XHTML</a></li>
</ul>
</li>
<li><a href="#html%E5%85%83%E7%B4%A0%E7%90%86%E5%BF%B5">HTML元素理念</a><ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E8%AF%AD%E6%B3%95">语法</a></li>
<li><a href="#%E5%85%83%E7%B4%A0%E5%AE%9E%E4%BE%8B">元素实例</a></li>
<li><a href="#%E5%85%83%E7%B4%A0%E5%B5%8C%E5%A5%97">元素嵌套</a></li>
</ul>
</li>
<li><a href="#html%E5%B1%9E%E6%80%A7%E7%90%86%E5%BF%B5">HTML属性理念</a></li>
<li><a href="#html%E5%A4%B4%E9%83%A8%E5%85%83%E7%B4%A0">HTML头部元素</a></li>
<li><a href="#html%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0">HTML基本元素</a><ul>
<li><a href="#html%E6%A0%87%E9%A2%98">HTML标题</a></li>
<li><a href="#html%E6%AE%B5%E8%90%BD">HTML段落</a></li>
<li><a href="#html%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B1%BB%E6%A0%87%E7%AD%BE">HTML格式化类标签</a><ul>
<li><a href="#%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A0%87%E7%AD%BE">文本格式化标签</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BE%93%E5%87%BA%E6%A0%87%E7%AD%BE">“计算机输出”标签</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E5%92%8C%E6%9C%AF%E8%AF%AD%E5%AE%9A%E4%B9%89">引用和术语定义</a></li>
</ul>
</li>
<li><a href="#html%E9%93%BE%E6%8E%A5">HTML链接</a></li>
<li><a href="#html%E5%9B%BE%E5%83%8F">HTML图像</a></li>
<li><a href="#html%E8%A1%A8%E6%A0%BC%E5%85%83%E7%B4%A0">HTML表格元素</a><ul>
<li><a href="#table%E6%A0%87%E7%AD%BE">table标签</a></li>
<li><a href="#caption%E6%A0%87%E7%AD%BE">caption标签</a></li>
<li><a href="#th%E6%A0%87%E7%AD%BE%E4%B8%8Etd%E6%A0%87%E7%AD%BE">th标签与td标签</a></li>
<li><a href="#tr%E6%A0%87%E7%AD%BE">tr标签</a></li>
<li><a href="#thead%E6%A0%87%E7%AD%BE-tbody%E6%A0%87%E7%AD%BE%E5%92%8Ctfoot%E6%A0%87%E7%AD%BE">thead标签、tbody标签和tfoot标签</a></li>
<li><a href="#col%E6%A0%87%E7%AD%BE">col标签</a></li>
<li><a href="#colgroup%E6%A0%87%E7%AD%BE">colgroup标签</a></li>
</ul>
</li>
<li><a href="#html%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0">HTML列表元素</a><ul>
<li><a href="#%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8">无序列表</a></li>
<li><a href="#%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8">有序列表</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%88%97%E8%A1%A8">定义列表</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E6%A0%87%E7%AD%BE">列表标签</a><ul>
<li><a href="#ol%E6%A0%87%E7%AD%BE">ol标签</a></li>
<li><a href="#ul%E6%A0%87%E7%AD%BE">ul标签</a></li>
<li><a href="#li%E6%A0%87%E7%AD%BE">li标签</a></li>
<li><a href="#dl%E6%A0%87%E7%AD%BE-dt%E6%A0%87%E7%AD%BE%E5%92%8Cdd%E6%A0%87%E7%AD%BE">dl标签、dt标签和dd标签</a></li>
<li><a href="#dir%E6%A0%87%E7%AD%BE%E5%92%8Cmenu%E6%A0%87%E7%AD%BE">dir标签和menu标签</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#html%E5%9D%97">HTML块</a><ul>
<li><a href="#div%E5%85%83%E7%B4%A0">div元素</a></li>
<li><a href="#span%E5%85%83%E7%B4%A0">span元素</a></li>
</ul>
</li>
<li><a href="#html%E7%B1%BB%E6%A0%87%E7%AD%BE">HTML类标签</a></li>
<li><a href="#html%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6">HTML内联框架</a></li>
<li><a href="#html%E5%B8%83%E5%B1%80%E7%B1%BB%E6%A0%87%E7%AD%BE">HTML布局类标签</a><ul>
<li><a href="#html5%E8%AF%AD%E4%B9%89%E5%85%83%E7%B4%A0">HTML5语义元素</a></li>
<li><a href="#%E6%A1%86%E6%9E%B6">框架</a><ul>
<li><a href="#%E6%A0%87%E7%AD%BE">标签</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#html%E8%A1%A8%E5%8D%95">HTML表单</a><ul>
<li><a href="#form%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7">form元素属性</a><ul>
<li><a href="#action%E5%B1%9E%E6%80%A7">action属性</a></li>
<li><a href="#target%E5%B1%9E%E6%80%A7">target属性</a></li>
<li><a href="#method%E5%B1%9E%E6%80%A7">method属性</a><ul>
<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a></li>
</ul>
</li>
<li><a href="#autocomplete%E5%B1%9E%E6%80%A7">autocomplete属性</a></li>
<li><a href="#novalidate%E5%B1%9E%E6%80%A7">novalidate属性</a></li>
<li><a href="#accept-charset%E5%B1%9E%E6%80%A7">accept-charset属性</a></li>
<li><a href="#enctype%E5%B1%9E%E6%80%A7">enctype属性</a></li>
<li><a href="#name%E5%B1%9E%E6%80%A7">name属性</a></li>
<li><a href="#rel%E5%B1%9E%E6%80%A7">rel属性</a></li>
</ul>
</li>
<li><a href="#input%E5%85%83%E7%B4%A0%E8%BE%93%E5%85%A5%E7%B1%BB%E5%9E%8B">input元素输入类型</a><ul>
<li><a href="#%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5">文本输入</a></li>
<li><a href="#%E5%AF%86%E7%A0%81%E8%BE%93%E5%85%A5">密码输入</a></li>
<li><a href="#%E5%8D%95%E9%80%89%E6%8C%89%E9%92%AE%E8%BE%93%E5%85%A5">单选按钮输入</a></li>
<li><a href="#%E5%A4%8D%E9%80%89%E6%A1%86%E8%BE%93%E5%85%A5">复选框输入</a></li>
<li><a href="#%E6%8C%89%E9%92%AE%E8%BE%93%E5%85%A5">按钮输入</a></li>
<li><a href="#%E6%8F%90%E4%BA%A4%E6%8C%89%E9%92%AE">提交按钮</a></li>
<li><a href="#html5%E6%96%B0%E5%A2%9E%E8%BE%93%E5%85%A5%E7%B1%BB%E5%9E%8B">HTML5新增输入类型</a></li>
</ul>
</li>
<li><a href="#input%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7">input元素属性</a></li>
<li><a href="#select%E5%85%83%E7%B4%A0"><code>&lt;select&gt;</code>元素</a></li>
<li><a href="#textarea%E5%85%83%E7%B4%A0">textarea元素</a></li>
<li><a href="#button%E5%85%83%E7%B4%A0">button元素</a></li>
</ul>
</li>
<li><a href="#html%E5%AA%92%E4%BD%93">HTML媒体</a><ul>
<li><a href="#html%E5%AF%B9%E8%B1%A1">HTML对象</a><ul>
<li><a href="#object%E5%85%83%E7%B4%A0">object元素</a></li>
<li><a href="#embed%E5%85%83%E7%B4%A0">embed元素</a></li>
</ul>
</li>
<li><a href="#html%E9%9F%B3%E9%A2%91">HTML音频</a><ul>
<li><a href="#audio%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7">audio标签属性</a></li>
</ul>
</li>
<li><a href="#html%E8%A7%86%E9%A2%91">HTML视频</a><ul>
<li><a href="#video%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7">video标签属性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#html5%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0">HTML5新增元素</a><ul>
<li><a href="#fieldset%E5%85%83%E7%B4%A0">fieldset元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#html-id%E5%B1%9E%E6%80%A7">HTML id属性</a></li>
</ul>
<!-- tocstop -->

<h1><span id="html前言">HTML前言</span></h1><h2><span id="什么是html">什么是HTML？</span></h2><ul>
<li>HTML，为HyperTest Markup Language的缩写，意为超文本标记语言。其是一种用于创建网页的标准标记语言。</li>
<li>HTML由一系列元素组成，可以用于描述网页的结构。</li>
<li>HTML使用各种元素使得浏览器展示内容，并使用元素标记内容片段。</li>
<li>作为HTML文件，必须以一个声明开始。<br>这个声明表示文档类型，帮助浏览器正确展示网页内容。其只需在每个文档开头出现一次，它也不注重大小写。一般的HTML5文件以<code>&lt;!DOCTYPE html&gt;</code>开始。</li>
<li>HTML文件应该以<code>&lt;html&gt;</code>开始并以<code>&lt;/html&gt;</code>结束。</li>
<li>HTML文件的可视部分应该在<code>&lt;body&gt;</code>和<code>&lt;/body&gt;</code>之间。</li>
<li>HTML整体是大小写不敏感，但为了格式与美观，一般有统一的标准。</li>
<li>HTML使用<code>&lt;!-- --&gt;</code>进行注释。</li>
</ul>
<h2><span id="html5">HTML5</span></h2><ul>
<li>HTML5 是最新的 HTML 标准。</li>
<li>HTML5 是专门为承载丰富的 web 内容而设计的，并且无需额外插件。</li>
<li>HTML5 拥有新的<a href="https://www.w3school.com.cn/html/html5_browsers.asp">语义</a>、图形以及多媒体元素。</li>
<li>HTML5 提供的新<a href="https://www.w3school.com.cn/html/html5_new_elements.asp">元素</a>和新的 API 简化了 web 应用程序的搭建。</li>
<li>HTML5 是跨平台的，被设计为在不同类型的硬件（PC、平板、手机、电视机等等）之上运行。</li>
</ul>
<h2><span id="响应式web设计">响应式Web设计</span></h2><ul>
<li>响应式Web设计，Responsive Web Design，能够以可变尺寸传递网页。</li>
<li>可以使用Bootstrap创建响应式设计。</li>
</ul>
<h2><span id="html标准字符集">HTML标准字符集</span></h2><ul>
<li>为了正确显示HTML页面，在<code>&lt;meta&gt;</code>标签中设置编码。如：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符集有很多，如ASCII码，UTF-8码，ISO-8859-1码，推荐用UTF-8码。</li>
<li>在使用某些字符时，存在歧义，使用<a href="https://www.w3school.com.cn/charsets/ref_html_8859.asp">实体代码或编号</a>表示。</li>
<li><a href="https://www.w3school.com.cn/charsets/ref_utf_punctuation.asp">更多字符</a></li>
</ul>
<h2><span id="html统一资源定位器与路径">HTML统一资源定位器与路径</span></h2><ul>
<li>统一资源定位器和路径不完全相同。</li>
<li>URL，Uniform Resource Locator，统一资源定位器，也被称为网址。</li>
<li>URL 只能使用 ASCII 字符集来通过因特网进行发送。URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。</li>
<li>网址具有一定的语法规则：scheme:&#x2F;&#x2F;host.domain:port&#x2F;path&#x2F;filename<br>scheme定义因特网服务类型，常见为http和https。<br>host定义域主机，http默认主机是www。<br>domain定义因特网域名。<br>:port定义主机上的端口号。<br>path定义服务器上的路径，省略默认根目录。<br>filename定义文档、资源的名称。</li>
<li>路径描述了网站文件夹结构中某个文件的位置，使用相对路径是个好习惯。</li>
</ul>
<h2><span id="xhtml">XHTML</span></h2><ul>
<li>XHTML是指可扩展超文本标记语言，是更严格更纯净的HTML版本。</li>
<li>其与HTML4.01几乎相同。</li>
</ul>
<h1><span id="html元素理念">HTML元素理念</span></h1><h2><span id="定义">定义</span></h2><ul>
<li>HTML 元素指的是从开始标签（<code>&lt;xxx&gt;</code>）到结束标签（<code>&lt;/xxx&gt;</code>）的所有代码。其包含开始标签，内容和结束标签。</li>
</ul>
<h2><span id="语法">语法</span></h2><ul>
<li>HTML元素以开始标签起始。</li>
<li>HTML元素以结束标签终止。</li>
<li>元素的内容是开始标签与结束标签之间的内容。</li>
<li>某些HTML元素具有空内容。</li>
<li>没有内容的 HTML 元素被称为空元素。空元素在开始标签中进行关闭（以开始标签的结束而结束，即无结束标签）。</li>
<li>在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。在开始标签中添加斜杠，比如 <code>&lt;br /&gt;</code>，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。即使<code>&lt;br&gt;</code>在所有浏览器中都是有效的，但使用<code>&lt;br /&gt;</code>其实是更长远的保障。</li>
<li>大多数HTML元素可拥有属性。</li>
</ul>
<h2><span id="元素实例">元素实例</span></h2><ul>
<li>如<code>&lt;html&gt;</code>和<code>&lt;/html&gt;</code>元素（<code>&lt;html&gt;</code>与<code>&lt;/html&gt;</code>标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。），<code>&lt;body&gt;</code>和<code>&lt;/body&gt;</code>元素（body元素包含文档的所有内容），HTML标题，HTML段落，HTML链接，HTML图像等。</li>
</ul>
<h2><span id="元素嵌套">元素嵌套</span></h2><ul>
<li><p>大多数HTML元素可以嵌套（即包含其他HTML元素）如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 标签&lt;p&gt;表示段落元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1><span id="html属性理念">HTML属性理念</span></h1><ul>
<li>属性为 HTML 元素提供附加信息。</li>
<li>HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。</li>
<li>属性总是在 HTML 元素的开始标签中规定。</li>
<li>属性总是以名称或值对的形式出现</li>
<li><a href="https://www.w3school.com.cn/tags/html_ref_standardattributes.asp">HTML全局属性</a></li>
</ul>
<h1><span id="html头部元素">HTML头部元素</span></h1><ol>
<li><code>&lt;head&gt;</code>元素</li>
</ol>
<ul>
<li>定义关于文档的信息。</li>
<li><code>&lt;head&gt;</code>标签放在文档的开始处，紧跟在<code>&lt;html&gt;</code>后面，并处于<code>&lt;body&gt;</code>标签或<code>&lt;frameset&gt;</code>标签之前。</li>
<li><code>&lt;head&gt;</code>元素是所有头部元素的容器。<code>&lt;head&gt;</code>内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息，等等。以下标签都可以添加到 head 部分：<code>&lt;title&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>、<code>&lt;script&gt;</code>以及<code>&lt;style&gt;</code>。</li>
<li>属性<br>profile，可以设置URL，一个由空格分隔的URL列表，这些URL包含有关页面的元数据信息。<br>文档的头部经常会包含一些<code>&lt;meta&gt;</code>标签，用来告诉浏览器关于文档的附加信息。在将来，创作者可能会利用预先定义好的标准文档的元数据配置文件（metadata profile），以便更好地描述它们的文档。profile属性提供了与当前文档相关联的配置文件的 URL。</li>
</ul>
<ol start="2">
<li><code>&lt;title&gt;</code>元素</li>
</ol>
<ul>
<li>定义文档标题，定义浏览器工具栏中的标题，定义页面被收藏时显示的标题，定义显示在搜索引擎结果中的页面标题。</li>
<li>title元素在所有 HTML&#x2F;XHTML文档中都是必需的。</li>
<li>属性</li>
</ul>
<p>dir，可以设置值，规定元素中内容的文本方向。</p>
<p>lang，可以设置代码，规定元素中内容的语言代码。</p>
<p>xml:lang，可以设置代码，规定XHTML文档中元素内容的语言代码。</p>
<ol start="3">
<li><code>&lt;base&gt;</code>元素</li>
</ol>
<ul>
<li>定义页面上所有链接的默认地址或默认目标（target）。</li>
<li>其必须位于head元素内部。</li>
<li>属性</li>
</ul>
<p>href，可以设置URL，规定页面中所有相对链接的基准URL。即设置默认地址。</p>
<p>target，可以设置值，规定在何处打开页面中的所有链接。值包括“_blank”，“_parent”，“_self”，“_top”，和框架名。</p>
<ol start="4">
<li><code>&lt;link&gt;</code>元素</li>
</ol>
<ul>
<li>定义文档与外部资源之间的关系。</li>
<li><code>&lt;link&gt;</code>标签最常用于连接样式表。</li>
<li>属性</li>
</ul>
<p>charset，可以设置字符编码方式，在HTML5不支持。</p>
<p>href，可以设置URL，规定被链接文档的位置。</p>
<p>hreflang，可以设置语言代码，规定被链接文档中文本的语言。</p>
<p>media，可以设置媒体查询，规定被链接文档将被显示在什么设备上。</p>
<p>referrerpolicy，可以设置值，规定在获取资源时使用的引荐来源信息。值包括“no-referrer”，“no-referrer-when-downgrade”，“origin”，“origin-when-cross-origin”，“unsafe-url”。</p>
<p>rel，可以设置值，规定当前文档与被链接文档之间的关系。值包括“alternate”，“author”，“help”，“icon”，“licence”，“next”，“pingback”，“prefetch”，“prev”，“search”，“sidebar”，“stylesheet”，“tag”。</p>
<p>rev，可以设置反向关系，在HTML5中不支持。</p>
<p>sizes，可以设置值，规定被链接资源的尺寸，仅适用<code>rel=&quot;icon&quot;</code>。值包括“heightxwidth”，“any”。</p>
<p>target，可以设置目标，在HTML5中不支持。</p>
<p>type，可以设置MIME类型，规定被链接文档的MIME类型。</p>
<ol start="5">
<li><code>&lt;style&gt;</code>元素</li>
</ol>
<ul>
<li>定义文档的样式信息。如：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:red&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Header 1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>属性</li>
</ul>
<p>type，只能设置text&#x2F;css，规定样式表的MIME类型。</p>
<p>media，可以设置值，为样式表规定不同的媒介类型。值包括“screen”，“tty”，“tv”，“projection”，“handheld”，“print”，“braille”，“aural”，“all”。</p>
<ol start="6">
<li><code>&lt;meta&gt;</code>元素</li>
</ol>
<ul>
<li>定义关于HTML文档的元数据。</li>
<li><code>&lt;meta&gt;</code>标签位于文档的头部，不包含任何内容。<code>&lt;meta&gt;</code>标签的属性定义了与文档相关联的名称&#x2F;值对。</li>
<li><code>&lt;meta&gt;</code>无结束标签。</li>
<li>属性</li>
</ul>
<p>charset，可以设置字符，规定HTML文档的字符编码。</p>
<p>content，可以设置文本，定义与http-equiv或name相关的元信息。</p>
<p>content 属性提供了名称&#x2F;值对中的值。该值可以是任何有效的字符串。content 属性始终要和name属性或http-equiv属性一起使用。</p>
<p>http-equiv，可以设置值，把content属性关联到HTTP头部。值包括“content-security-policy”，“content-type”，“default-style”，“refresh”。</p>
<p>name，可以设置值，把content属性关联到一个名称。值包括“application-name”，“author”，“description”，“generator”，“keywords”，“viewport”。</p>
<p>scheme，可以设置一些文本，定义用于解释content属性值的格式。scheme 属性用于指定要用来翻译属性值的方案。此方案应该在由 <code>&lt;head&gt;</code>标签的 profile 属性指定的概况文件中进行了定义。</p>
<ol start="7">
<li><code>&lt;script&gt;</code>元素</li>
</ol>
<ul>
<li>定义客户端脚本。比如JavaScript。</li>
<li>属性</li>
</ul>
<p>async，规定异步执行脚本（仅适用于外部脚本）。</p>
<p>charset，可以设置编码，规定在外部脚本文件中使用的字符编码。</p>
<p>crossorigin，可以设置值，将请求模式设置为HTTP CORS请求。值包括“anonymous”，“use-credentials”。</p>
<p>defer，规定是否对脚本执行进行延迟，直到页面加载为止。</p>
<p>language，规定脚本语言，不赞成使用，用type代替。</p>
<p>referrerpolicy，可以设置值，规定外部脚本文件的URL。值包括“no-referrer”，“no-referrer-when-downgrade”，“origin”，“origin-when-cross-origin”，“same-origin”，“strict-origin”，“strict-origin-when-cross-origin”，“unsafe-url”。</p>
<p>src，可以设置URL，规定外部脚本文件的URL。</p>
<p>xml:space，规定是否保留代码中的空白。</p>
<p>type，可以设置MIME类型，指示脚本的MIME类型。</p>
<h1><span id="html基本元素">HTML基本元素</span></h1><h2><span id="html标题">HTML标题</span></h2><ul>
<li>标题（Heading）是通过<code>&lt;h1&gt;</code>~&#96;<h6><span id="等标签进行定义的-定义最大的标题-96定义最小的标题"><code>等标签进行定义的。</code><h1><code>定义最大的标题。</code><h6>&#96;定义最小的标题。</h6></h1></span></h6></li>
<li>具有“align”属性，其值有“left”、“center”、“right”和“justify”，规定了标题中文本的排列。</li>
<li><code>&lt;hr /&gt;</code>标签在 HTML 页面中创建水平线。hr元素可用于分隔内容。</li>
</ul>
<h2><span id="html段落">HTML段落</span></h2><ul>
<li>段落是通过<code>&lt;p&gt;</code>标签定义的。</li>
<li>具有“align”属性，其值有“left”、“center”、“right”和“justify”，规定了段落中文本的排列。</li>
<li><code>&lt;br /&gt;</code>标签可以在段落中进行换行。</li>
</ul>
<h2><span id="html格式化类标签">HTML格式化类标签</span></h2><h3><span id="文本格式化标签">文本格式化标签</span></h3><ul>
<li><code>&lt;b&gt;</code>和<code>&lt;/b&gt;</code>加粗字体</li>
<li><code>&lt;strong&gt;</code>和<code>&lt;/strong&gt;</code>加重语气</li>
<li><code>&lt;big&gt;</code>和<code>&lt;/big&gt;</code>加大字体</li>
<li><code>&lt;small&gt;</code>和<code>&lt;/small&gt;</code>小字体</li>
<li><code>&lt;em&gt;</code>和<code>&lt;/em&gt;</code>着重文字</li>
<li><code>&lt;i&gt;</code>和<code>&lt;/i&gt;</code> 斜体字</li>
<li><code>&lt;sup&gt;</code>和<code>&lt;/sup&gt;</code>上标</li>
<li><code>&lt;sub&gt;</code>和<code>&lt;/sub&gt;</code>下标</li>
<li><code>&lt;del&gt;</code>和<code>&lt;/del&gt;</code>删除字</li>
<li><code>&lt;ins&gt;</code>和<code>&lt;/ins&gt;</code>下划线</li>
</ul>
<h3><span id="计算机输出标签">“计算机输出”标签</span></h3><ul>
<li><code>&lt;code&gt;</code>和<code>&lt;/code&gt;</code>计算机代码字体</li>
<li><code>&lt;kbd&gt;</code>和<code>&lt;/kbd&gt;</code>键盘码字体</li>
<li><code>&lt;samp&gt;</code>和<code>&lt;/samp&gt;</code>计算机代码样本字体</li>
<li><code>&lt;tt&gt;</code>和<code>&lt;/tt&gt;</code>打字机代码字体</li>
<li><code>&lt;var&gt;</code>和<code>&lt;/var&gt;</code>定义变量字体</li>
<li><code>&lt;pre&gt;</code>和<code>&lt;/pre&gt;</code>预格式文本字体</li>
</ul>
<h3><span id="引用和术语定义">引用和术语定义</span></h3><ul>
<li><code>&lt;abbr&gt;</code>和<code>&lt;/abbr&gt;</code>定义缩写，鼠标悬浮显示内容</li>
<li><code>&lt;acronym&gt;</code>和<code>&lt;/acronym&gt;</code>定义首字母缩写，鼠标悬浮显示内容。</li>
<li><code>&lt;address&gt;</code>和<code>&lt;/address&gt;</code>定义地址</li>
<li><code>&lt;bdo&gt;</code>和<code>&lt;/bdo&gt;</code>定义文字方向，具有dir属性，值为“rtl”(right-to-left)和“ltr”(left-to-right)</li>
<li><code>&lt;blockquote&gt;</code>和<code>&lt;/blockquote&gt;</code>定义长引用</li>
<li><code>&lt;q&gt;</code>和<code>&lt;/q&gt;</code>定义短引用</li>
<li><code>&lt;cite&gt;</code>和<code>&lt;/cite&gt;</code>定义引用、引证；<code>&lt;dfn&gt;</code>和<code>&lt;/dfn&gt;</code>定义项目。</li>
</ul>
<h2><span id="html链接">HTML链接</span></h2><ul>
<li>链接或者超链接，可以是一个字、一个词、一幅画像，可以点击跳转到新的内容。</li>
<li>链接是通过<code>&lt;a&gt;</code>定义的。</li>
<li>开始标签和结束标签之间的文字被作为超级链接来显示。超级链接可以是文本、图片或者其他HTML元素。</li>
<li><code>&lt;a&gt;</code>标签具有href属性和name属性，href属性用于创建指向另一个文档的链接，name属性用于创建文档内的书签。用法如下。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span> = <span class="string">&quot;flag&quot;</span>&gt;</span>这是一句话<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://cn.bing.com/&quot;</span> &gt;</span>A link to Bing<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;#flag&quot;</span>&gt;</span>跳转到顶部句子<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;a&gt;</code>标签具有target属性，其用于定义被链接的文档在何处显示。如<code>&lt;a href=&quot;http://cn.bing.com/&quot; target=&quot;_blank&quot;&gt;A Link&lt;/a&gt;</code>中的<code>target=&quot;_blank&quot;</code>表示在新的窗口打开文档。</li>
</ul>
<h2><span id="html图像">HTML图像</span></h2><ul>
<li>在 HTML 中，图像由<code>&lt;img&gt;</code>标签定义。<code>&lt;img&gt;</code>是空标签，意思是说，它只包含属性，并且没有闭合标签。</li>
<li>页面上显示图像需要使用源属性（src，source），源属性的值是图像的URL地址。如：<code>&lt;img src=&quot;xxx/image.jpg&quot;&gt;</code>，则image这个jpg文件需要在源属性的值的地址上。</li>
<li>替换文本属性（Alt），用来为图像定义一串预备的可替换的文本。替换文本属性的值是人为定义的。即当图片无法显示时，展示alt属性的值的文字。如：<code>&lt;img src=&quot;xxx/a.jpg&quot; alt=&quot;test&quot;&gt;</code>，当a.jpg无法显示时，显示test。</li>
<li>img标签中可以使用align属性进行图像与文本对齐。此处align的值可选“bottom”、“middle”和“top”，默认bottom对齐。</li>
<li>img标签中可以使用align属性进行文本和图像位置设定。此处align的值可选“left”、“right”，分别用于图像固定段落的左端和右端。</li>
<li>img标签中可以使用width和height属性进行更改图像的大小。如：<code>&lt;img src=&quot;xxx/a.jpg&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;</code></li>
<li>可以将<code>&lt;a&gt;</code>标签和<code>&lt;img&gt;</code>结合，制作能跳转链接的图片。如：<code>&lt;a href=&quot;http://cn.bing.cn&quot;&gt;&lt;img src=&quot;xxx/a.jpg&quot;&gt;&lt;/a&gt;</code></li>
<li>img标签中还有以下属性</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">border</td>
<td align="center">像素值</td>
<td align="center">定义图像周围的边框</td>
</tr>
<tr>
<td align="center">hspace</td>
<td align="center">像素值</td>
<td align="center">定义图像左侧和右侧的空白</td>
</tr>
<tr>
<td align="center">ismap</td>
<td align="center">URL</td>
<td align="center">将图像定义为服务器端图像映射</td>
</tr>
<tr>
<td align="center">loading</td>
<td align="center">eager&#x2F;lazy</td>
<td align="center">规定浏览器是立即加载图像还是推迟加载屏幕外图像</td>
</tr>
<tr>
<td align="center">longdesc</td>
<td align="center">URL</td>
<td align="center">指向包含长的图像描述文档的URL</td>
</tr>
<tr>
<td align="center">referrerpolicy</td>
<td align="center">no-referrer&#x2F;no-referrer-when-downgrade&#x2F;origin&#x2F;origin-when-cross-origin&#x2F;unsafe-url</td>
<td align="center">规定获取图像时要使用的引荐来源信息</td>
</tr>
<tr>
<td align="center">usemap</td>
<td align="center">URL</td>
<td align="center">将图像定义为客户器端图像映射</td>
</tr>
<tr>
<td align="center">vspace</td>
<td align="center">像素值</td>
<td align="center">定义图像顶部和底部的空白</td>
</tr>
</tbody></table>
<ul>
<li>在body标签中使用background属性可以使用图像作为背景。但如果图像小于页面，图像会进行重复。</li>
<li>使用<code>&lt;map&gt;</code>标签和<code>&lt;area&gt;</code>标签制作图像映射。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;xxx/a.jpg&quot;</span> <span class="attr">usemap</span>=<span class="string">&quot;#amap&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--map标签中有属性name和id，与img标签usemap对应--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--map标签中id属性时必须且唯一的，name属性时可选的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;amap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;amap&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--area标签中有shape属性、coords属性等--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;180,139,14&quot;</span> <span class="attr">href</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;129,161,10&quot;</span> <span class="attr">href</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;rect&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;0,0,110,260&quot;</span> <span class="attr">href</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>area标签的其他属性如下：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">coords</td>
<td align="center">坐标值</td>
<td align="center">定义可点击区域的坐标和大小</td>
</tr>
<tr>
<td align="center">download</td>
<td align="center">文件名</td>
<td align="center">指定用户点击超链接时下载目标</td>
</tr>
<tr>
<td align="center">href</td>
<td align="center">URL</td>
<td align="center">此区域目标URL</td>
</tr>
<tr>
<td align="center">hreflang</td>
<td align="center">language_code</td>
<td align="center">规定区域中URL的语言</td>
</tr>
<tr>
<td align="center">media</td>
<td align="center">media query</td>
<td align="center">规定目标URL优化的媒体、设备</td>
</tr>
<tr>
<td align="center">referrerpolicy</td>
<td align="center">no-referrer&#x2F;no-referrer-when-downgrade&#x2F;origin&#x2F;origin-when-cross-origin&#x2F;same-origin&#x2F;strict-origin-when-cross-origin&#x2F;unsafe-url</td>
<td align="center">规定用户单击超链接时发送引荐来源信息</td>
</tr>
<tr>
<td align="center">rel</td>
<td align="center">alternate&#x2F;author&#x2F;bookmark&#x2F;help&#x2F;licence&#x2F;next&#x2F;nofollow&#x2F;noreferrer&#x2F;prefatch&#x2F;prev&#x2F;search&#x2F;tag</td>
<td align="center">规定区域中目标URL的语言</td>
</tr>
<tr>
<td align="center">nohref</td>
<td align="center">nohref</td>
<td align="center">从图像映射排除某个区域</td>
</tr>
<tr>
<td align="center">shape</td>
<td align="center">default&#x2F;rect&#x2F;circ&#x2F;poly</td>
<td align="center">定义区域形状</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">_blank&#x2F;_parent&#x2F;_self&#x2F;_top</td>
<td align="center">规定在何处打开href属性指定目标的URL</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">media_type</td>
<td align="center">规定目标URL的Internet媒体类型</td>
</tr>
</tbody></table>
<h2><span id="html表格元素">HTML表格元素</span></h2><ul>
<li>表格由<code>&lt;table&gt;</code>标签定义。每个表格均有若干行（由<code>&lt;tr&gt;</code>标签定义），每行被分割为若干单元格（由<code>&lt;td&gt;</code>标签定义）。</li>
<li>字母 tr 指一行（table row）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</li>
<li>表格的表头用<code>&lt;th&gt;</code>标签表示。</li>
<li>为了避免空单元边框（添加border属性）不显示，在空单元格中添加一个空格占位符（<code>&amp;nbsp;</code>），就可以将边框显示出来。</li>
<li>表格标签：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">标签</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;table&gt;</code></td>
<td align="center">定义表格</td>
</tr>
<tr>
<td align="center"><code>&lt;caption&gt;</code></td>
<td align="center">定义表格标题</td>
</tr>
<tr>
<td align="center"><code>&lt;th&gt;</code></td>
<td align="center">定义表格的表头</td>
</tr>
<tr>
<td align="center"><code>&lt;tr&gt;</code></td>
<td align="center">定义表格的行</td>
</tr>
<tr>
<td align="center"><code>&lt;td&gt;</code></td>
<td align="center">定义表格单元</td>
</tr>
<tr>
<td align="center"><code>&lt;thead&gt;</code></td>
<td align="center">定义表格的页眉</td>
</tr>
<tr>
<td align="center"><code>&lt;tbody&gt;</code></td>
<td align="center">定义表格主体</td>
</tr>
<tr>
<td align="center"><code>&lt;tfoot&gt;</code></td>
<td align="center">定义表格页脚</td>
</tr>
<tr>
<td align="center"><code>&lt;col&gt;</code></td>
<td align="center">用于表格列的属性</td>
</tr>
<tr>
<td align="center"><code>&lt;colgroup&gt;</code></td>
<td align="center">定义表格列的组</td>
</tr>
</tbody></table>
<h3><span id="table标签">table标签</span></h3><ul>
<li>属性</li>
</ul>
<p>align，可以设置值，规定表格相对周围元素的对齐方式。值包括“left”，“right”，“center”。不赞成使用，用样式代替。</p>
<p>bgcolor，可以设置rgb值或十六进制颜色或颜色名，规定表格的背景颜色。不赞成使用，用样式代替。</p>
<p>border，可以设置像素值，规定表格边框的宽度。</p>
<p>cellpadding，可以通过设置百分比或像素值，规定单元边沿与其内容之间的空白。</p>
<p>cellspacing，可以通过设置百分比或像素值，规定单元格之间的空白。</p>
<p>frame，可以通过设置值，规定外侧边框的哪个部分时可见的。值包括“void”，“above”，“below”，“hsides”，“lhs”，“rhs”，“vsides”，“box”，“border”。</p>
<p>rules，可以通过设置值，规定内侧边框的哪个部分时可见的。值包括“none”，“groups”，“rows”，“cols”，“all”。</p>
<p>summary，可以通过设置文本，规定表格的摘要。</p>
<p>width，可以通过设置百分比或像素值，规定表格的宽度。</p>
<h3><span id="caption标签">caption标签</span></h3><ul>
<li><p>caption 元素定义表格标题。caption 标签必须紧随 table 标签之后。您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。</p>
</li>
<li><p>属性</p>
</li>
</ul>
<p>其属性有align，可以设置值，规定标题的对齐方式。值包括“left”，“right”，“top”，“bottom”。不赞成使用，用样式代替。</p>
<h3><span id="th标签与td标签">th标签与td标签</span></h3><ul>
<li>定义表格内的表头单元格。</li>
<li>HTML 表单中有两种类型的单元格：<br>表头单元格 - 包含表头信息（由 th 元素创建）<br>标准单元格 - 包含数据（由 td 元素创建）</li>
<li>th 元素内部的文本通常会呈现为居中的粗体文本，而 td 元素内的文本通常是左对齐的普通文本。如果需要将内容横跨多个行或列，请使用 colspan 和 rowspan 属性。</li>
<li>属性</li>
</ul>
<p>abbr，可以通过设置文本，规定单元格中内容的缩写版本。</p>
<p>align，可以通过设置值，规定单元格内容的水平对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。</p>
<p>axis，可以设置分类名字，对单元格进行分类。</p>
<p>bgcolor，可以设置rgb值或十六进制颜色或颜色名，规定表格的背景颜色。不赞成使用，用样式代替。</p>
<p>char，可以设置字符，规定根据哪个字符进行内容的对齐。</p>
<p>charoff，可以设置数字，规定对齐字符的偏移量。</p>
<p>colspan，可以设置数字，规定单元格可跨越的列数。</p>
<p>headers，可以设置属性类型，由空格分隔的表头单元格ID列标，为数据单元格提供表头信息。</p>
<p>nowrap，可以设置值，规定单元格中是否折行。不推荐使用，用样式代替。</p>
<p>rowspan，可以设置数字，规定单元格可横跨的行数。</p>
<p>scope，可以设置值，定义将表头数据与单元数据相关联的方法。值包括“col”，“clogroup”，“row”，“rowgroup”。</p>
<p>valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。</p>
<p>width，可以设置百分比或像素值，规定表格单元格的宽度。不推荐使用，用样式代替。</p>
<p>height，可以设置百分比或像素值，规定表格单元格的高度。不推荐使用，用样式代替。</p>
<h3><span id="tr标签">tr标签</span></h3><ul>
<li>属性</li>
</ul>
<p>align，可以通过设置值，规定表格行内容对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。</p>
<p>bgcolor，可以设置rgb值或十六进制颜色或颜色名，规定表格的背景颜色。不赞成使用，用样式代替。</p>
<p>char，可以设置字符，规定根据哪个字符进行内容的对齐。</p>
<p>charoff，可以设置数字，规定对齐字符的偏移量。</p>
<p>valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。</p>
<h3><span id="thead标签-tbody标签和tfoot标签">thead标签、tbody标签和tfoot标签</span></h3><ul>
<li><code>&lt;thead&gt;</code>标签定义表格的表头。thead 元素应该与 tbody 和 tfoot 元素结合起来使用。</li>
<li>tbody 元素用于对 HTML 表格中的主体内容进行分组，而 tfoot 元素用于对 HTML 表格中的表注（页脚）内容进行分组。</li>
<li>如果使用 thead、tfoot 以及 tbody 元素，就必须使用全部的元素。它们的出现次序是：thead、tfoot、tbody。必须在 table 元素内部使用这些标签。</li>
<li>属性</li>
</ul>
<p>align，可以通过设置值，规定元素中内容对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。</p>
<p>char，可以设置字符，规定根据哪个字符进行内容的对齐。</p>
<p>charoff，可以设置数字，规定对齐字符的偏移量。</p>
<p>valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。</p>
<h3><span id="col标签">col标签</span></h3><ul>
<li><code>&lt;col&gt;</code>标签为表格中一个或多个列定义属性值。</li>
<li>如需对全部列应用样式，<code>&lt;col&gt;</code>标签很有用，这样就不需要对各个单元和各行重复应用样式了。</li>
<li>只能在 table 或 colgroup 元素中使用<code>&lt;col&gt;</code>标签。</li>
<li>无结束标签。</li>
<li>为<code>&lt;col&gt;</code>标签添加 class 属性。这样就可以使用 CSS 来负责对齐方式、宽度和颜色等等。</li>
<li>属性</li>
</ul>
<p>align，可以通过设置值，规定与col元素相关的内容的水平对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。</p>
<p>char，可以设置字符，规定根据哪个字符进行内容的对齐。</p>
<p>charoff，可以设置数字，规定对齐字符的偏移量。</p>
<p>span，可以设置数字，规定col元素应该跨越的列数。</p>
<p>valign，可以设置值，规定单元格内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。</p>
<p>width，可以设置百分比或像素值或相关长度，规定col元素的宽度。</p>
<h3><span id="colgroup标签">colgroup标签</span></h3><ul>
<li><code>&lt;colgroup&gt;</code>标签用于对表格中的列进行组合，以便对其进行格式化。</li>
<li>如需对全部列应用样式，<code>&lt;colgroup&gt;</code>标签很有用，这样就不需要对各个单元和各行重复应用样式了。</li>
<li><code>&lt;colgroup&gt;</code>标签只能在 table 元素中使用。</li>
<li>属性</li>
</ul>
<p>align，可以通过设置值，定义在列组合中内容的水平对齐方式。值包括“left”，“right”，“center”，“justify”，“char”。</p>
<p>char，可以设置字符，规定根据哪个字符进行内容的对齐。</p>
<p>charoff，可以设置数字，规定对齐字符的偏移量。</p>
<p>span，可以设置数字，规定列组应该跨越的列数。</p>
<p>valign，可以设置值，定义在列组合中内容的垂直排列方式。值包括“top”，“middle”，“bottom”，“baseline”。</p>
<p>width，可以设置百分比或像素值或相关长度，规定列组合的宽度。</p>
<h2><span id="html列表元素">HTML列表元素</span></h2><h3><span id="无序列表">无序列表</span></h3><ul>
<li>无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。</li>
<li>无序列表始于<code>&lt;ul&gt;</code>标签（unordered_list）。每个列表项始于<code>&lt;li&gt;</code>标签（list）。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。</li>
</ul>
<h3><span id="有序列表">有序列表</span></h3><ul>
<li>有序列表始于<code>&lt;ol&gt;</code>标签（ordered_list）。每个列表项始于<code>&lt;li&gt;</code>标签（list）。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。</li>
</ul>
<h3><span id="定义列表">定义列表</span></h3><ul>
<li>自定义列表不仅仅是一列项目，而是项目及其注释的组合。</li>
<li>自定义列表以<code>&lt;dl&gt;</code>标签开始。每个自定义列表项以<code>&lt;dt&gt;</code>开始。每个自定义列表项的定义以<code>&lt;dd&gt;</code>开始。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>White cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="列表标签">列表标签</span></h3><h4><span id="ol标签">ol标签</span></h4><ul>
<li>定义有序列表。</li>
<li>属性</li>
</ul>
<p>compact，不赞成使用。</p>
<p>reversed，设置列表顺序为降序。</p>
<p>start，可以设置数字，规定有序列表的起始值。</p>
<p>type，可以设置值，规定在列表中使用的标记类型。值包括“1”，“A”，“a”，“I”，“i”。</p>
<h4><span id="ul标签">ul标签</span></h4><ul>
<li>定义无序列表。</li>
<li>属性</li>
</ul>
<p>compact，不赞成使用。</p>
<p>type，可以设置值，规定在列表中使用的标记类型。值包括“disc”，“square”，“circle”。</p>
<h4><span id="li标签">li标签</span></h4><ul>
<li>定义列表项目。</li>
<li>用于<code>&lt;ol&gt;</code>标签或<code>&lt;ul&gt;</code>标签中。</li>
<li>属性</li>
</ul>
<p>type，不赞成使用，值如上5+3，共8种。</p>
<p>value，不赞成使用，规定项目的数字。</p>
<h4><span id="dl标签-dt标签和dd标签">dl标签、dt标签和dd标签</span></h4><ul>
<li><code>&lt;dl&gt;</code>标签定义定义列表。</li>
<li><code>&lt;dt&gt;</code>标签定义定义项目。</li>
<li><code>&lt;dd&gt;</code>标签定义定义描述。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>一个定义列表：<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>计算机<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>用来计算的仪器 ... ...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>显示器<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>以视觉方式显示信息的装置 ... ...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4><span id="dir标签和menu标签">dir标签和menu标签</span></h4><ul>
<li>已废弃，使用<code>&lt;ul&gt;</code>标签代替。</li>
</ul>
<h2><span id="html块">HTML块</span></h2><ul>
<li>大多数 HTML 元素被定义为块级元素（block level element）或内联元素（inline element）。</li>
<li>块级元素在浏览器显示时，通常会以新行来开始（和结束）而内联元素在显示时通常不会以新行开始。</li>
</ul>
<h3><span id="div元素">div元素</span></h3><ul>
<li><code>&lt;div&gt;</code>用于定义文档中的分区或节（division&#x2F;section）。</li>
<li>HTML<code>&lt;div&gt;</code>元素是块级元素，它是可用于组合其他 HTML 元素的容器。浏览器通常会在 div 元素前后放置一个换行符。</li>
<li><code>&lt;div&gt;</code>元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。如果与 CSS 一同使用，<code>&lt;div&gt;</code>元素可用于对大的内容块设置样式属性。</li>
<li><code>&lt;div&gt;</code>元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用<code>&lt;div&gt;</code>元素来组合块级元素，这样就可以使用样式对它们进行格式化。如：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用div分块，并用class标识和更改颜色为蓝色--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color:blue&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>xxxxxx<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>align属性，可以设置值，规定div元素中的内容的对齐方式。不赞成使用，用样式取代。<br>值包括“left”、“right”、“center”、“justify”。</p>
<h3><span id="span元素">span元素</span></h3></li>
<li><p><code>&lt;span&gt;</code>用于组合文档中的行内元素。</p>
</li>
<li><p>HTML<code>&lt;span&gt;</code>元素是内联元素，可用作文本的容器。</p>
</li>
<li><p><code>&lt;span&gt;</code>元素也没有特定的含义。当与 CSS 一同使用时，<code>&lt;span&gt;</code>元素可用于为部分文本设置样式属性。如：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在html中标识class，并使用span组合--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;tip&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>强调：<span class="tag">&lt;/<span class="name">span</span>&gt;</span>... ... ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在CSS文件中统一设置span的格式*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.tip</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#ff9955</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>&lt;span&gt;</code>来组合行内元素，以便通过样式来格式化它们。</li>
</ul>
<h2><span id="html类标签">HTML类标签</span></h2><ul>
<li>使用class标识分类，进行内容格式化。如：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--CSS样式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.cities</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>:black;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>:white;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125; </span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">span</span><span class="selector-class">.place</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>:blue;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>:white;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;    </span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--使用class名整体格式化--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cities&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  London is the capital city of England. </span><br><span class="line">  It is the most populous city in the United Kingdom, </span><br><span class="line">  with a metropolitan area of over 13 million inhabitants.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>A <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;place&quot;</span>&gt;</span>place<span class="tag">&lt;/<span class="name">span</span>&gt;</span>in London<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="html内联框架">HTML内联框架</span></h2><ul>
<li><p>iframe可以在网页内显示网页。</p>
</li>
<li><p>语法：<code>&lt;iframe src=&quot;URL&quot;&gt;&lt;iframe&gt;</code></p>
</li>
<li><p>属性</p>
</li>
</ul>
<p>align，可以设置值，规定如何根据周围的元素对齐此框架。不赞成使用，值包括“left”，“right”，“top”，“middle”，“bottom”。</p>
<p>frameborder，可以设置0或1，规定是否显示框架周围的边框。</p>
<p>height，可以设置百分比或像素值，规定iframe的高度。</p>
<p>width，可以设置百分比或像素值，规定iframe的宽度。</p>
<p>longdesc，可以设置URL，规定一个页面，该页面包含了有关iframe的描述。</p>
<p>marginheight，可以设置像素值，定义iframe的顶部和底部的边距。</p>
<p>marginwidth，可以设置像素值，定义iframe的左边和右边的边距。</p>
<p>name，可以设置文本，规定iframe的名称。</p>
<p>referrerpolicy，可以设置值，规定iframe的引荐信息。值包括“no-referrer”，“no-referrer-when-downgrade”，“origin”，“origin-when-cross-origin”，“same-origin”，“strict-origin-when-cross-origin”，“unsafe-url”。</p>
<p>sandbox，可以设置值，启用一系列对<code>&lt;iframe&gt;</code>中内容的额外限制。值包括“”，“allow-forms”，“allow-same-origin”，“allow-scripts”，“allow-top-navigation”。</p>
<p>scrolling，可以设置值，规定是否在iframe中显示滚动条。值包括“yes”，“no”，“auto”。</p>
<p>seamless，规定<code>&lt;iframe&gt;</code>看上去像是包含文档的一部分。</p>
<p>src，可以设置URL，规定iframe中显示的文档的URL。</p>
<p>srcdoc，可以设置HTML代码，规定在<code>&lt;iframe&gt;</code>中显示的页面的HTML内容。</p>
<h2><span id="html布局类标签">HTML布局类标签</span></h2><h3><span id="html5语义元素">HTML5语义元素</span></h3><ul>
<li><code>&lt;header&gt;</code></li>
</ul>
<p>定义文档或节的页眉。应该被用作介绍性内容的容器。</p>
<ul>
<li><code>&lt;main&gt;</code></li>
</ul>
<p>规定文档的主内容。</p>
<ul>
<li><code>&lt;mark&gt;</code></li>
</ul>
<p>定义重要或强调的文本。</p>
<ul>
<li><code>&lt;time&gt;</code></li>
</ul>
<p>定义日期&#x2F;时间。</p>
<ul>
<li><code>&lt;nav&gt;</code></li>
</ul>
<p>定义导航链接的容器。</p>
<ul>
<li><code>&lt;section&gt;</code></li>
</ul>
<p>定义文档中的节。</p>
<ul>
<li><code>&lt;article&gt;</code></li>
</ul>
<p>定义独立的自包含文章。应用场景：论坛、博客、新闻……</p>
<ul>
<li><code>&lt;aside&gt;</code></li>
</ul>
<p>定义内容之外的内容，如侧栏。aside内容应该与周围内容相关。</p>
<ul>
<li><code>&lt;footer&gt;</code></li>
</ul>
<p>定义文档或节的页脚。页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。</p>
<ul>
<li><code>&lt;details&gt;</code></li>
</ul>
<p>定义额外的细节。</p>
<ul>
<li><code>&lt;figure&gt;</code></li>
</ul>
<p>规定自包含内容，比如图示、图表、照片、代码清单等。通过 HTML5，图片和标题能够被组合在<code>&lt;figure&gt;</code>元素中。</p>
<ul>
<li><code>&lt;figcaption&gt;</code></li>
</ul>
<p>定义<code>&lt;figure&gt;</code>元素的标题。</p>
<ul>
<li><code>&lt;summary&gt;</code></li>
</ul>
<p>定义details元素的标题。</p>
<h3><span id="框架">框架</span></h3><ul>
<li><p>通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。</p>
</li>
<li><p>但使用框架开发人员必须同时跟踪更多的HTML文档，并且很难打印整张页面。</p>
</li>
</ul>
<h4><span id="标签">标签</span></h4><ul>
<li><code>&lt;frameset&gt;</code>，定义如何将窗口分割为框架。每个 frameset 定义了一系列行或列，rows&#x2F;columns 的值规定了每行或每列占据屏幕的面积。</li>
<li><code>&lt;frame&gt;</code>，定义了放置在每个框架中的 HTML 文档。</li>
<li>为不支持框架的浏览器添加<code>&lt;noframes&gt;</code>标签。</li>
<li>假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在<code>&lt;frame&gt;</code>标签中加入：noresize&#x3D;”noresize”。为不支持框架的浏览器添加<code>&lt;noframes&gt;</code>标签。不能将<code>&lt;body&gt;&lt;/body&gt;</code>标签与<code>&lt;frameset&gt;&lt;/frameset&gt;</code>标签同时使用！不过，假如你添加包含一段文本的<code>&lt;noframes&gt;</code>标签，就必须将这段文字嵌套于<code>&lt;body&gt;&lt;/body&gt;</code>标签内。如</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">&quot;25%,50%,25%&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;/xxx/frame_a.html&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;/xxx/frame_b.html&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;/xxx/frame_c.html&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">noframes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>您的浏览器无法处理框架！<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noframes</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2><span id="html表单">HTML表单</span></h2><ul>
<li>HTML表单用于搜集不同类型的用户输入。</li>
<li><code>&lt;form&gt;</code>元素定义HTML表单。</li>
<li>表单元素是指不同类型的input元素、复选框、单选按钮、提交按钮等等。</li>
</ul>
<h3><span id="form元素属性">form元素属性</span></h3><h4><span id="action属性">action属性</span></h4><ul>
<li><p>action 属性定义提交表单时要执行的操作。通常，当用户单击“提交”按钮时，表单数据将发送到服务器上的文件中。</p>
</li>
<li><p>值为URL。</p>
</li>
<li><p>如果省略 action 属性，则将 action 设置为当前页面。</p>
<h4><span id="target属性">target属性</span></h4></li>
<li><p>target 属性规定提交表单后在何处显示响应。</p>
</li>
<li><p>值包括“_blank”（新窗口），“_self”（当前窗口），“_parent”（父框架），“_top”（窗口的body中），框架名。默认为“_self”。</p>
<h4><span id="method属性">method属性</span></h4></li>
<li><p>属性规定在提交表单时所用的 HTTP 方法（GET 或 POST）。</p>
</li>
<li><p>表单数据可以作为 URL 变量（使用 method&#x3D;”get”）或作为 HTTP post 事务（使用 method&#x3D;”post”）发送。提交表单数据时，默认的 HTTP 方法是 GET。</p>
</li>
<li><p>如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息。当您使用 GET 时，表单数据在页面地址栏中是可见的。GET 最适合少量数据的提交。浏览器会设定容量限制。</p>
</li>
<li><p>如果表单正在更新数据，或者包含敏感信息（例如密码）。POST 的安全性更好，因为在页面地址栏中被提交的数据是不可见的。</p>
<h5><span id="注意事项">注意事项</span></h5></li>
<li><p>GET<br>以名称&#x2F;值对的形式将表单数据追加到 URL。<br>永远不要使用 GET 发送敏感数据！（提交的表单数据在 URL 中可见！）。<br>URL 的长度受到限制（2048 个字符）。<br>对于用户希望将结果添加为书签的表单提交很有用。<br>GET 适用于非安全数据，例如 Google 中的查询字符串。</p>
</li>
<li><p>POST<br>将表单数据附加在 HTTP 请求的正文中（不在 URL 中显示提交的表单数据）。<br>POST 没有大小限制，可用于发送大量数据。<br>带有 POST 的表单提交无法添加书签。</p>
</li>
<li><p>如果表单数据包含敏感信息或个人信息，请务必使用 POST！</p>
<h4><span id="autocomplete属性">autocomplete属性</span></h4></li>
<li><p>autocomplete 属性规定表单是否应打开自动完成功能。</p>
</li>
<li><p>启用自动完成功能后，浏览器会根据用户之前输入的值自动填写值。</p>
</li>
<li><p>值为on或off。</p>
<h4><span id="novalidate属性">novalidate属性</span></h4></li>
<li><p>novalidate 属性是一个布尔属性。它规定提交时不应验证表单数据。</p>
</li>
<li><p>值为自身。</p>
<h4><span id="accept-charset属性">accept-charset属性</span></h4></li>
<li><p>accept-charset 属性规定服务器用哪种字符集处理表单数据。</p>
</li>
<li><p>常用值有：UTF-8 - Unicode 字符编码，ISO-8859-1 - 拉丁字母表的字符编码，gb2312 - 简体中文字符集。</p>
<h4><span id="enctype属性">enctype属性</span></h4></li>
<li><p>enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。</p>
</li>
<li><p>表单数据会默认编码为 “application&#x2F;x-www-form-urlencoded”。就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为 ASCII HEX 值）。</p>
</li>
<li><p>值包括“application&#x2F;x-www-form-urlencoded”（编码所有），“multipart&#x2F;form-data”（不对字符编码），“text&#x2F;plain”（部分编码）。</p>
<h4><span id="name属性">name属性</span></h4></li>
<li><p>name属性规定表单名称，提供了一种在脚本中引用表单的方法。</p>
</li>
<li><p>如果要正确地被提交，每个输入字段必须设置一个 name 属性。</p>
</li>
<li><p>值为自定义名称。</p>
<h4><span id="rel属性">rel属性</span></h4></li>
<li><p>rel 属性规定当前文档和被链接文档之间的关系。</p>
</li>
<li><p>值包括“external”（规定引用的文档不是当前站点的一部分），“help”（链接到帮助文档），“license”（链接到文档的版权信息），“next”（集合中的下一个文档），“nofollow”    （链接到未经认可的文档，例如付费链接）（Google 使用 “nofollow” 来指定 Google 搜索蜘蛛不应跟踪该链接），“noopener”，     “noreferrer”（规定如果用户点击该超链接，则浏览器不应发送 HTTP 推荐标头），“opener”，     “prev”（集合中的上一个文档），“search”（链接到文档的搜索工具）。</p>
</li>
</ul>
<h3><span id="input元素输入类型">input元素输入类型</span></h3><h4><span id="文本输入">文本输入</span></h4><ul>
<li><p><code>&lt;input type=&quot;text&quot;&gt;</code>定义用于文本输入的单行输入字段。</p>
</li>
<li><p>表单本身并不可见。还要注意文本字段的默认宽度是 20 个字符。</p>
<h4><span id="密码输入">密码输入</span></h4></li>
<li><p><code>&lt;input type=&quot;password&quot;&gt;</code>定义密码字段。</p>
</li>
<li><p>password 字段中的字符会被做掩码处理（显示为星号或实心圆）。</p>
<h4><span id="单选按钮输入">单选按钮输入</span></h4></li>
<li><p><code>&lt;input type=&quot;radio&quot;&gt;</code>定义单选按钮。</p>
</li>
<li><p>通常单选应该有选项，如下是一个单选：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>/&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span> <span class="attr">checked</span>/&gt;</span>女</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4><span id="复选框输入">复选框输入</span></h4><ul>
<li><p><code>&lt;input type=&quot;checkbox&quot;&gt;</code>定义复选框。</p>
</li>
<li><p>复选框允许用户在有限数量的选项中选择零个或多个选项。</p>
<h4><span id="按钮输入">按钮输入</span></h4></li>
<li><p><code>&lt;input type=&quot;button&gt;</code>定义按钮。</p>
<h4><span id="提交按钮">提交按钮</span></h4></li>
<li><p><code>&lt;input type=&quot;submit&quot;&gt;</code>定义用于向表单处理程序提交表单的按钮。</p>
</li>
<li><p>表单处理程序通常是包含用来处理输入数据的脚本的服务器页面。有关处理表单输入的知识，参考ASP或PHP语言。</p>
</li>
<li><p>表单处理程序在表单的 action 属性中指定：</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--将表单数据提交到xxx.asp页面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;../xxx/xxx.asp&quot;</span>&gt;</span></span><br><span class="line">Name:<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>提交按钮中的value属性值是显示在按钮上的内容。</p>
<h4><span id="html5新增输入类型">HTML5新增输入类型</span></h4></li>
<li><p>color<br><code>&lt;input type=&quot;color&quot;&gt;</code>用于应该包含颜色的输入字段。根据浏览器支持，颜色选择器会出现输入字段中。</p>
</li>
<li><p>date<br><code>&lt;input type=&quot;date&quot;&gt;</code>用于应该包含日期的输入字段。根据浏览器支持，日期选择器会出现输入字段中。</p>
</li>
<li><p>datetime<br><code>&lt;input type=&quot;datetime&quot;&gt;</code>允许用户选择日期和时间（有时区）。根据浏览器支持，日期选择器会出现输入字段中。</p>
</li>
<li><p>datetime-local<br><code>&lt;input type=&quot;datetime-local&quot;&gt;</code>允许用户选择日期和时间（无时区）。根据浏览器支持，日期选择器会出现输入字段中。</p>
</li>
<li><p>email<br><code>&lt;input type=&quot;email&quot;&gt;</code>用于应该包含电子邮件地址的输入字段。根据浏览器支持，能够在被提交时自动对电子邮件地址进行验证。某些智能手机会识别 email 类型，并在键盘增加 “.com” 以匹配电子邮件输入。</p>
</li>
<li><p>month<br><code>&lt;input type=&quot;month&quot;&gt;</code>允许用户选择月份和年份。根据浏览器支持，日期选择器会出现输入字段中。</p>
</li>
<li><p>number<br><code>&lt;input type=&quot;number&quot;&gt;</code>用于应该包含数字值的输入字段。能够对数字做出限制。</p>
</li>
<li><p>range<br><code>&lt;input type=&quot;range&quot;&gt;</code>用于应该包含一定范围内的值的输入字段。根据浏览器支持，输入字段能够显示为滑块控件。</p>
</li>
<li><p>search<br><code>&lt;input type=&quot;search&quot;&gt;</code>用于搜索字段（搜索字段的表现类似常规文本字段）。</p>
</li>
<li><p>tel<br><code>&lt;input type=&quot;tel&quot;&gt;</code>用于应该包含电话号码的输入字段。目前只有 Safari 8 支持 tel 类型。</p>
</li>
<li><p>time<br><code>&lt;input type=&quot;time&quot;&gt;</code>允许用户选择时间（无时区）。根据浏览器支持，时间选择器会出现输入字段中。</p>
</li>
<li><p>url<br><code>&lt;input type=&quot;url&quot;&gt;</code>用于应该包含 URL 地址的输入字段。根据浏览器支持，在提交时能够自动验证 url 字段。某些智能手机识别 url 类型，并向键盘添加 “.com” 以匹配 url 输入。</p>
</li>
<li><p>week<br><code>&lt;input type=&quot;week&quot;&gt;</code>允许用户选择周和年。根据浏览器支持，日期选择器会出现输入字段中。</p>
</li>
<li><p>image<br><code>&lt;input type=&quot;image&quot;&gt;</code>获取点击图像时的x和y坐标。</p>
</li>
</ul>
<h3><span id="input元素属性">input元素属性</span></h3><ul>
<li>value，值为自定义字段，规定输入字段的初始值。</li>
<li>readonly，不需要值，规定输入字段只读不可修改。</li>
<li>disabled，不需要值，规定输入字段禁用，不可用不可点击不会被提交。</li>
<li>size，值为字符数，规定输入字段框的尺寸。</li>
<li>maxlength，值为数字，规定输入字段允许的最大长度。<br>如设置 maxlength 属性，则输入控件不会接受超过所允许数的字符。<br>该属性不会提供任何反馈。如果需要提醒用户，则必须编写 JavaScript 代码。<br>输入限制并非万无一失。JavaScript 提供了很多方法来增加非法输入。如需安全地限制输入，则接受者（服务器）必须同时对限制进行检查。</li>
<li>autocomplete，值为on或off，规定表单或输入字段是否应该自动完成。当自动完成开启，浏览器会基于用户之前的输入值自动填写值。<br>可以把表单的 autocomplete 设置为 on，同时把特定的输入字段设置为 off，反之亦然。<br>autocomplete 属性适用于<code>&lt;form&gt;</code>以及如下<code>&lt;input&gt;</code>类型：text、search、url、tel、email、password、datepickers、range 以及 color。</li>
<li>autofocus，布尔属性，如果设置，则规定当页面加载时，<code>&lt;input&gt;</code>元素应该自动获得焦点。</li>
<li>form，规定<code>&lt;input&gt;</code>元素所属的一个或多个表单。如需引用一个以上的表单，请使用空格分隔的表单 id 列表。<br>即表单外使用<code>&lt;input&gt;</code>标签。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;xxx.php&quot;</span> <span class="attr">id</span>=<span class="string">&quot;form1&quot;</span>&gt;</span></span><br><span class="line">   First name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> Last name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lname&quot;</span> <span class="attr">form</span>=<span class="string">&quot;form1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>formaction，规定当提交表单时处理该输入控件文件的URL。<br>formaction 属性覆盖<code>&lt;form&gt;</code>元素的 action 属性。<br>formaction 属性适用于<code>type=&quot;submit&quot;</code>以及<code>type=&quot;image&quot;</code>。</p>
</li>
<li><p>formenctype，规定表单数据提交服务器时编码规则。<br>formenctype 属性覆盖<code>&lt;form&gt;</code>元素的 enctype 属性。<br>formenctype 属性适用于<code>type=&quot;submit&quot;</code>以及<code>type=&quot;image&quot;</code>。</p>
</li>
<li><p>formmethod，定义用以向action URL发送表单数据的HTTP方法。<br>formmethod 属性覆盖<code>&lt;form&gt;</code>元素的 method 属性。<br>formmethod 属性适用于<code>type=&quot;submit&quot;</code>以及<code>type=&quot;image&quot;</code>。</p>
</li>
<li><p>formnovalidate，布尔属性，设置时，规定提交表单时不对<code>&lt;input&gt;</code>元素进行验证。<br>formnovalidate 属性覆盖<code>&lt;form&gt;</code>元素的 novalidate 属性。<br>formnovalidate 属性可用于<code>type=&quot;submit&quot;</code>。</p>
</li>
<li><p>formtarget，规定名称或关键词指示提交表单后何处显示接收到的响应。<br>formtarget 属性会覆盖<code>&lt;form&gt;</code>元素的 target 属性。<br>formtarget 属性可与<code>type=&quot;submit&quot;</code>和<code>type=&quot;image&quot;</code>使用。</p>
</li>
<li><p>height和width，规定<code>&lt;input&gt;</code>元素的高度和宽度。<br>height 和 width 属性仅用于<code>&lt;input type=&quot;image&quot;&gt;</code>。</p>
</li>
<li><p>list，引用的<code>&lt;datalist&gt;</code>元素中包含了<code>&lt;input&gt;</code>元素的预定义选项。</p>
</li>
<li><p>min和max，规定<code>&lt;input&gt;</code>元素的最小值和最大值。<br>min 和 max 属性适用于如需输入类型：number、range、date、datetime、datetime-local、month、time 以及 week。</p>
</li>
<li><p>multiple，布尔属性，设置时，规定允许用户在<code>&lt;input&gt;</code>元素中输入一个以上的值。<br>multiple 属性适用于以下输入类型：email 和 file。</p>
</li>
<li><p>pattern，规定用于检查<code>&lt;input&gt;</code>元素值的正则表达式。<br>pattern 属性适用于以下输入类型：text、search、url、tel、email、password。</p>
</li>
<li><p>placeholder，规定用以描述输入字段预期值的提示（样本值或有关格式的简短描述）。<br>该提示会在用户输入值之前显示在输入字段中。<br>placeholder 属性适用于以下输入类型：text、search、url、tel、email 以及 password。</p>
</li>
<li><p>required，布尔属性，设置时，规定在提交表单之前必须填写输入字段。<br>required 属性适用于以下输入类型：text、search、url、tel、email、password、date pickers、number、checkbox、radio、file。</p>
</li>
<li><p>step，规定<code>&lt;input&gt;</code>元素的合法数字间隔。<br>step 属性可与 max 以及 min 属性一同使用，来创建合法值的范围。<br>step 属性适用于以下输入类型：number、range、date、datetime、datetime-local、month、time 以及 week。</p>
<h3><span id="ltselectgt元素"><code>&lt;select&gt;</code>元素</span></h3></li>
<li><p>定义下拉列表</p>
</li>
<li><p><code>&lt;option&gt;</code>元素定义待选择的选项。列表通常会把首个选项显示为被选选项。通过添加 selected 属性来定义预定义选项。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;saab&quot;</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;fiat&quot;</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;audi&quot;</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3><span id="textarea元素">textarea元素</span></h3><ul>
<li>定义多行输入字段（文本域）。</li>
</ul>
<h3><span id="button元素">button元素</span></h3><ul>
<li>定义可点击的按钮。</li>
</ul>
<h2><span id="html媒体">HTML媒体</span></h2><ul>
<li>Web 上的多媒体指的是音效、音乐、视频和动画。</li>
<li>插件（Plug-in）是扩展浏览器标准功能的计算机程序。</li>
</ul>
<h3><span id="html对象">HTML对象</span></h3><h4><span id="object元素">object元素</span></h4><ul>
<li><p><code>&lt;object&gt;</code>元素定义 HTML 文档中的嵌入式对象。</p>
</li>
<li><p>它旨在将插件（例如 Java applet、PDF 阅读器和 Flash 播放器）嵌入网页中，但也可以用于将 HTML 包含在 HTML 中。</p>
<h4><span id="embed元素">embed元素</span></h4></li>
<li><p><code>&lt;embed&gt;</code>元素也可定义了 HTML 文档中的嵌入式对象，也可用于在 HTML 中包含 HTML。</p>
</li>
<li><p>Web 浏览器长期以来一直支持<code>&lt;embed&gt;</code>元素。但是，它不属于 HTML5 之前的 HTML 规范的一部分。</p>
</li>
<li><p><code>&lt;embed&gt;</code>元素没有结束标记。它无法包含替代文本。</p>
</li>
</ul>
<h3><span id="html音频">HTML音频</span></h3><ul>
<li>使用<code>&lt;embed&gt;</code>元素嵌入MP3文件。<br><code>&lt;embed&gt;</code>标签在 HTML 4 中是无效的。页面无法通过 HTML 4 验证。<br>不同的浏览器对音频格式的支持也不同。<br>如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。<br>如果用户的计算机未安装插件，无法播放音频。<br>如果把该文件转换为其他格式，仍然无法在所有浏览器中播放。</li>
<li>使用<code>&lt;object&gt;</code>元素嵌入MP3文件。<br>不同的浏览器对音频格式的支持也不同。<br>如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。<br>如果用户的计算机未安装插件，无法播放音频。<br>如果把该文件转换为其他格式，仍然无法在所有浏览器中播放。</li>
<li>使用HTML5<code>&lt;audio&gt;</code>元素播放音频。<br><code>&lt;audio&gt;</code>标签在 HTML 4 中是无效的。您的页面无法通过 HTML 4 验证。<br>必须把音频文件转换为不同的格式。<br><code>&lt;audio&gt;</code>元素在老式浏览器中不起作用。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;song.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mp3&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;song.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span> /&gt;</span></span><br><span class="line">Your browser does not support this audio format.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>最好的HTML解决方法是<code>&lt;audio&gt;</code>标签与<code>&lt;embed&gt;</code>标签混用。</p>
</li>
<li><p>使用JS和播放器播放音频。</p>
<h5><span id="audio标签属性">audio标签属性</span></h5></li>
<li><p>autoplay，设置该属性时，音频就绪后马上播放。</p>
</li>
<li><p>controls，设置该属性时，显示控件。</p>
</li>
<li><p>loop，出现该属性时，音频循环播放。</p>
</li>
<li><p>muted，出现该属性时，规定音频静音。</p>
</li>
<li><p>preload，出现该属性时，在页面加载时加载音频，预备播放。</p>
</li>
<li><p>src，值为URL，播放音频的URL。</p>
</li>
</ul>
<h3><span id="html视频">HTML视频</span></h3><ul>
<li><p>使用<code>&lt;embed&gt;</code>标签。<br>HTML4 无法识别<code>&lt;embed&gt;</code>标签。您的页面无法通过验证。<br>如果浏览器不支持 Flash，那么视频将无法播放<br>iPad 和 iPhone 不能显示 Flash 视频。<br>如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</p>
</li>
<li><p>使用<code>&lt;object&gt;</code>标签。<br>如果浏览器不支持 Flash，将无法播放视频。<br>iPad 和 iPhone 不能显示 Flash 视频。<br>如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</p>
</li>
<li><p>使用<code>&lt;video&gt;</code>标签。<br><code>&lt;video&gt; </code>，是 HTML 5 中的新标签，作用是在 HTML 页面中嵌入视频元素。<br>您必须把视频转换为很多不同的格式。<br><code>&lt;video&gt;</code>元素在老式浏览器中无效。<br><code>&lt;video&gt;</code>元素无法通过 HTML 4 和 XHTML 验证</p>
</li>
<li><p>最好的HTML解决方法：HTML5+<code>&lt;object&gt;</code>+<code>&lt;embed&gt;</code>。</p>
<h4><span id="video标签属性">video标签属性</span></h4></li>
<li><p>autoplay，设置该属性时，视频就绪后马上播放。</p>
</li>
<li><p>controls，设置该属性时，显示控件。</p>
</li>
<li><p>height，值为像素值，设置播放器高度。</p>
</li>
<li><p>width，值为像素值，设置播放器宽度。</p>
</li>
<li><p>loop，出现该属性时，视频循环播放。</p>
</li>
<li><p>muted，出现该属性时，规定视频静音。</p>
</li>
<li><p>poster，值为URL，规定视频下载时现实的图像，或播放按钮前显示的图像。</p>
</li>
<li><p>preload，出现该属性时，在页面加载时加载视频，预备播放。</p>
</li>
<li><p>src，值为URL，播放音频的URL。</p>
</li>
</ul>
<h2><span id="html5新增元素">HTML5新增元素</span></h2><ul>
<li><p><code>&lt;datalist&gt;</code><br><code>&lt;datalist&gt;</code>元素为<code>&lt;input&gt;</code>元素规定预定义选项列表。用户会在他们输入数据时看到预定义选项的下拉列表。<code>&lt;input&gt;</code>元素的 list 属性必须引用<code>&lt;datalist&gt;</code>元素的 id 属性</p>
</li>
<li><p><code>&lt;keygen&gt;</code></p>
</li>
<li><p><code>&lt;output&gt;</code></p>
<h3><span id="fieldset元素">fieldset元素</span></h3></li>
<li><p><code>&lt;fieldset&gt;</code>元素组合表单中的相关数据。</p>
</li>
<li><p><code>&lt;legend&gt;</code>元素为<code>&lt;fieldset&gt;</code>元素定义标题。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Personal information:<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    First name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    Last name:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1><span id="html-id属性">HTML id属性</span></h1><ul>
<li><p>HTML id 属性用于HTML 元素指定唯一的id。一个 HTML文档中不能存在多个有相同 id 的元素。</p>
</li>
<li><p>id 的语法是：写一个井号 (#)，后跟一个 id 名称。然后，在花括号 {} 中定义 CSS 属性。如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-id">#London</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: black;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;London&quot;</span>&gt;</span>My City<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>id对大小写敏感，且至少包含一个字符，不能为空白字符（空格、制表符等）。</p>
</li>
<li><p>id还可以用于实现书签。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--先用id创建书签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;C4&quot;</span>&gt;</span>第四章<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--接着使用链接元素跳转--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#C4&quot;</span>&gt;</span>跳转到第四章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者跳转到另一页的书签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;test.html#C4&quot;</span>&gt;</span>跳转到第四章<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>CSS和JS可以使用id属性选取元素或设置样式。 </li>
<li>Class 与 ID 的差异<br>同一个类名可以由多个 HTML 元素使用，而一个 id 名称只能由页面中的一个 HTML 元素使用。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言入门学习教程</title>
    <url>/%E7%AC%94%E8%AE%B0/c-language-learning/</url>
    <content><![CDATA[<p>个人认为面向入门基础级别的C语言学习教程。</p>
<p>关键词：C语言</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#i-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%8B%E7%BB%8D">Ⅰ —— 基础知识介绍</a><ul>
<li><a href="#11-c%E8%AF%AD%E8%A8%80%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86">1.1 C语言背景知识</a></li>
<li><a href="#12-%E7%94%A8%E4%BB%80%E4%B9%88%E5%86%99c%E8%AF%AD%E8%A8%80">1.2 用什么写C语言</a></li>
<li><a href="#13-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F">1.3 从代码到执行程序</a></li>
<li><a href="#14-%E8%AE%A4%E8%AF%86%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84c%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81">1.4 认识最基础的C语言代码</a></li>
<li><a href="#15-%E5%A4%B4%E6%96%87%E4%BB%B6">1.5 头文件</a></li>
<li><a href="#16-%E5%85%B3%E9%94%AE%E5%AD%97">1.6 关键字</a></li>
</ul>
</li>
<li><a href="#ii-%E5%87%BD%E6%95%B0">Ⅱ —— 函数</a><ul>
<li><a href="#21-%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">2.1 函数的基本结构</a></li>
<li><a href="#22-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89">2.2 函数声明和定义</a></li>
<li><a href="#23-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">2.3 调用函数</a></li>
<li><a href="#24-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">2.4 函数参数传递</a></li>
</ul>
</li>
<li><a href="#iii-%E6%95%B0%E6%8D%AE-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E8%AF%AD%E5%8F%A5">Ⅲ —— 数据、运算符及语句</a><ul>
<li><a href="#31-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F">3.1 数据的表现形式</a></li>
<li><a href="#32-%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B">3.2 数据的类型</a><ul>
<li><a href="#321-%E6%95%B4%E5%9E%8B%E6%95%B0%E6%8D%AE">3.2.1 整型数据</a></li>
<li><a href="#322-%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE">3.2.2 浮点型数据</a></li>
<li><a href="#323-void%E7%B1%BB%E5%9E%8B">3.2.3 Void类型</a></li>
<li><a href="#324-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">3.2.4 类型转换</a></li>
</ul>
</li>
<li><a href="#33-%E8%BF%90%E7%AE%97%E7%AC%A6">3.3 运算符</a><ul>
<li><a href="#331-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">3.3.1 算术运算符</a></li>
<li><a href="#332-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">3.3.2 关系运算符</a></li>
<li><a href="#333-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">3.3.3 逻辑运算符</a></li>
<li><a href="#334-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">3.3.4 位运算符</a></li>
<li><a href="#335-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">3.3.5 赋值运算符</a></li>
<li><a href="#336-%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6">3.3.6 其他运算符</a></li>
<li><a href="#337-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7">3.3.7 运算符优先级</a></li>
</ul>
</li>
<li><a href="#34-%E8%AF%AD%E5%8F%A5">3.4 语句</a></li>
<li><a href="#35-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4">3.5 变量的作用范围</a></li>
</ul>
</li>
<li><a href="#iv-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">Ⅳ —— 格式化输入输出</a><ul>
<li><a href="#41-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E8%BE%93%E5%87%BA">4.1 格式化的输出</a></li>
<li><a href="#42-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E8%BE%93%E5%85%A5">4.2 格式化的输入</a></li>
</ul>
</li>
<li><a href="#v-%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84">Ⅴ —— 条件结构</a><ul>
<li><a href="#51-if%E6%9E%84%E6%88%90%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84">5.1 if构成的条件结构</a></li>
<li><a href="#52-switch%E6%9E%84%E6%88%90%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84">5.2 switch构成的条件结构</a></li>
</ul>
</li>
<li><a href="#vi-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">Ⅵ —— 循环结构</a><ul>
<li><a href="#61-while%E6%9E%84%E6%88%90%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">6.1 while构成的循环结构</a></li>
<li><a href="#62-do-while%E6%9E%84%E6%88%90%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">6.2 do-while构成的循环结构</a></li>
<li><a href="#63-for%E6%9E%84%E6%88%90%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84">6.3 for构成的循环结构</a></li>
<li><a href="#64-%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%BB%88%E6%AD%A2%E4%B8%8E%E7%BB%A7%E7%BB%AD">6.4 循环的终止与继续</a></li>
</ul>
</li>
<li><a href="#vii-%E6%9E%9A%E4%B8%BE">Ⅶ —— 枚举</a></li>
<li><a href="#viii-%E6%95%B0%E7%BB%84">Ⅷ —— 数组</a><ul>
<li><a href="#81-%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84">8.1 数组结构</a></li>
<li><a href="#82-%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%AE%BF%E9%97%AE">8.2 数组的定义和访问</a></li>
<li><a href="#83-%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">8.3 数组的初始化</a></li>
<li><a href="#84-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">8.4 多维数组</a></li>
<li><a href="#85-%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8">8.5 数组的使用</a></li>
</ul>
</li>
<li><a href="#ix-%E6%8C%87%E9%92%88">Ⅸ —— 指针</a><ul>
<li><a href="#91-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89">9.1 指针变量的定义</a></li>
<li><a href="#92-%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%90%E7%AE%97">9.2 指针的运算</a></li>
<li><a href="#93-%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8">9.3 指针的使用</a></li>
</ul>
</li>
<li><a href="#x-%E5%85%B1%E7%94%A8%E4%BD%93%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93">Ⅹ —— 共用体与结构体</a><ul>
<li><a href="#101-%E5%85%B1%E7%94%A8%E4%BD%93">10.1 共用体</a></li>
<li><a href="#102-%E7%BB%93%E6%9E%84%E4%BD%93">10.2 结构体</a></li>
</ul>
</li>
<li><a href="#xi-%E9%93%BE%E8%A1%A8">Ⅺ —— 链表</a><ul>
<li><a href="#111-%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E6%9E%84%E6%88%90">11.1 链表及其构成</a></li>
<li><a href="#112-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%BD%E6%95%B0">11.2 内存管理的函数</a></li>
<li><a href="#113-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">11.3 单向链表</a></li>
<li><a href="#114-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">11.4 双向链表</a></li>
<li><a href="#115-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8">11.5 循环链表</a></li>
</ul>
</li>
<li><a href="#xii-%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99">Ⅻ —— 对文件的读写</a><ul>
<li><a href="#121-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6">12.1 打开文件</a></li>
<li><a href="#122-%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6">12.2 写入文件</a></li>
<li><a href="#123-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6">12.3 读取文件</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="i-基础知识介绍">Ⅰ —— 基础知识介绍</span></h1><p>此教程会用一些注记符号，表示某种格式。</p>
<h2><span id="11-c语言背景知识">1.1 C语言背景知识</span></h2><p>C语言是一种通用的、面向过程式的计算机程序设计语言。1972 年，为了移植与开发 UNIX 操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了 C 语言。</p>
<p>C语言标准有C89、C99、C11、C17、C2x ……等，后面的数字是标准发布的年份。如果想了解每个标准有什么差异，自行必应搜索。本教程的完整代码在GNU C17下成功运行。</p>
<h2><span id="12-用什么写c语言">1.2 用什么写C语言</span></h2><p>编写C语言，就连基本的文本编辑器——记事本也可以完成。但我们并不会只想着使用那么奇奇怪怪的记事本，去编写十来行代码甚至上千行代码，至少是真的不习惯。</p>
<p>接触C语言，会有很多人推荐你用那个什么什么写啊，一点一动就行；但如果在大学学习，教师可能会让你使用Visual C++ 6.0（下简称VC 6.0）去写。</p>
<p>感受过VC 6.0软件界面的人都知道，很不舒服，甚至降低自己的效率。VC 6.0甚至比我的年龄还大，算是老古董了。但是目前教材用的是VC 6.0，实验室配置的是VC 6.0，乃至你的考试，甚至计算机二级，都是VC 6.0，所以用VC 6.0而不是别的软件，更加容易应付教学。</p>
<p>所以在此，我推荐使用的C语言编辑器是：</p>
<ul>
<li><p>基础小白或图方便可使用<a href="https://sourceforge.net/projects/dev-cpp-2020/">Dev-C++</a></p>
</li>
<li><p>非基础小白可使用Visual Studio或Visual Studio Code</p>
</li>
</ul>
<p>此教程的代码使用Dev-C++，均在Dev-C++下成功运行。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_devcpp.jpg" alt="Dev-C++界面"></p>
<p>按 <code>Ctrl</code> + <code>N</code> 可以新建文件，或者点击左上角文件新建文件。</p>
<p>在 工具 → 编译选项 → 代码生成&#x2F;优化 → 代码生成 处可以找到语言标准。 </p>
<h2><span id="13-从代码到执行程序">1.3 从代码到执行程序</span></h2><p>在上一节我提到了用什么写C语言，这是关于编辑器（Editor）的事情。字面意思，它只负责编辑，也就是敲上一个个的字母数字，就像写英语日记、写英语文章一样。</p>
<p>事实上，你在编辑器上写的内容，还不能完全算是程序，这个内容称为 <strong>源代码（Source Code）</strong> 。存放源代码的文件称为 <strong>源文件</strong> 。</p>
<p>我们还需要经过一些步骤，使得源代码变成 <strong>可执行文件（Executable file）</strong> ，也就是你计算机里面那些.exe文件。把这些步骤称之为 <strong>编译（Build）</strong> 和 <strong>链接（Link）</strong> 。</p>
<ul>
<li><p>编译：编译需要 <strong>编译器</strong> 完成。编译器把一个源代码翻译成可执行文件的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。常见的编译器有：MinGW、MSVC等。</p>
</li>
<li><p>链接：链接需要 <strong>链接器</strong> 完成。链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是在程序被加载器加载到内存并执行时；甚至执行于运行时，也就是由应用程序来执行。链接的意义在于我们不用将一个大型的应用程序组织成一个巨大的源文件，而是可以把它分解成为更小、更好管理的模块，可以独立的修改和编译这些模块。当我们改变这些模块中的一个时，只需要简单的重新编译它，并重新链接应用，而不必重新编译其他文件。</p>
</li>
</ul>
<p>这些只是一些知识补充，想详细了解可参阅编译原理。另外，如果你选择了Dev-C++或者Visual Studio这样的集成软件，编译器和链接器的配置会相对简单。</p>
<h2><span id="14-认识最基础的c语言代码">1.4 认识最基础的C语言代码</span></h2><p>学习C语言的开始，从输出一个“Hello World！”开始，这似乎是所有编程语言一开始都经历的事情。</p>
<p>我在此直接给出完整代码，心急的可以复制到Dev-C++运行试试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hello World.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在来逐行认识基本的C语言代码结构。</p>
<ul>
<li><p><code>//</code> 表示当前整行被编译器忽略，又称注释，供程序员理解语句。</p>
</li>
<li><p><code>#include&lt;stdio.h&gt;</code>中的 <code>#</code>（井号）表示预处理命令，即在程序编译前进行提前处理的部分。若是头文件，可用 <code>&lt;&gt;</code>（单书名号）括起来，也可用 <code>&quot; &quot;</code>（引号）包含起来。 <strong>其中由 <code>&lt;&gt;</code> 括起来的头文件表示在系统头文件的文件夹中查找，由 <code>&quot;&quot;</code> 括起来的头文件表示在源文件当前文件夹查找。</strong></p>
</li>
<li><p><code>int main()</code> 是一个函数的开头，再加以 <code>&#123;&#125;</code>（大括号）包含主函数内容。此处是主函数，主函数是一个程序最重要的函数，程序从此开始编译。</p>
</li>
<li><p><code>printf(&quot;Hello World!&quot;);</code> 为程序工作语句，其作用是输出“Hello World！”。</p>
</li>
<li><p>C语言中以 <code>;</code>（分号）作为一条语句的结束标志。</p>
</li>
<li><p><code>return 0;</code>是函数的结构之一，在函数一节介绍。</p>
</li>
</ul>
<p>一般情况下， <strong>一个C语言程序包含预处理器指令、函数、变量、语句（表达式和注释）等</strong> 。函数是一个进行某种功能操作的模块，目前认识到的是主函数，还可以自定义函数。变量即程序运行时其值可以改变的量，变量的功能就是存储数据。</p>
<p>C语言代码按 <strong>顺序结构</strong> ，由上到下顺序执行代码。</p>
<p>还有一件比较重要的事情，养成良好的代码风格，即令人舒适的缩进、空格位置等；千万不要所有代码都挤到一块或者全都左对齐。</p>
<h2><span id="15-头文件">1.5 头文件</span></h2><p>在上一节提到了预处理命令包含的头文件，那么头文件是什么？</p>
<p>头文件是扩展名为.h的文件，包含了C语言一些函数甚至几乎所有函数的提前 <strong>声明（Statement）</strong> 和 <strong>定义（Definition）</strong> ，没有这些声明和定义，编译器不会认识这些函数，故而不能运行。</p>
<p>有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p>
<p>在程序中要使用头文件，需要使用预处理指令 #include 来引用它，引用头文件相当于复制头文件的内容。如stdio.h头文件，它包含了<code>printf()</code>这一函数。</p>
<h2><span id="16-关键字">1.6 关键字</span></h2><p>C语言的关键字是C语言的基本构成要素，共有32个，根据关键字的作用，可分其为数据类型关键字、控制语句关键字、存储类型关键字和其它关键字四类。       </p>
<p><strong>1 数据类型关键字（12个）：</strong><br>(1)  <code>char</code> ：声明字符型变量或函数<br>(2) <code>double</code> ：声明双精度变量或函数<br>(3) <code>enum</code> ：声明枚举类型<br>(4) <code>float</code> ：声明浮点型变量或函数<br>(5) <code>int</code> ：声明整型变量或函数<br>(6) <code>long</code> ：声明长整型变量或函数<br>(7) <code>short</code> ：声明短整型变量或函数<br>(8) <code>signed</code> ：声明有符号类型变量或函数<br>(9) <code>struct</code> ：声明结构体变量或函数<br>(10) <code>union</code> ：声明共用体（联合）数据类型<br>(11) <code>unsigned</code> ：声明无符号类型变量或函数<br>(12) <code>void</code> ：声明函数无返回值或无参数，声明无类型指针</p>
<p><strong>2 控制语句关键字（12个）：</strong><br>A循环语句<br>(1) <code>for</code> ：一种循环语句(可意会不可言传）<br>(2) <code>do</code> ：循环语句的循环体<br>(3) <code>while</code> ：循环语句的循环条件<br>(4) <code>break</code> ：跳出当前循环<br>(5) <code>continue</code> ：结束当前循环，开始下一轮循环<br>B条件语句<br>(1) <code>if</code> : 条件语句<br>(2) <code>else</code> ：条件语句否定分支（与 if 连用）<br>(3) <code>goto</code> ：无条件跳转语句<br>C开关语句<br>(1) <code>switch</code> :用于开关语句<br>(2) <code>case</code>：开关语句分支<br>(3) <code>default</code>：开关语句中的“其他”分支<br>D返回语句<br><code>return</code> ：函数返回语句（可以带参数，也可不带参数）</p>
<p><strong>3 存储类型关键字（4个）</strong><br>(1) <code>auto</code> ：声明自动变量 一般不使用<br>(2) <code>extern</code> ：声明变量是在其他文件正声明（也可以看做是引用变量）<br>(3) <code>register</code>：声明积存器变量<br>(4) <code>static</code> ：声明静态变量</p>
<p><strong>4 其它关键字（4个）：</strong><br>(1) <code>const</code> ：声明只读变量<br>(2) <code>sizeof</code> ：计算数据类型长度<br>(3) <code>typedef</code> ：用以给数据类型取别名<br>(4) <code>volatile</code> ：说明变量在程序执行中可被隐含地改变</p>
<p>你可能不明白这些关键字什么意思怎么用，但你只需要知道这些关键字不能随便用，它们被C语言内部定义占用了。</p>
<p><br><br><br></p>
<h1><span id="ii-函数">Ⅱ —— 函数</span></h1><p>函数是用来完成特定任务的一组语句。在C语言中，每个程序至少有一个主函数 <code>main()</code> 。此外，C语言还提供了许多内置函数，可以在相应的头文件中找到。有时候，我们也可以称函数为方法。</p>
<p>当我们编写代码时，我们可以将其分割成不同的函数。划分代码到不同的函数中是我们自己决定的。但是从逻辑上来说，我们通常会根据每个函数执行特定的任务来进行划分。例如，如果我们正在编写一个计算器程序，我们可以使用四个函数分别处理加法、减法、乘法和除法。这样的划分可以让代码更有组织性，并且更易于理解和维护。</p>
<h2><span id="21-函数的基本结构">2.1 函数的基本结构</span></h2><p>函数的结构应当如下，包括 <strong>函数返回类型return_type</strong> ， <strong>函数名字function_name</strong> 、 <strong>参数arguments</strong> 和 <strong>函数主体Body</strong> 等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">(arguments)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>函数返回类型</strong>：一个函数可以返回一个值，return_type是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <code>void</code> 。</p>
</li>
<li><p><strong>函数名字</strong>：这是函数的实际名称。函数名和参数列表一起构成了 <strong>函数签名（Function signature）</strong> 。</p>
</li>
<li><p><strong>参数列表</strong>：当函数被调用时，可以向参数传递值。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</p>
</li>
<li><p><strong>函数主体</strong>：函数主体包含一组定义函数执行任务的语句。若有返回值的函数使用 <code>return</code> 返回。函数主体中遇到返回表示结束函数。</p>
</li>
</ul>
<h2><span id="22-函数声明和定义">2.2 函数声明和定义</span></h2><p>函数的产生有两个概念： <strong>函数声明（Function Statement）</strong> 和 <strong>函数定义（Function Definition）</strong> 。函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 <strong>使用函数之前必须先声明（也可以直接声明并定义）。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明并定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数声明中的参数列表可以不具体写变量名，但函数定义中的参数列表必须写变量名。如上述代码的声明可以写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="23-调用函数">2.3 调用函数</span></h2><p>当我们写完我们的函数，使用时直接称呼 <strong>函数签名</strong>（函数名字+参数列表）即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明并定义函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">add(c, d);</span><br></pre></td></tr></table></figure>

<h2><span id="24-函数参数传递">2.4 函数参数传递</span></h2><p>如果函数要使用参数，接受参数值的变量称为函数的 <strong>形式参数</strong> 。如上面 <code>int add(int a, int b)</code> 中的 <code>a</code> 和 <code>b</code>。</p>
<p>如果调用函数时，传递进入的参数称为 <strong>实际参数</strong>。如上面 <code>add(1, 2)</code>中的 <code>c</code> 和 <code>d</code> 。</p>
<p>参数传递有两种方式： <strong>值传递</strong> 和 <strong>地址传递</strong> 。</p>
<ul>
<li><p><strong>值传递</strong>：把参数的数值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</p>
</li>
<li><p><strong>地址（引用）传递</strong>：把参数的地址复制给函数的形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 <em>对于地址传递，经过指针的学习可能更清晰。</em></p>
</li>
</ul>
<p><br><br><br></p>
<h1><span id="iii-数据-运算符及语句">Ⅲ —— 数据、运算符及语句</span></h1><h2><span id="31-数据的表现形式">3.1 数据的表现形式</span></h2><p>数据以常量、变量、常变量或标识符的形式出现。</p>
<p>变量、常变量的出现包括 <strong>声明</strong> 、 <strong>定义</strong> 、 <strong>初始化</strong> 三个步骤。 <strong>为变量分配地址和存储空间的称为定义，不分配地址的称为声明。</strong> </p>
<p>变量定义：用于为变量分配存储空间，还可为变量指定初始值，程序中，变量有且仅有一个定义。</p>
<p>变量声明：用于向程序表明变量的类型和名字。</p>
<p>定义也是声明：当定义变量时我们声明了它的类型和名字。</p>
<p><strong>所有变量使用之前需要有声明或定义。</strong></p>
<ul>
<li><p><strong>常量</strong> ，其值不能改变的量。其分为 <strong>整型常量</strong> （即整数，如1，2，1000，666）、 <strong>实型常量</strong> 、 <strong>字符常量</strong> 。</p>
</li>
<li><p><strong>实型常量</strong> ，包括十进制小数形式（由数字和小数点组成）和指数形式，指数形式以E或e代表以10为底的指数，如1e6，注意：e或E之前必须有数字，且e或E之后必须为整数；</p>
</li>
<li><p><strong>字符常量之字符常量</strong> ，由 <code>‘’</code> （单引号）包括的一个字符，如 <code>‘a’</code> 、 <code>‘A’</code> 等。普通字符，详见ASCII字符集；转义字符，特殊形式的字符，以 <code>\</code> 开头。  <em>引号在此充当界限符，字符常量和字符串常量不包括引号。</em></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">转义字符</th>
<th align="center">字符值</th>
<th align="center">输出结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\&#39;</code></td>
<td align="center">一个单引号</td>
<td align="center"><code>&#39;</code></td>
</tr>
<tr>
<td align="center"><code>\&quot;</code></td>
<td align="center">一个双引号</td>
<td align="center"><code>&quot;</code></td>
</tr>
<tr>
<td align="center"><code>\?</code></td>
<td align="center">一个问号</td>
<td align="center"><code>?</code></td>
</tr>
<tr>
<td align="center"><code>\\</code></td>
<td align="center">一个反斜杠</td>
<td align="center"><code>\</code></td>
</tr>
<tr>
<td align="center"><code>\a</code></td>
<td align="center">警告alert</td>
<td align="center">产生声音或视觉信号</td>
</tr>
<tr>
<td align="center"><code>\b</code></td>
<td align="center">退格backspace</td>
<td align="center">将光标后退一个字符</td>
</tr>
<tr>
<td align="center"><code>\f</code></td>
<td align="center">换页form feed</td>
<td align="center">将光标移到下一页</td>
</tr>
<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行</td>
<td align="center">将光标移到下一行</td>
</tr>
<tr>
<td align="center"><code>\r</code></td>
<td align="center">回车carriage return</td>
<td align="center">将光标移到本行开头</td>
</tr>
<tr>
<td align="center"><code>\t</code></td>
<td align="center">水平制表符</td>
<td align="center">将光标移到下一个Tab位置</td>
</tr>
<tr>
<td align="center"><code>\v</code></td>
<td align="center">垂直制表符</td>
<td align="center">将光标移到下一个垂直制表符</td>
</tr>
<tr>
<td align="center"><code>\o</code></td>
<td align="center">与该八进制码对应的ASCII字符</td>
<td align="center">与该八进制码对应的ASCII字符</td>
</tr>
<tr>
<td align="center"><code>\xh[h…]</code></td>
<td align="center">与该十六进制码对应的ASCII字符</td>
<td align="center">与该十六进制码对应的ASCII字符</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>字符常量之字符串常量</strong> ，由 <code>“ ”</code> （双引号）包括的一个字符串，可以超过一个字符，如 <code>“boy”</code> 。</p>
</li>
<li><p><strong>字符常量之符号常量</strong> ，用 <code>#define</code> 指令指定一个符号名称代表一个常量。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Pi 3.14 <span class="comment">//符号常量，之后所有语句中所有Pi用3.14替换</span></span></span><br></pre></td></tr></table></figure>

<p><em>#define宏定义与常变量const的区别是，#define宏定义的值为实型常量，且#define为预处理命令，不分配内存，但常变量具有使程序稳定性提高的优点，使用方便。</em></p>
<ul>
<li><strong>变量</strong> ，在运行期间可以改变的量。变量必须先定义后使用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;  <span class="comment">//定义整型变量 a</span></span><br><span class="line">a = <span class="number">3</span>;  <span class="comment">//把3赋值给变量 a</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>常变量</strong> ，在变量存在期间不可改变的量。也必须先定义后使用。用法是在定义变量前加上“const”。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">3</span>;  <span class="comment">//定义一个整数常变量 a，后续不可修改。 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>标识符</strong> ，简单来说就是一个对象的名字，遵守命名规则。</li>
</ul>
<p>变量的命名规则：</p>
<ol>
<li><p>变量名的开头必须是字母或下划线，不能是数字。实际编程中最常用的是以字母开头，而以下划线开头的变量名是系统专用的。</p>
</li>
<li><p>变量名中的字母是区分大小写的。比如 a 和 A 是不同的变量名，num 和 Num 也是不同的变量名。</p>
</li>
<li><p>变量名绝对不可以是C语言关键字。</p>
</li>
<li><p>变量名中不能有空格。这个可以这样理解：因为上面我们说过，变量名是字母、数字、下划线的组合，没有空格这一项。</p>
</li>
</ol>
<h2><span id="32-数据的类型">3.2 数据的类型</span></h2><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_type.jpg" alt="数据类型"></p>
<h3><span id="321-整型数据">3.2.1 整型数据</span></h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">存储大小</th>
<th align="center">表示值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>char</code></td>
<td align="center">1字节</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center"><code>unsigned char</code></td>
<td align="center">1字节</td>
<td align="center">0~255</td>
</tr>
<tr>
<td align="center"><code>signed char</code></td>
<td align="center">1字节</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center"><code>int</code></td>
<td align="center">4字节</td>
<td align="center">-2147483648（$-2^{31}$）~2147483647（$2^{31}-1$）</td>
</tr>
<tr>
<td align="center"><code>unsigned int</code></td>
<td align="center">4字节</td>
<td align="center">0~4294967295（$2^{32}-1$）</td>
</tr>
<tr>
<td align="center"><code>short</code></td>
<td align="center">2字节</td>
<td align="center">-32768~32767</td>
</tr>
<tr>
<td align="center"><code>unsigned short</code></td>
<td align="center">2字节</td>
<td align="center">0~65535</td>
</tr>
<tr>
<td align="center"><code>long</code></td>
<td align="center">4字节</td>
<td align="center">-2147483648（$-2^{31}$）~2147483648（$2^{31}-1$）</td>
</tr>
<tr>
<td align="center"><code>unsigned long</code></td>
<td align="center">4字节</td>
<td align="center">0~4294967295（$2^{32}-1$）</td>
</tr>
<tr>
<td align="center"><code>long int</code></td>
<td align="center">4字节</td>
<td align="center">-2147483648（$-2^{31}$）~2147483648（$2^{31}-1$）</td>
</tr>
<tr>
<td align="center"><code>unsigned long int</code></td>
<td align="center">4字节</td>
<td align="center">0~4294967295（$2^{32}-1$）</td>
</tr>
<tr>
<td align="center"><code>long long int</code></td>
<td align="center">8字节</td>
<td align="center">$-2^{64}$~$2^{64}-1$</td>
</tr>
<tr>
<td align="center"><code>unsigned long long int</code></td>
<td align="center">8字节</td>
<td align="center">0~$2^{64}-1$</td>
</tr>
</tbody></table>
<p>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主，下同。为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 <code>sizeof(type)</code> 得到对象或类型的存储字节大小。</p>
<p>特别指出，unsigned表示无符号数据，即非负数，但只有整型和字符型数据可以加unsigned修饰符。</p>
<p>由于ASCII码的存在， <code>char</code> 类型的数据范围恰好最小完整表达字符，所以 <code>char</code> 类型又称为字符类型。</p>
<h3><span id="322-浮点型数据">3.2.2 浮点型数据</span></h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">存储大小</th>
<th align="center">表示值范围</th>
<th align="center">精度</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>float</code></td>
<td align="center">4字节</td>
<td align="center">1.2E-38~3.4E+38</td>
<td align="center">6位有效数字</td>
</tr>
<tr>
<td align="center"><code>double</code></td>
<td align="center">8字节</td>
<td align="center">2.3E-308~1.7E+308</td>
<td align="center">15位有效数字</td>
</tr>
<tr>
<td align="center"><code>long double</code></td>
<td align="center">16字节</td>
<td align="center">3.4E-4932~1.1E+4932</td>
<td align="center">19位有效数字</td>
</tr>
</tbody></table>
<p>需要注意，计算机对于浮点数的存储并不完全精准。</p>
<p>若我们声明定义的变量超过数据类型的数据范围时，编译会警告我们，我们可在数据末尾加专用字符进行类型转换。如在 <code>float</code> 类型数据后加“f”，指定为 <code>float</code> 类型，如在实型变量后加“L”，指定为 <code>long double</code> 型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">3.14159</span>;</span><br><span class="line"><span class="comment">//在某些系统中，会发出警告超出float类型，系统自动转化会影响精度</span></span><br><span class="line"><span class="type">float</span> a = <span class="number">3.14159f</span>;</span><br><span class="line"><span class="comment">//在数字后面加“f”，指定为float型，编译时不发出警告</span></span><br></pre></td></tr></table></figure>

<h3><span id="323-void类型">3.2.3 Void类型</span></h3><p><code>void</code> 它通常用于以下三种情况下：</p>
<ol>
<li>函数返回为空：C中有各种函数都不返回值，或者可以说它们返回空。不返回值的函数的返回类型为空。</li>
<li>函数参数为空：C中有各种函数不接受任何参数。不带参数的函数可以接受一个 <code>void</code> 。</li>
<li>指针指向 <code>void</code> ：类型为 <code>void *</code> 的指针代表对象的地址，而不是类型。返回指向 <code>void</code> 的指针，可以转换为任何数据类型。</li>
</ol>
<h3><span id="324-类型转换">3.2.4 类型转换</span></h3><p>类型转换是将一个数据类型的值转换为另一种数据类型的值。</p>
<p>C 语言中有两种类型转换：</p>
<ul>
<li><strong>隐式类型转换</strong>：隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型，例如，将int类型转换为long类型或float类型转换为double类型。隐式类型转换也可能会导致数据精度丢失或数据截断。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> d = i + f; <span class="comment">// 隐式将int类型转换为double类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>显式类型转换</strong>：显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。强制类型转换可以使程序员在必要时对数据类型进行更精确的控制，但也可能会导致数据丢失或截断。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">int</span> i = (<span class="type">int</span>)d; <span class="comment">// 显式将double类型转换为int类型</span></span><br></pre></td></tr></table></figure>


<h2><span id="33-运算符">3.3 运算符</span></h2><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_cop.jpg" alt="运算符"></p>
<h3><span id="331-算术运算符">3.3.1 算术运算符</span></h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>+</code></td>
<td align="center">左操作数和右操作数相加</td>
<td align="center"><code>A + B</code></td>
</tr>
<tr>
<td align="center"><code>-</code></td>
<td align="center">左操作数减去右操作数</td>
<td align="center"><code>A - B</code></td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td align="center">左操作数和右操作数相乘</td>
<td align="center"><code>A * B</code></td>
</tr>
<tr>
<td align="center"><code>/</code></td>
<td align="center">左操作数除以右操作数</td>
<td align="center"><code>A / B</code></td>
</tr>
<tr>
<td align="center"><code>%</code></td>
<td align="center">左操作数除以右操作数后的余数</td>
<td align="center"><code>A % B</code></td>
</tr>
<tr>
<td align="center"><code>++</code></td>
<td align="center">操作数整数值自增1</td>
<td align="center"><code>A ++</code></td>
</tr>
<tr>
<td align="center"><code>--</code></td>
<td align="center">操作数整数值自减1</td>
<td align="center"><code>A --</code></td>
</tr>
</tbody></table>
<p><code>%</code> 运算符的操作数只可以是整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> a, b, ans1;</span><br><span class="line">	<span class="type">int</span> c, d, ans2;</span><br><span class="line">	ans1 = a + b; <span class="comment">//两个整型变量相加的结果仍为整型.</span></span><br><span class="line">	ans1 = a - b; <span class="comment">//两个整型变量相减的结果仍为整型。</span></span><br><span class="line">	ans1 = a * b; <span class="comment">//两个整型变量相乘的结果仍为整型。</span></span><br><span class="line">	ans1 = a / b; <span class="comment">//两个整型变量相除的结果仍为整型，多数为除不尽向零取整。</span></span><br><span class="line">	<span class="comment">//如 5/3=1，-5/3=-1；</span></span><br><span class="line">	ans2 = c % d; <span class="comment">// 取余运算要求运算对象均为整数，即整型。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应当注意， <code>++i</code> 和 <code>i++</code> ， <code>--i</code> 和 <code>i--</code> 是两回事。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test2.c</span></span><br><span class="line"><span class="comment">//以下例子可能理解更加深刻</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,j;</span><br><span class="line">  </span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">	i++;    <span class="comment">//i使用后，使i的值加一,此时 i=1；</span></span><br><span class="line">	j = i;    <span class="comment">// j=i=2;</span></span><br><span class="line">    </span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">	++i;    <span class="comment">//i使用前，使i的值加一,此时 i=2；</span></span><br><span class="line">	j = i;    <span class="comment">// j=i=2;</span></span><br><span class="line">    </span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">	i--;    <span class="comment">//j使用后，使i的值减一，此时 i=1；</span></span><br><span class="line">	j = i;    <span class="comment">//j=i=0;</span></span><br><span class="line">    </span><br><span class="line">	i = <span class="number">1</span>;</span><br><span class="line">	--i;    <span class="comment">//j使用前，使i的值减一，此时 i=0；</span></span><br><span class="line">	j = i;    <span class="comment">//j=i=0;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="332-关系运算符">3.3.2 关系运算符</span></h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>==</code></td>
<td align="center">检查两个操作数的值是否相等，如果相等则条件为真</td>
<td align="center"><code>A == B</code></td>
</tr>
<tr>
<td align="center"><code>!=</code></td>
<td align="center">检查两个操作数的值是否相等，如果不相等则条件为真</td>
<td align="center"><code>A != B</code></td>
</tr>
<tr>
<td align="center"><code>&gt;</code></td>
<td align="center">检查左操作数的值是否大于右操作数的值，如果是则条件为真</td>
<td align="center"><code>A &gt; B</code></td>
</tr>
<tr>
<td align="center"><code>&lt;</code></td>
<td align="center">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td align="center"><code>A &lt; B</code></td>
</tr>
<tr>
<td align="center"><code>&gt;=</code></td>
<td align="center">检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。</td>
<td align="center"><code>A &gt;= B</code></td>
</tr>
<tr>
<td align="center"><code>&lt;=</code></td>
<td align="center">检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。</td>
<td align="center"><code>A &lt;= B</code></td>
</tr>
</tbody></table>
<h3><span id="333-逻辑运算符">3.3.3 逻辑运算符</span></h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;&amp;</code></td>
<td align="center">逻辑与运算符，如果两个操作数都非零，则条件为真。</td>
<td align="center"><code>A &amp;&amp; B</code></td>
</tr>
<tr>
<td align="center"><code>||</code></td>
<td align="center">逻辑或运算符，如果两个操作数中有任意一个非零，则条件为真</td>
<td align="center"><code>A || B</code></td>
</tr>
<tr>
<td align="center"><code>!</code></td>
<td align="center">逻辑非运算符，用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td align="center"><code>!A</code></td>
</tr>
</tbody></table>
<h3><span id="334-位运算符">3.3.4 位运算符</span></h3><p>位运算符是对数据转化为二进制，再逐位进行运算。如$60_{10} &#x3D; 00111100_{2}$，再对每一位进行逻辑运算。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;</code></td>
<td align="center">按位与运算符，对两个操作数的每一位执行逻辑与操作</td>
<td align="center"><code>A &amp; B</code></td>
</tr>
<tr>
<td align="center"><code>|</code></td>
<td align="center">按位或运算符，对两个操作数的每一位执行逻辑或操作</td>
<td align="center"><code>A | B</code></td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">按位异或运算符，对两个操作数的每一位执行逻辑异或操作</td>
<td align="center"><code>A ^ B</code></td>
</tr>
<tr>
<td align="center"><code>~</code></td>
<td align="center">按位取反运算符，对两个操作数的每一位执行逻辑取反操作</td>
<td align="center"><code>~A</code></td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">将操作数的所有位向左移动指定的位数。左移n位相当于乘以2的n次方</td>
<td align="center"><code>A &lt;&lt; n</code></td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">将操作数的所有位向右移动指定的位数。右移n位相当于除以2的n次方</td>
<td align="center"><code>A &gt;&gt; n</code></td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bit.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">60</span>;    <span class="comment">/* 60 = 0011 1100 */</span>  </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">13</span>;    <span class="comment">/* 13 = 0000 1101 */</span></span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;           </span><br><span class="line"> </span><br><span class="line">	c = a &amp; b;       <span class="comment">/* 12 = 0000 1100 */</span> </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c ); <span class="comment">// 一个输出的函数</span></span><br><span class="line"> </span><br><span class="line">	c = a | b;       <span class="comment">/* 61 = 0011 1101 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">	c = a ^ b;       <span class="comment">/* 49 = 0011 0001 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">	c = ~a;          <span class="comment">/*-61 = 1100 0011 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">	c = a &lt;&lt; <span class="number">2</span>;     <span class="comment">/* 240 = 1111 0000 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c );</span><br><span class="line"> </span><br><span class="line">	c = a &gt;&gt; <span class="number">2</span>;     <span class="comment">/* 15 = 0000 1111 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c 的值是 %d\n&quot;</span>, c );</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="335-赋值运算符">3.3.5 赋值运算符</span></h3><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th align="center">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>=</code></td>
<td align="center">把右操作数的值赋给左操作数</td>
<td align="center"><code>C = A + B</code></td>
</tr>
<tr>
<td align="center"><code>+=</code></td>
<td align="center">把右边操作数加上左边操作数的结果赋给左边操作数</td>
<td align="center"><code>C += A</code> 相当于 <code>C = C + A</code></td>
</tr>
<tr>
<td align="center"><code>-=</code></td>
<td align="center">把右边操作数减去左边操作数的结果赋给左边操作数</td>
<td align="center"><code>C -= A</code> 相当于 <code>C = C - A</code></td>
</tr>
<tr>
<td align="center"><code>*=</code></td>
<td align="center">把右边操作数乘以左边操作数的结果赋给左边操作数</td>
<td align="center"><code>C *= A</code> 相当于 <code>C = C * A</code></td>
</tr>
<tr>
<td align="center"><code>/=</code></td>
<td align="center">把右边操作数除以左边操作数的结果赋给左边操作数</td>
<td align="center"><code>C /= A</code> 相当于 <code>C = C / A</code></td>
</tr>
<tr>
<td align="center"><code>%=</code></td>
<td align="center">把右边操作数取余左边操作数的结果赋给左边操作数</td>
<td align="center"><code>C %= A</code> 相当于 <code>C = C % A</code></td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;=</code></td>
<td align="center">左移且赋值运算符</td>
<td align="center"><code>C &lt;&lt;= A</code> 相当于 <code>C = C &lt;&lt; A</code></td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;=</code></td>
<td align="center">右移且赋值运算符</td>
<td align="center"><code>C &gt;&gt;= A</code> 相当于 <code>C = C &gt;&gt; A</code></td>
</tr>
<tr>
<td align="center"><code>&amp;=</code></td>
<td align="center">按位与且赋值运算符</td>
<td align="center"><code>C &amp;= A</code> 相当于 <code>C = C &amp; A</code></td>
</tr>
<tr>
<td align="center"><code>^=</code></td>
<td align="center">按位异或且赋值运算符</td>
<td align="center"><code>C ^= A</code> 相当于 <code>C = C ^ A</code></td>
</tr>
<tr>
<td align="center"><code>|=</code></td>
<td align="center">按位或且赋值运算符</td>
<td align="center"><code>C |= A</code> 相当于 <code>C = C | A</code></td>
</tr>
</tbody></table>
<h3><span id="336-其他运算符">3.3.6 其他运算符</span></h3><ul>
<li><strong>条件运算符</strong> <code>（? : ）</code> ：其形式为 <code>(表达式1)? 表达式2 : 表达式3</code> ，先求解表达式1，若其值为真（非0）则将表达式2的值作为整个表达式的取值，否则（表达式1的值为0）将表达式3的值作为整个表达式的取值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">9</span>, o = <span class="number">6</span>, q;</span><br><span class="line">	i &gt; o ? i : o;</span><br><span class="line">	<span class="comment">// i大于o吗，大于（真）则返回i的值，小于（假）则返回o的值。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>逗号运算符</strong> <code>,</code> ：其形式为 <code>表达式1,表达式2</code> ，逗号运算符确保操作数被顺序地处理：先计算左边的操作数，再计算右边的操作数。右操作数的类型和值作为整个表达式的结果。左操作数只是为了副作用需要而被计算，它其值会被丢弃。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">9</span>, o = <span class="number">6</span>, q;</span><br><span class="line">	q = (i + o, i - o);</span><br><span class="line">	<span class="comment">// q = 3</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>指针运算符</strong> <code>&amp;</code> 和 <code>*</code> 。 <code>*</code> ：取值符，指向一个变量； <code>&amp;</code> ：取地址符，取址运算符的操作数必须是在内存中可寻址到的地址。换句话说，该运算符只能用于函数或对象。</p>
</li>
<li><p><strong>成员运算符</strong> <code>.</code> 和 <code>-&gt;</code> 。用于返回复杂数据类型的子成员。</p>
</li>
<li><p><strong>下标运算符</strong> <code>[]</code> 。用于访问下标，在数组中用到。</p>
</li>
<li><p><strong>求字节运算符</strong> <code>sizeof()</code> 。返回变量的大小，将需要求字节内存的变量或其他数据结构放于括号中。</p>
</li>
<li><p><strong>强制类型转换运算符</strong> <code>(类型名)(表达式)</code> 。 如 <code>(float)(a + b)</code> 。</p>
</li>
</ul>
<h3><span id="337-运算符优先级">3.3.7 运算符优先级</span></h3><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_pre.jpg" alt="运算符优先级"></p>
<h2><span id="34-语句">3.4 语句</span></h2><ol>
<li><strong>控制语句</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件语句</span></span><br><span class="line"><span class="keyword">if</span>(条件)  <span class="comment">//如果小括号里面的条件为真，则运行大括号的语句。</span></span><br><span class="line">&#123;</span><br><span class="line">  …… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环语句</span></span><br><span class="line"><span class="keyword">for</span>(语句<span class="number">1</span>;语句<span class="number">2</span>;语句<span class="number">3</span>)  <span class="comment">//语句2为条件，为真则运行大括号的语句，直至条件为假</span></span><br><span class="line">&#123;</span><br><span class="line">  …… </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，小括号内必须得有两个分号，即使没有语句</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环语句</span></span><br><span class="line"><span class="keyword">while</span>(条件)  <span class="comment">//如果小括号的条件为真，则运行大括号的语句，直至条件为假</span></span><br><span class="line">&#123;</span><br><span class="line">  …… </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  …… </span><br><span class="line">&#125;<span class="keyword">while</span>(条件);  <span class="comment">//如果小括号的条件为真，则运行大括号的语句，直至条件为假</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，while(…)&#123;…&#125;和do&#123;…&#125;while;的区别是，do-while至少循环一次，无视条件真或假。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//用于循环语句</span></span><br><span class="line"><span class="comment">//作用是结束该次循环，转至下一次循环，不改变总循环次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//用于循环语句或者switch语句</span></span><br><span class="line"><span class="comment">//作用是结束整个循环，改变总循环次数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件语句</span></span><br><span class="line"><span class="keyword">switch</span> (对象)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">    语句<span class="number">1</span> </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    语句<span class="number">2</span> </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:  <span class="comment">//default表示除以上case之外的情况</span></span><br><span class="line">    语句<span class="number">3</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该语句每个case中的break不可省略。</span></span><br><span class="line"><span class="comment">//若省略break则系统会一直往下读语句，直至结束或者break，可自行上机作死</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> ……;</span><br><span class="line"><span class="comment">//从函数中返回语句，一般情况下返回语句也是函数结束的地方</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//转向语句</span></span><br><span class="line"><span class="keyword">goto</span> a;</span><br><span class="line">  number = <span class="number">0</span>;</span><br><span class="line">a:</span><br><span class="line">  number = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//结果number为1;  </span></span><br><span class="line"><span class="comment">//声明一处标记为a，使用goto语句使程序转向a处；</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>函数调用语句</strong>：右一个函数调用加分号构成。</p>
</li>
<li><p><strong>复合语句</strong>：用 <code>&#123;&#125;</code> 括起来的语句，也称语句块。</p>
</li>
<li><p><strong>空语句</strong>：只有一个分号。</p>
</li>
<li><p><strong>表达式语句</strong>：一个表达式加上一个分号构成。用C语言运算符将运算对象连接起来的式子称为表达式。</p>
</li>
</ol>
<h2><span id="35-变量的作用范围">3.5 变量的作用范围</span></h2><p>任何一种编程中， <strong>作用域</strong> 是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。</p>
<p>C语言中有三个地方可以声明变量：</p>
<ol>
<li><p>在函数或块（由花括号包括起来的称为代码块）内部的局部变量</p>
</li>
<li><p>在所有函数外部的全局变量</p>
</li>
<li><p>在形式参数的函数参数定义中</p>
</li>
</ol>
<p>变量按作用范围可分为 <strong>局部变量</strong> 、 <strong>全局变量</strong> 、 <strong>形式参数</strong> 。</p>
<ul>
<li><strong>局部变量</strong></li>
</ul>
<p>在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 局部变量声明</span></span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 实际初始化 </span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">20</span>;</span><br><span class="line">	c = a + b;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>全局变量</strong></li>
</ul>
<p>全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。也就是说，全局变量在声明后整个程序中都是可用的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 局部变量声明</span></span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 实际初始化</span></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = <span class="number">20</span>;</span><br><span class="line">	g = a + b;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;value of a = %d, b = %d and g = %d\n&quot;</span>, a, b, g);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>形式参数</strong></li>
</ul>
<p>函数的参数就是形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用，同样如果局部变量与全局变量同名时优先使用当前区域的局部变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 在主函数中的局部变量声明</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;主函数中的 a = %d\n&quot;</span>, a);</span><br><span class="line">	c = sum(a, b);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;主函数中的 c = %d\n&quot;</span>, c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加两个整数的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;sum函数中的 a = %d\n&quot;</span>,  a);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">&quot;sum函数中的 b = %d\n&quot;</span>,  b);</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">主函数中的 a = 10</span><br><span class="line">sum函数中的 a = 10</span><br><span class="line">sum函数中的 b = 20</span><br><span class="line">主函数中的 c = 30</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>全局变量与局部变量在内存中的区别</strong></li>
</ul>
<ol>
<li><p>全局变量保存在内存的全局存储区中，占用静态的存储单元；</p>
</li>
<li><p>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</p>
</li>
</ol>
<ul>
<li><strong>局部变量和全局变量的初始化</strong></li>
</ul>
<p>当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">初始化默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>int</code></td>
<td align="center"><code>0</code></td>
</tr>
<tr>
<td align="center"><code>char</code></td>
<td align="center"><code>\0</code></td>
</tr>
<tr>
<td align="center"><code>float</code></td>
<td align="center"><code>0</code></td>
</tr>
<tr>
<td align="center"><code>double</code></td>
<td align="center"><code>0</code></td>
</tr>
<tr>
<td align="center"><code>pointer</code>（指针）</td>
<td align="center"><code>NULL</code></td>
</tr>
</tbody></table>
<h1><span id="iv-格式化输入输出">Ⅳ —— 格式化输入输出</span></h1><p>格式化的输入输出函数位于 <code>stdio.h</code> 头文件中。</p>
<h2><span id="41-格式化的输出">4.1 格式化的输出</span></h2><ul>
<li><code>printf()</code>函数进行格式化的输出，其函数定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br><span class="line"><span class="comment">// fmt：为常量字符串,存储在内存的常量字段，fmt为该字符串首地址；</span></span><br><span class="line"><span class="comment">// ...表示存在可变形参</span></span><br><span class="line"><span class="comment">// 输出正确返回输出的字符总数，输出错误返回负值</span></span><br></pre></td></tr></table></figure>

<p>也可以参考这样的格式： <code>printf(格式控制,输出表列)</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// printf.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a, b, c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<p><strong>格式控制</strong>，是使用双引号括起来的一个字符串，称为格式控制字符串，包括格式声明和普通字符。</p>
<ol>
<li><p><strong>格式声明</strong>，由 <code>%</code>（百分号）和格式字符组成，其作用是将输出的数据转换为指定的格式后输出。格式声明总是由 <code>%</code> 字符开始。</p>
</li>
<li><p><strong>普通字符</strong>，即原样输出的字符，包括逗号、空格等。</p>
</li>
</ol>
<p>应当注意的是：</p>
<ol>
<li><p>当我们想在显示器输出一个 <code>%</code> 时，我们需要在格式控制字符串中连续使用两个 <code>%</code> 表示一个 <code>%</code> 。</p>
</li>
<li><p>当我们想在显示器输出一个 <code>\</code> 时，我们需要在格式控制字符串中连续使用两个 <code>\</code> 表示一个 <code>\</code> 。</p>
</li>
</ol>
<p>对于格式字符，有如下：</p>
<table>
<thead>
<tr>
<th align="center">格式字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>d</code> 或 <code>i</code></td>
<td align="center">以带符号的十进制输出整数（正数不带符号）</td>
</tr>
<tr>
<td align="center"><code>ld</code> 或 <code>lld</code></td>
<td align="center">数据类型为 <code>long int</code> 或 <code>long long int</code> 的输出</td>
</tr>
<tr>
<td align="center"><code>o</code></td>
<td align="center">以无符号的八进制输出整数（不输出前导 <code>0</code>）</td>
</tr>
<tr>
<td align="center"><code>x</code> 或 <code>X</code></td>
<td align="center">以无符号的十六进制输出整数（不输出前导符 <code>0x</code> ）</td>
</tr>
<tr>
<td align="center"><code>u</code></td>
<td align="center">以无符号的十进制输出整数</td>
</tr>
<tr>
<td align="center"><code>c</code></td>
<td align="center">以字符形式输出一个字符</td>
</tr>
<tr>
<td align="center"><code>s</code></td>
<td align="center">输出一整个字符串，直至遇到 <code>\0</code></td>
</tr>
<tr>
<td align="center"><code>f</code></td>
<td align="center">以小数形式输出单精度数，默认输出6位小数</td>
</tr>
<tr>
<td align="center"><code>lf</code></td>
<td align="center">以小数形式输出双精度数，默认输出6位小数</td>
</tr>
<tr>
<td align="center"><code>e</code> 或 <code>E</code></td>
<td align="center">以指数形式输出实数</td>
</tr>
<tr>
<td align="center"><code>g</code> 或 <code>G</code></td>
<td align="center">选用 <code>%f</code> 或 <code>%e</code> 中宽度较短的格式，不输出无意义 <code>0</code></td>
</tr>
</tbody></table>
<ul>
<li>PS：正常来说，一个数字的前面加 <code>0</code> ，表示该数字为八进制。上述中不输出前导 <code>0</code> ，但当格式为 <code>%#o</code> 时，输出前导 <code>0</code> ；一个数字的前面加 <code>0x</code> ，表示该数字为十六进制。上述中不输出前导符，但当格式为 <code>%#x</code> 时，输出前导 <code>0x</code> 。</li>
</ul>
<p>输入下面的代码可以直观感受输出的格式问题：会因为格式字符与输出的数据类型不匹配而导致输出乱码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">float</span> b = <span class="number">3.1415926535</span>; </span><br><span class="line">	<span class="type">double</span> c = <span class="number">3.1415926535</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">int</span> d = <span class="number">1e9</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> e=<span class="number">1e18</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t\t%ld\t\t%lld\t\t%f\t%lf\n&quot;</span>, a, a, a, a, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t%ld\t%lld\t%.8f\t%.8lf\n&quot;</span>, b, b, b, b, b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t%ld\t%lld\t%.8f\t%.8lf\n&quot;</span>, c, c, c, c, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t%ld\t%lld\t%f\t%lf\n&quot;</span>, d, d, d, d, d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\t%ld\t%lld\t%f\t%lf\n&quot;</span>, e, e, e, e, e);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">1               1               4294967297              0.000000        0.000000</span><br><span class="line">1610612736      1074340347      4614256656748904448     3.14159274      3.14159274</span><br><span class="line">1413551940      1074340347      4614256656551843652     3.14159265      3.14159265</span><br><span class="line">1000000000      1000000000      4294967297000000000     3.141592        3.141593</span><br><span class="line">-1486618624     232830643       1000000000000000000     0.000000        0.000000</span><br></pre></td></tr></table></figure>

<p>应该清晰格式字符，不乱用不混用。 <strong>输出表列的数量需与%d（或其他格式声明）的数量一致。</strong></p>
<p><code>%f</code> 默认保留6位小数，而 <code>%m.nf</code> 可以自定义小数位，m指输出宽度，n指保留小数位。如果想用 <code>0</code> 控制宽度，在宽度控制数字前加 <code>0</code> 可以这么使用 <code>%06d</code> 、<code>%07.2f</code> ，但只能补前导 <code>0</code> 。而单独的 <code>%.nf</code> 就可以控制输出的小数位。</p>
<p>当m前面添加 <code>-</code> ，则输出数据向左对齐，再补空格或 <code>0</code> 。当m前面无 <code>-</code> ，则输出数据向右对齐，再补空格或 <code>0</code> ，此时称前导空格或前导 <code>0</code> 。</p>
<p>如 <code>%7.2f</code> ，表示输出数据占7列（小数点也占一列），保留2位小数。运行以下代码可深刻理解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> a = <span class="number">3.141592</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;|%07.2f|\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;|%-07.2f|\n&quot;</span>, a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">|0003.14|</span><br><span class="line">|3.14   |</span><br></pre></td></tr></table></figure>

<p>由 <code>%f</code> 拓展， <code>%d</code> 等格式声明都可在 <code>%</code> 和格式字符之间加一个数字（正或负），表示控制整个输出所占宽度，如 <code>%7d</code> 、 <code>%4c</code> 等。</p>
<p>如果事先并不知道保留多少小数位，而是后续输入的情况，可以使用占位符 <code>%.*f</code> 解决。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> a = <span class="number">3.1415926</span>;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k); <span class="comment">// 根据输入的k决定保留多少位小数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.*f&quot;</span>, k, a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>另外， <code>printf()</code> 函数在运行时的形参是 <strong>从右到左</strong> 处理，具体效果如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, b = a + <span class="number">1</span>, a += <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果:</span><br><span class="line">7 6</span><br></pre></td></tr></table></figure>

<p>由于是 <strong>从右到左</strong> 的顺序处理，所以先是 <code>a += 1</code> ，a变成6，再接着 <code>b = a + 1</code>，b变成7。</p>
<ul>
<li>putchar()：输出一个字符</li>
</ul>
<p>函数原型： <code>int putchar(int _Character)</code> ，函数定义在 <code>stdio.h</code> 中。</p>
<ul>
<li>puts()：输出一个字符串，并换行</li>
</ul>
<p>函数原型： <code>int puts(const char *s);</code> ，函数定义在 <code>stdio.h</code> 中。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(a);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">!aHello World!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="42-格式化的输入">4.2 格式化的输入</span></h2><ul>
<li>用 <code>scanf()</code> 函数进行格式化的输出，其函数定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="keyword">restrict</span> format,...)</span>;</span><br><span class="line"><span class="comment">// 第一参数为输入格式字符串，省略号表示存在可变形参</span></span><br><span class="line"><span class="comment">// 输入成功返回成功读入的数据项数，输入数据时遇到了结束则返回EOF（End Of File）。</span></span><br></pre></td></tr></table></figure>

<p>也可以参考这样的格式： <code>scanf(格式控制，地址表列)；</code>。格式控制字符串同输入的规则。在使用 <code>scanf()</code> 的时候，我们应当注意， <code>scanf()</code> 函数的地址表列是需要输入的变量地址，而不是变量名，因此，我们要在变量名前加 <code>&amp;</code> 取地址符。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, a, b, c);    <span class="comment">//此写法错误</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c); <span class="comment">//此写法正确</span></span><br></pre></td></tr></table></figure>

<p>当我们不加取地址符的时候，程序会因为储存内存溢出（输入的内容没有正确的地方存放）而终止程序。因此，当我们的程序莫名中断崩掉时，我们可以优先考虑是否在输入时加取地址符。</p>
<p>还需要注意的是， <code>scanf()</code> 的格式控制字符串应与我们输入的格式严格一致，即格式控制字符串中有逗号或空格等的时候，我们输入也需加上逗号或空格等。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);<span class="comment">//此时应当输入 1 2 3</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>, &amp;a, &amp;b, &amp;c);<span class="comment">//此时应当输入 1,2,3</span></span><br></pre></td></tr></table></figure>

<p>如果没有留意到这个问题，那么当我们输入数据的时候，可能会出现数据吞没的情况，因为输入的跟字符串规定的不匹配，不读入。</p>
<p>该函数还有自动处理的地方，如</p>
<ol>
<li><p>当我们的输入格式控制为 <code>%d%d%d</code> 时，系统会自动把空格或者换行（回车）作为分隔两个数据的标志。</p>
</li>
<li><p>当我们的输入格式控制为 <code>%f%f%f</code> 时，系统会自动把小数点、空格或者换行（回车）作为分隔两个数据的标志。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%f%f&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%f %f\n&quot;</span>, a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行窗口：</span><br><span class="line">3.142.77                              //输入</span><br><span class="line">3.142000 0.770000                     //输出</span><br></pre></td></tr></table></figure>

<p>虽然系统会自动把空格作为分隔两个数据的标志而不读入空格，但是总有办法可以使得 <code>scanf()</code> 函数输入带空格，如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getstring.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">20</span>]; <span class="comment">// 存放字符串</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>, a); <span class="comment">// 可输入带空格的字符串</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上， <code>scanf()</code> 函数的注意点与其的键盘缓冲区和输入流有关。该函数会从输入流中选择数据放入键盘缓冲区中。在未输入满前忽略掉空白字符（空格、制表符和新行符），在输入满时把空白字符当作中断的标志。所以要注意反思输入流和键盘缓冲区里面的内容是什么，是否有键盘缓冲区遗留问题导致提前终止输入，是否有数据仍在输入流中没有进入键盘缓冲区而丢弃等。</p>
<ul>
<li><code>getchar()</code>：输入一个字符</li>
</ul>
<p>函数原型： <code>int getchar(void);</code> ，返回值则是输入的字符的ASCII码，若读取失败返回EOF或-1，函数定义在 <code>stdio.h</code> 中。 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	b = getchar();</span><br><span class="line">	<span class="built_in">putchar</span>(b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行窗口：</span><br><span class="line">h	// 输入</span><br><span class="line">h	// 输出</span><br></pre></td></tr></table></figure>

<ul>
<li><code>gets()</code>：输入一个字符串，一般使用 <code>scanf()</code> 输入字符串的时候不能输入含空格的字符串，而使用 <code>gets()</code> 则可以输入含空格的字符串。</li>
</ul>
<p>由于 <code>gets()</code> 函数的不安全性，在C99标准中，已经不再建议使用该函数，而在C11中更是直接抛弃了这个函数。</p>
<p><br><br><br></p>
<h1><span id="v-条件结构">Ⅴ —— 条件结构</span></h1><p>实际上，在很多情况下，需要根据某个条件是否满足来决定是否执行指定操作任务，或者从给定的两种或多种操作选择其一。这就是选择结构需要解决的问题。再举个详细的例子，当我们处于岔路时，做出方向的选择；比如数学上的分段函数，条件不同对应函数关系不同。</p>
<p>通过条件结构，可以完成一些简单的语法题，如交换两个数，输出两数最大值和最小值，由键盘输入三个数输出最大值，判断闰年……</p>
<h2><span id="51-if构成的条件结构">5.1 if构成的条件结构</span></h2><p><code>if</code> 语句的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( condition is <span class="literal">true</span> ) </span><br><span class="line">&#123;</span><br><span class="line">  sentence1;</span><br><span class="line">  sentence2;</span><br><span class="line">  …………</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先简单地翻译一遍以上代码：如果（ 某个条件成立 ），则运行花括号中的内容。</span></span><br></pre></td></tr></table></figure>

<p>需要注意， <code>if</code> 语句在没有花括号的情况下，只连带其后的一句语句。即 <code>if(condition)</code> 后只能跟一个语句，其可以是单个简单语句，也可以是由花括号包含起来的复合语句。</p>
<p>再加之 <code>else</code> （另外，否则），可以组成以下三种形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一，无else子句部分，只有单个if语句</span></span><br><span class="line"><span class="keyword">if</span>( condition )</span><br><span class="line">&#123;</span><br><span class="line">	sentence;</span><br><span class="line">&#125;   </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 情况二，有else子句部分</span></span><br><span class="line"><span class="keyword">if</span>( condition )</span><br><span class="line">&#123;</span><br><span class="line">	sentence1;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	sentence2;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 情况三，在else部分又嵌套多层if语句</span></span><br><span class="line"><span class="keyword">if</span>( condition )</span><br><span class="line">&#123;</span><br><span class="line">	sentence1;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( condition1 )</span><br><span class="line">&#123;</span><br><span class="line">	sentence2;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	sentence3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三还可以写成下面的形式</span></span><br><span class="line"><span class="keyword">if</span>( condition )</span><br><span class="line">&#123;</span><br><span class="line">	sentence1;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>( condition1 )</span><br><span class="line">	&#123;</span><br><span class="line">		sentence2;</span><br><span class="line">	&#125;   </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		sentence3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code> 语句无论写几行，都是一个整体，属于同一个语句，只是将其分成 <code>if</code> 部分和 <code>else</code> 部分。在 <code>if</code> 语句中要对给定的条件进行检查，判定所给定的条件是否成立。判断的结果是一个逻辑值“是”或“否”。</p>
<p><code>if</code> 语句小括号中的 <code>condition</code> ，应该是由关系运算符与逻辑运算符构成的表达式，运算符号详见运算符。如表达x大于1时写成 <code>x&gt;1</code> ，表达x在10到20之间时写成 <code>x &gt;=10 &amp;&amp; x &lt;= 20</code> ，表达x不等于4时写成 <code>x != 4</code> ，表达x等于4时写成 <code>x == 4</code> 。可以试着巧妙应用 <code>? :</code> 三目运算符转化繁琐的if结构。</p>
<p>下面结合一个例子剖析 <code>if-else</code> 语句，在数学中有阶跃函数（分段函数），当x＞0时，y＝1；当x＝0时，y＝0；当x＜0时，y＝-1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y; <span class="comment">//定义x和y变量</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">//输入x</span></span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">0</span>) <span class="comment">//第一个判断，做x＞0的判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		y = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>( x == <span class="number">0</span> ) <span class="comment">//排除第一个判断后的另外一个判断，做x＝0的判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>( x &lt; <span class="number">0</span> ) <span class="comment">//排除以上两种情况后的另一种情况，做x＜0的判断</span></span><br><span class="line">	&#123;</span><br><span class="line">		y = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//其实这种情况下，排除以上两种情况，剩下唯一的可能，可以写成else部分</span></span><br><span class="line">	<span class="comment">//如：</span></span><br><span class="line">	<span class="comment">//  else</span></span><br><span class="line">	<span class="comment">//  &#123;</span></span><br><span class="line">	<span class="comment">//     y = -1;</span></span><br><span class="line">	<span class="comment">//  &#125;</span></span><br><span class="line">  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, y); <span class="comment">//输出y</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code> 语句可以多个嵌套， <code>if</code> 中又带有 <code>if-else</code> 等情况，请注意辨识。应当注意 <code>if</code> 与 <code>else</code> 的配对关系。 <code>else</code> 总是与它上面最近的未配对的 <code>if</code> 配对， <code>else</code> 一般不能单独出现，上面必须先有 <code>if</code> 部分。上面的例子用 <code>if</code> 语句嵌套可如下表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y; <span class="comment">//定义x和y变量</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">//输入x</span></span><br><span class="line">	<span class="keyword">if</span>(x &gt;= <span class="number">0</span>)  <span class="comment">//将大于等于零归为一类</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &gt; <span class="number">0</span>)<span class="comment">//再判断大于0的情况</span></span><br><span class="line">			y = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//在x大于等于零的情况下，再排除x大于零，即x等于零</span></span><br><span class="line">			y = ;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//排除x大于等于零的情况下，即x小于零 </span></span><br><span class="line">		y = <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, y); <span class="comment">//输出y</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="52-switch构成的条件结构">5.2 switch构成的条件结构</span></h2><p><code>switch</code> 语句的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (object) <span class="comment">//对于某个变量或表达式进行switch</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">case</span> constant1: <span class="comment">//对于常量1的情况，进行语句</span></span><br><span class="line">		<span class="comment">//操作部分语句</span></span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">//注意break必须存在</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> constant2: <span class="comment">//对于常量2的情况，进行语句</span></span><br><span class="line">		<span class="comment">//操作部分语句</span></span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">//注意break必须存在</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>: <span class="comment">//对于默认情况，即排除上述情况，进行语句</span></span><br><span class="line">		<span class="comment">//操作部分语句</span></span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">//注意break不必存在，建议存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此强调， <code>switch</code> 语句中 <code>case</code> 情况部分的 <code>break</code> 语句必须存在，此为语法规定。当去掉 <code>break</code> 语句时，系统将逐句往下运行。更具体地说，如果 <code>switch</code> 时 <code>case</code> 情况1的话，你想运行情况1部分的语句，但因为缺少 <code>break</code> 语句，系统还会运行下面 <code>case</code> 情况的语句，造成逻辑表达上的错误。可以对下面的代码中每个 <code>break</code> 试着取消注释，让其运行，观察系统运行语句输出区别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> object = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span>(object) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span> : </span><br><span class="line">			sum = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//break;</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span> : </span><br><span class="line">			sum = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//brea;</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">			sum = <span class="number">2</span>;</span><br><span class="line">			<span class="comment">//break;</span></span><br><span class="line">		<span class="keyword">default</span> :</span><br><span class="line">			sum = <span class="number">-1</span>;</span><br><span class="line">			<span class="comment">//break;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 语句的对象应该是 <strong>整型和字符类型的变量或变量表达式</strong> ，如 <code>int</code> 变量 <code>number</code> 、 <code>char</code> 变量 <code>ch</code>  、 <code>number%10</code> 、 <code>ch+32</code> ……相对于的 <code>case</code> 情况应该是整型常量或者是字符常量。如整数1、2、3……和字符’A’、’B’、’c’……</p>
<p>对于 <code>switch</code> 语句，还有以下规则说明。操作部分语句可以不止一个语句，其一直运行到 <code>break</code> 语句为止。可以没有 <code>default</code> 的情况，但此时如果没有与 <code>switch</code> 表达式相匹配的 <code>case</code> 常量时，不执行任何语句。 <code>case</code> 情况出现的次序不影响执行结果，每个 <code>case</code> 情况常量必须互不相同，不能存在一个值有多种执行情况。</p>
<p>这里有一个例子，对于输入分数，输出分数评级，可以辅助理解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> score ; <span class="comment">//输入分数score，此处人为规定输入值在0到100之间 </span></span><br><span class="line">	<span class="type">char</span> grade ; <span class="comment">//输出分数评级，由&#x27;A&#x27;到&#x27;E&#x27; </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;score ) ; <span class="comment">//输入分数 </span></span><br><span class="line">	<span class="keyword">switch</span>( score / <span class="number">10</span> ) </span><br><span class="line">	<span class="comment">//对分数除以十，即判断十位的情况，如80分到90，除以十为8 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>: </span><br><span class="line">			grade = <span class="string">&#x27;A&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>: </span><br><span class="line">			grade = <span class="string">&#x27;A&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;    </span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>: </span><br><span class="line">			grade = <span class="string">&#x27;B&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>: </span><br><span class="line">			grade = <span class="string">&#x27;C&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: </span><br><span class="line">			grade = <span class="string">&#x27;D&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			grade = <span class="string">&#x27;E&#x27;</span> ;</span><br><span class="line">			<span class="keyword">break</span> ;      </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Your grade is %c .\n&quot;</span> , grade ) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch</code> 语句也是可以嵌套的，但结构上比较繁琐。</p>
<p><br><br><br></p>
<h1><span id="vi-循环结构">Ⅵ —— 循环结构</span></h1><p>有时候用条件结构还是不能简便解决问题，还需要使用循环结构，如处理求多个整数的和、处理多个判断。</p>
<p>再如在输入的时候，我希望输入50个数字，我们可以复制粘贴50句 <code>scanf()</code> 来实现这个要求。学了循环之后，至少，不再需要50句语句。</p>
<p>需要注意的是， <strong>循环语句一定要设置终止条件，否则将进入死循环，无法得出结果！！！</strong></p>
<p>通过循环结构，可以完成一些简单的语法题，如判断一个数是否为素数，计算斐波那契数列，计算阶乘……</p>
<h2><span id="61-while构成的循环结构">6.1 while构成的循环结构</span></h2><p><code>while</code> 语句的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( condition is <span class="literal">true</span> ) </span><br><span class="line">&#123;</span><br><span class="line">	sentences;</span><br><span class="line">	……………………</span><br><span class="line">	<span class="comment">//花括号内的内容总称为循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处 <code>condition</code> 为表达式，只有当循环条件为真，即表达式为真，就执行循环体语句。循环体可以是一条语句，也可以是一个语句块（用花括号包起来）。 <code>while</code> 循环的特点是先判断条件表达式，后执行循环体语句。</p>
<p><code>while</code> 语句的运行顺序是：从上至下，先判断条件表达式是否为真，为真则执行循环体。循环体运行完后再次判断条件表达式，为真则执行循环体。一直循环直至判断条件表达式为假。</p>
<p>这里给出一个例子，求1到100的和，希望通过例子更好理解 <code>while</code> 循环：</p>
<p>分析此问题，将100个数相加，要重复进行100次加法，显然是需要循环结构介入。有兴趣的可以尝试画画流程图（此处不做介绍）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add-100-number.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件 </span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//初始化循环变量，从1开始 </span></span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//用来存求和的值 </span></span><br><span class="line">	<span class="keyword">while</span>(i &lt;= <span class="number">100</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		sum += i; <span class="comment">//相当于sum=sum+i，求和 </span></span><br><span class="line">		i ++; <span class="comment">//i自增，实现从1到2到3到……100 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum); <span class="comment">//输出求和的值 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>while</code> 括号里的 <code>condition</code> 条件表达式实际上也会被执行的，如果条件表达式是赋值语句（赋值成功则表达式为真）、自增自减等也会生效。</p>
<h2><span id="62-do-while构成的循环结构">6.2 do-while构成的循环结构</span></h2><p><code>do-while</code> 语句。其一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;</span><br><span class="line">	sentences;</span><br><span class="line">	……………………</span><br><span class="line">	<span class="comment">//花括号内的内容总称为循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span>(condition is <span class="literal">true</span>); <span class="comment">//注意这有一个分号</span></span><br></pre></td></tr></table></figure>

<p>此处 <code>condition</code> 为表达式，道理同上。 <code>do-while</code> 循环的特点是先无条件执行循环体，然后判断循环条件是否成立。即 <code>do-while</code> 循环至少进行一次循环，注意与 <code>while</code> 语句区分。</p>
<p><code>do-while</code> 语句的运行顺序是：从上至下，先无条件执行一次循环体，再判断条件表达式是否为真，为真则回到循环体开始重新执行循环体。循环体运行完后再次判断条件表达式，为真则执行循环体。一直循环直至判断条件表达式为假。</p>
<p>此处同样解决上面的问题，从1加到100求和。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add-100-number.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件 </span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//初始化循环变量，从1开始 </span></span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//用来存求和的值 </span></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		sum += i; <span class="comment">//相当于sum=sum+i，求和 </span></span><br><span class="line">		i ++; <span class="comment">//i自增，实现从1到2到3到……100 </span></span><br><span class="line">	&#125; <span class="keyword">while</span>(i &lt;= <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum); <span class="comment">//输出求和的值 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>while</code> 括号里的 <code>condition</code> 条件表达式实际上也会被执行的，如果条件表达式是赋值语句（赋值成功则表达式为真）、自增自减等也会生效。</p>
<h2><span id="63-for构成的循环结构">6.3 for构成的循环结构</span></h2><p><code>for</code> 语句的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( sentence1; condition; sentence2 )</span><br><span class="line">&#123;</span><br><span class="line">	sentences3</span><br><span class="line">	…………………………</span><br><span class="line">	<span class="comment">//花括号内的内容总称为循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处 <code>sentence1</code> 和 <code>sentence2</code> 为普通表达式， <code>sentence1</code> 只执行一次，而 <code>sentence2</code> 在每次执行完循环体后都会运行一次。 <code>condition</code> 为条件控制表达式，只有当循环条件为真，即表达式为真，就执行循环体语句。</p>
<p><code>for</code> 语句的运行顺序是：先进行一次 <code>sentence1</code> ，接着判断 <code>condition</code> 是否为真，为真则执行循环体。循环体运行完后执行 <code>sentence2</code> 。然后再次判断 <code>condition</code> ，一直循环直至条件为假。</p>
<p>所以延展出常用的 <code>for</code> 语句使用格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环变量赋值初始化; 循环条件; 循环变量变化)</span><br><span class="line">&#123;</span><br><span class="line">  循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做个补充，在老版本的C语言中， <code>sentence1</code> 不支持声明变量并同时初始化，如： <code>for(int i = 1; i &lt;= 100; i ++)</code> 。但是在C99版本后是允许的。</p>
<p>事实上， <code>for</code> 语句中的 <code>sentence1</code> 语句、 <code>sentence2</code> 语句和 <code>condition</code> 语句并非必要。即这三句语句可以省略，省略 <code>condition</code> 语句默认为真，写成 <code>for( ; ; )</code> ，但是两个分号绝不可少。在省略掉这三句语句时，我们仍要思考如何终止循环。例如在 <code>for</code> 语句上面就把变量初始化，在循环体中设置判断 <code>if</code> 什么条件就终止循环，在循环体中处理条件变化……</p>
<h2><span id="64-循环的终止与继续">6.4 循环的终止与继续</span></h2><ul>
<li>使用 <code>break</code> 语句终止循环。</li>
</ul>
<p>之前使用 <code>break</code> 语句，可能是条件结构中跳出 <code>switch</code> 语句。实际上， <code>break</code> 语句还可以用来跳出循环体，即终止循环。</p>
<p>以求1到100和的例子，假如我希望在和刚好大于等于2500的时候结束，并想知道此时是多少个数的和，那怎么实现呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use-break.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件 </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i ++) </span><br><span class="line">	&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">		<span class="keyword">if</span>(sum &gt;= <span class="number">2500</span>) <span class="comment">//当sum大于等于2500 </span></span><br><span class="line">		<span class="keyword">break</span>; <span class="comment">//终止所在的一层for循环 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d, and now i is %d\n&quot;</span>, sum, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以这样解决：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// use-for.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件 </span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; sum &lt; <span class="number">2500</span>; i ++) </span><br><span class="line">	&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d, and now i is %d\n&quot;</span>, sum, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释中我写到，终止 <code>break</code> 所在的一层 <code>for</code> 循环，因为当有多个循环嵌套时， <code>break</code> 不会终止所有的循环，而是一层循环。（可以自己做实验研究）</p>
<ul>
<li>使用 <code>continue</code> 语句跳过本次循环。</li>
</ul>
<p>有时候不希望终止整个循环，而是想结束这一次循环，还得执行下次循环。这时可以使用 <code>continue</code> 语句。</p>
<p>还是求1到100和的例子，但我希望求1到100中是偶数的和，那么奇数就没必要加进去，此时可以使用 <code>continue</code> 语句跳过本次循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find-the-sum-of-even-numbers-from-1-to-100.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//声明头文件 </span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i ++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>) <span class="comment">//当i为奇数，即除于2余数为1 </span></span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">//结束本次循环 </span></span><br><span class="line">		sum += i; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，结束本次循环并不是完全不进入循环，而是不执行 <code>continue</code> 下面的循环体部分。上面的代码，如果 <code>sum += i</code> 在 <code>continue</code> 的上面，结果还是会加上奇数的部分。</p>
<p><br><br><br></p>
<h1><span id="vii-枚举">Ⅶ —— 枚举</span></h1><p>枚举是C语言中的一种基本数据类型，用于定义一组具有离散值的常量。枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。</p>
<p>定义一个枚举类型，需要使用 <code>enum</code> 关键字，后面跟着枚举类型的名称，以及用大括号 <code>&#123;&#125;</code> 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从0开始递增。</p>
<p>枚举语法定义格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>

<p>举个例子，一周有7天，如果想将星期一映射为数字1，星期天映射为数字7，我们可以使用枚举。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// MON映射到1，后面的会自动递增</span></span><br><span class="line"><span class="comment">// 效果跟#define MON 1 等一样</span></span><br></pre></td></tr></table></figure>

<p>如果想让星期三之后特殊一些，星期三映射到8，星期天映射到12，只需在中间添加赋值即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	MON=<span class="number">1</span>, TUE, WED=<span class="number">8</span>, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// MON映射到1，TUE映射到2，WED映射到8，后面的会自动递增</span></span><br></pre></td></tr></table></figure>

<p>使用时直接输出即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, MON);</span><br></pre></td></tr></table></figure>

<p>然而上面是对枚举类型的使用，下面介绍枚举变量的定义和使用。</p>
<p>枚举类型是一种数据类型，可以对标 <code>int</code> 理解；枚举变量是一个变量，可以对标 <code>int number</code> 中的 <code>number</code> 理解。</p>
<p>可以通过三种方式定义枚举变量：</p>
<ol>
<li>先定义枚举类型，再定义枚举变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义枚举类型的同时定义枚举变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>省略枚举名称，直接定义枚举变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure>

<p>给出使用枚举变量的情形：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br><span class="line">    day = WED;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>枚举类型值连续</strong> 的情况下还可以进行循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遍历枚举元素</span></span><br><span class="line">    <span class="keyword">for</span> (day = MON; day &lt;= SUN; day++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;枚举元素：%d \n&quot;</span>, day);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将将整数转换为现有枚举值，只需强制类型转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">day</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        saturday, sunday, monday, tuesday, wednesday, thursday, friday</span><br><span class="line">    &#125; workday;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">weekend</span>;</span></span><br><span class="line">    weekend = ( <span class="keyword">enum</span> day ) a;  <span class="comment">//类型转换</span></span><br><span class="line">    <span class="comment">//weekend = a; //错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,weekend);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><br><br><br></p>
<h1><span id="viii-数组">Ⅷ —— 数组</span></h1><p>数组是一种可以存储固定大小的相同类型元素的顺序集合。简单来说，数组可以存放一串相同的数据类型。</p>
<h2><span id="81-数组结构">8.1 数组结构</span></h2><p>数组的结构如下图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_array.png" alt="数组的结构"></p>
<p>数组的每一个单体称作 <strong>元素</strong> ，每个元素有它的 <strong>索引号</strong> ，用于访问该元素。 <strong>索引号从0开始。</strong></p>
<h2><span id="82-数组的定义和访问">8.2 数组的定义和访问</span></h2><p>数组的定义十分简单，其定义格式是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type arrayName [arraySize];</span><br></pre></td></tr></table></figure>

<p>如 <code>int array[5];</code> 就定义了一个大小为5的整型数组，数组名为array，它可以存放5个整型数据，索引号从0到4。</p>
<p>访问数组时直接使用 <code>arrayName[index]</code> 的方式进行，如 <code>array[0]</code> 就是array数组的第一个元素的值。使用循环还可以将数组的内容输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 访问数组并赋值</span></span><br><span class="line">   	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</span><br><span class="line">   		<span class="built_in">array</span>[i] = i + <span class="number">1</span>;</span><br><span class="line">   	</span><br><span class="line">   	<span class="comment">// 访问数组并输出</span></span><br><span class="line">   	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</span><br><span class="line">   		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>补充个冷知识，我们比较经常使用 <code>array[0]</code> 访问元素，实际上还能以 <code>0[array]</code> 的方式访问元素。</p>
<h2><span id="83-数组的初始化">8.3 数组的初始化</span></h2><p>通过上面的例子，我们可以通过循环给数组中的每个元素赋值。但是还可以通过声明时的初始化语句进行相同的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>大括号 <code>&#123; &#125;</code> 之间的值的数目不能大于我们在数组声明时在方括号 <code>[ ]</code> 中指定的元素数目。如果省略掉了数组的大小，数组的大小则为初始化时元素的个数。即等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="84-多维数组">8.4 多维数组</span></h2><p>C 语言支持多维数组。多维数组声明的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type name[size1][size2]...[sizeN];</span><br></pre></td></tr></table></figure>

<p>下面以二维数组作为示例。一个二维数组，在本质上，是一个元素为一维数组的数组。定义形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type arrayName [x][y];</span><br></pre></td></tr></table></figure>

<p>如一个二维数组初始化如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">4</span>] = &#123;  </span><br><span class="line"> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; ,   <span class="comment">/*  初始化索引号为 0 的行 */</span></span><br><span class="line"> &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125; ,   <span class="comment">/*  初始化索引号为 1 的行 */</span></span><br><span class="line"> &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;   <span class="comment">/*  初始化索引号为 2 的行 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_array2.png" alt="二维数组"></p>
<p>二维数组中的元素是通过使用下标（即数组的行索引和列索引）访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 一个带有 5 行 2 列的数组</span></span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">4</span>&#125;, &#123;<span class="number">3</span>,<span class="number">6</span>&#125;,&#123;<span class="number">4</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 输出数组中每个元素的值</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a[%d][%d] = %d\n&quot;</span>, i, j, a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="85-数组的使用">8.5 数组的使用</span></h2><ul>
<li>求数组长度：使用 <code>sizeof</code> 关键字，将整个数组占的内存大小除以每个元素占的内存大小，得到的就是元素个数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> numbers[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(numbers[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li>将数组作为函数参数传入</li>
</ul>
<ol>
<li>形式参数是一个已定义大小的数组</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> param[<span class="number">10</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>形式参数是一个未定义大小的数组</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> param[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了函数的通用性，通常使用未定义大小的数组，再将数组大小作为第二参数传入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getAverage</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> <span class="comment">// 求数组的平均值</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">double</span> avg;</span><br><span class="line">	<span class="type">double</span> sum;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	avg = sum / size;</span><br><span class="line">	<span class="keyword">return</span> avg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，我们传入的是数组，在函数内部中如若有对数组元素的修改，也会同步对外部的数组进行修改。因为此处形式参数是以地址传递的形式传入。</p>
<p>为什么传递数组名字会是以地址传递的形式传入呢？那是因为 <strong>数组名实际上是一个指针</strong> ，它存放数组中首元素的地址。至于什么是指针，可查阅下一节。</p>
<p><br><br><br></p>
<h1><span id="ix-指针">Ⅸ —— 指针</span></h1><p>指针是C语言很重要的一环。</p>
<p>数据都有一个内存空间，内存空间都有一个地址，我们形象地把这个地址称为指针。指针也就是内存地址，指针变量是用来存放内存地址的变量。</p>
<h2><span id="91-指针变量的定义">9.1 指针变量的定义</span></h2><p>指针变量定义的一般形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type *var_name;</span><br></pre></td></tr></table></figure>

<p><code>type</code> 是指针的基类型，它必须是一个有效的数据类型， <code>var_name</code> 是指针变量的名称。用来声明指针的星号 <code>*</code> 与乘法中使用的星号是相同的，但在此处的意义是标记改变量是指针变量，称为指针运算符。一个指针对应一个 <code>*</code> 。</p>
<p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个 <strong>代表内存地址的长的十六进制数</strong> 。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>
<p>当我们需要取一个变量的地址时，我们需要加 <code>&amp;</code> （取地址符）；当我们需要取一个指针的数据时，我们需要加 <code>*</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *pa = &amp;a;</span><br></pre></td></tr></table></figure>

<p>之前使用 <code>scanf()</code> 函数时所加的 <code>&amp;</code> ，表明我们是把数据放到某变量名所处的地址，而不是塞到变量名里面。</p>
<p>如果想输出地址的话，可以使用 <code>%p</code> 或 <code>%x</code> 输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;a);</span><br></pre></td></tr></table></figure>

<p>指针使用前必须有初始化值，即定义时必须赋值，若无值则指向NULL。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>如果使用前没有初始化值时，该指针会变成 <strong>野指针</strong> ，指针指向了一块随机的空间，不受程序控制。有可能是系统重要软件的地址，贸然使用可能使得系统崩溃。</p>
<h2><span id="92-指针的运算">9.2 指针的运算</span></h2><ul>
<li><p>指针之间不能进行 <code>+</code> 运算，无意义。</p>
</li>
<li><p>指针进行 <code>&lt;</code> 运算时，表示实际内存高低位的比较；</p>
</li>
<li><p>指针进行 <code>=</code> 运算时，表示把右边的地址赋值给左边；</p>
</li>
<li><p>指针进行 <code>-</code> 运算时，表示在两指针之间相隔相同类型元素的个数。</p>
</li>
<li><p>指针进行 <code>++</code> 运算时，表示在指针递增，会指向下一个元素的存储单元。指针在递增时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</p>
</li>
<li><p>指针进行 <code>--</code> 运算时，表示在指针递减，会指向上一个元素的存储单元。指针在递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</p>
</li>
</ul>
<h2><span id="93-指针的使用">9.3 指针的使用</span></h2><ul>
<li>指针间接访问变量</li>
</ul>
<p>通过指针输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> *pointer1, *pointer2;</span><br><span class="line">	pointer1 = &amp;a;</span><br><span class="line">	pointer2 = &amp;b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>, a, b); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pointer1=%d,pointer2=%d\n&quot;</span>, pointer1, pointer2); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;pointer1=%d,pointer2=%d\n&quot;</span>, *pointer1, *pointer2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">a=100,b=10</span><br><span class="line">pointer1=6422216,pointer2=6422220</span><br><span class="line">pointer1=100,pointer2=10</span><br></pre></td></tr></table></figure>

<p>通过指针将两个变量存放的值交换，用地址传递实现存储空间上的交换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap-ab.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	tmp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>, x, y);</span><br><span class="line">	swap(&amp;x, &amp;y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\n&quot;</span>, x, y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">x=1,y=2</span><br><span class="line">x=2,y=1</span><br></pre></td></tr></table></figure>

<ul>
<li>指针引用一维数组</li>
</ul>
<p>数组名即是该数组首元素（即序号为0的元素）的地址。所以我们可以直接用指针指向数组名，无需取地址符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure>

<p>同时，我们可以对数组首元素进行取地址，即下代码等价：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = a;      <span class="comment">//p指向数组首元素的地址，即a[0]的地址；</span></span><br><span class="line">p = &amp;a[<span class="number">0</span>];  <span class="comment">//p指向a[0]的地址</span></span><br></pre></td></tr></table></figure>

<p>当我们正确把指针指向一个数组的时候，可以对指针进行以下运算： <code>p++</code> , <code>++p</code> , <code>p--</code> , <code>--p</code> , <code>p = p + 1</code> , <code>p = p - 1</code> 等。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_pointer.png" alt="指针访问数组"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">104</span>,<span class="number">105</span>&#125;;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">	p = a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(p+<span class="number">2</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line"><span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br></pre></td></tr></table></figure>

<p>因为数组名也有地址的属性，所以输出语句还可以改成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(a+<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>但数组名不能进行自增自减，如不能 <code>a++</code> 或 <code>a--</code> 等。</p>
<p>指针还可以引用字符串（字符数组），字符串的本质是一个字符数组。我们可以类似指针引用一维数组那样引用字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> a[] = <span class="string">&quot;computer!&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *p);  <span class="comment">//%c，取*时，具体到某个元素，此处是首元素</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *(p + <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);  <span class="comment">//%s，不取*，从首元素输出所有字符</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p + <span class="number">2</span>);  <span class="comment">// 从a[2]开始输出所有字符</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">输出结果：</span><br><span class="line">c</span><br><span class="line">m</span><br><span class="line">computer!</span><br><span class="line">mputer!</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以上也可用字符指针变量表示，如下所示：</span></span><br><span class="line"><span class="type">char</span> *p=<span class="string">&quot;computer!&quot;</span>;<span class="comment">//此处可能会出现warning，但无关紧要</span></span><br><span class="line"><span class="comment">//上句等价于char *p; p=&quot;computer!&quot;;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,p);<span class="comment">//此处无需*p，注意对比</span></span><br></pre></td></tr></table></figure>

<p><code>char *p=&quot;computer!&quot;</code> 的意思是将字符指针变量 <code>p</code> 指到”computer!”的首地址即”c”的地址。</p>
<p>之前，我们用字符数组也能实现打印字符串，而使用字符指针的不同是：</p>
<p>①可以对字符指针变量赋值，但不能对数组名赋值，初始化不等于赋值，如不能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>] = &#123;<span class="string">&quot;computer!&quot;</span>&#125;; <span class="comment">//此句合法</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">10</span>]; </span><br><span class="line">a = <span class="string">&quot;computer!&quot;</span>; <span class="comment">//此句不合法</span></span><br></pre></td></tr></table></figure>

<p>②储存内容不同，字符数组把每一个元素的值都存放，而字符指针只存放第一个元素的地址。</p>
<ul>
<li>指针指向二维数组</li>
</ul>
<p>二维数组有两个下标，那么一个指针怎么指，我们将指针分为 <strong>行指针</strong> 和 <strong>列指针</strong> 。行指针，即指向某一行元素的指针；列指针，即指向某一列元素的指针。</p>
<p>下有二维数组 <code>a[4][5]</code> ：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_pointer2.png" alt="指针指向二维数组"></p>
<ul>
<li>动态数组</li>
</ul>
<p>像 <code>int a[5];</code> 这样的定义数组，我们称之为 <strong>静态数组</strong> 。在程序编译时，静态数组的内存空间就被分配好了，存储在栈上或者全局数据区。静态数组的大小在声明时确定且无法在运行时改变。静态数组的生命周期与其作用域相关。如果在函数内部声明静态数组，其生命周期为整个函数执行期间；如果在函数外部声明静态数组，其生命周期为整个程序的执行期间。</p>
<p><strong>动态数组</strong> 是在运行时通过动态内存分配函数（如 <code>malloc</code> 和 <code>calloc</code> ）手动分配内存的数组。动态数组的内存空间在运行时通过动态内存分配函数手动分配，并存储在堆上。需要使用 <code>malloc</code> 、 <code>calloc</code>  等函数来申请内存，并使用 <code>free</code> 函数来释放内存。动态数组的大小在运行时可以根据需要进行调整。可以使用 <code>realloc</code> 函数来重新分配内存，并改变数组的大小。动态数组的生命周期由程序员控制。需要在使用完数组后手动释放内存，以避免内存泄漏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *dynamicArray = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态数组内存分配</span></span><br><span class="line"><span class="comment">// 使用动态数组</span></span><br><span class="line"><span class="built_in">free</span>(dynamicArray); <span class="comment">// 动态数组内存释放</span></span><br></pre></td></tr></table></figure>

<ul>
<li>数组指针</li>
</ul>
<p>数组指针，其本质是指针，指向一个一维数组的指针。所以定义时，由运算符优先级，我们需要带上小括号</p>
<p>定义数组指针： <code>类型名 (*指针变量名)[长度];</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">4</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">		<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,</span><br><span class="line">		<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,</span><br><span class="line">		<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,</span><br><span class="line">		<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>&#125;;</span><br><span class="line">	<span class="type">int</span> (*p)[<span class="number">5</span>];</span><br><span class="line">	p = a+<span class="number">1</span>; <span class="comment">// 指向第2行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,(*p)[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">6 7 8 9 10</span><br></pre></td></tr></table></figure>

<ul>
<li>指针数组</li>
</ul>
<p>指针数组，其本质是数组，是一个元素均为指针类型的数组。</p>
<p>定义指针数组： <code>类型名 *数组名[长度];</code></p>
<p>举例：（将数字转化为对应的英文月份）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *p[<span class="number">13</span>];</span><br><span class="line">	p[<span class="number">1</span>]=<span class="string">&quot;Januray&quot;</span>;  p[<span class="number">2</span>]=<span class="string">&quot;February&quot;</span>;  p[<span class="number">3</span>]=<span class="string">&quot;March&quot;</span>; </span><br><span class="line">	p[<span class="number">4</span>]=<span class="string">&quot;April&quot;</span>;  p[<span class="number">5</span>]=<span class="string">&quot;May&quot;</span>;      p[<span class="number">6</span>]=<span class="string">&quot;June&quot;</span>;</span><br><span class="line">	p[<span class="number">7</span>]=<span class="string">&quot;July&quot;</span>;  p[<span class="number">8</span>]=<span class="string">&quot;August&quot;</span>;    p[<span class="number">9</span>]=<span class="string">&quot;September&quot;</span>;</span><br><span class="line">	p[<span class="number">10</span>]=<span class="string">&quot;October&quot;</span>;p[<span class="number">11</span>]=<span class="string">&quot;November&quot;</span>;  p[<span class="number">12</span>]=<span class="string">&quot;December&quot;</span>;</span><br><span class="line">	<span class="comment">//可能会警告，但无关紧要</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">3 	// 输入</span><br><span class="line">March 	// 输出</span><br></pre></td></tr></table></figure>

<ul>
<li>指向函数的指针</li>
</ul>
<p>函数名也代表函数的起始地址。</p>
<p>此内容直接看以下例子——比较两个数字的大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (x &gt; y ? x : y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">50</span>, b = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;max=%d&quot;</span>, max(a, b));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上代码等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (x &gt; y ? x : y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">50</span>, b = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">	p = max;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;max=%d&quot;</span>, (*p)(a,b));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>int (*p)(int,int)</code>；定义指向函数的指针变量： <code>类型名 (* 指针变量名)(函数参数表列);</code></p>
<p>指向函数的指针变量的一个重要用途是把函数的入口地址作为参数传递到其他函数，下附一个使用函数指针的例子；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ans;</span><br><span class="line">	ans = (*p)(x,y);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;max=&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;min=&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">34</span>, b = <span class="number">-21</span>, n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你的选择(1-求最大值，2-求最小值)：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)  fun(a, b, max);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>)  fun(a, b, min);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回指针类型的函数</li>
</ul>
<p>定义返回指针值得函数形式为： <code>类型名* 函数名(参数表列);</code></p>
<p>依然是使用一个例子：对若干学生成绩，找出不合格得课程得学生及其学生号，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span>* <span class="title function_">search</span><span class="params">(<span class="type">float</span> (*pointer)[<span class="number">4</span>])</span><span class="comment">//定义函数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">float</span> *pt;</span><br><span class="line">	pt = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//切记初始化指针，无则指向NULL</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(*(*pointer+i)&lt;<span class="number">60</span>)  pt = *pointer;</span><br><span class="line">		<span class="comment">//如有不及格，使pt指向score[i][0]</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> score[][<span class="number">4</span>] = &#123;&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;,&#123;<span class="number">56</span>,<span class="number">89</span>,<span class="number">67</span>,<span class="number">88</span>&#125;,&#123;<span class="number">34</span>,<span class="number">78</span>,<span class="number">90</span>,<span class="number">66</span>&#125;&#125;;</span><br><span class="line">	<span class="comment">//定义数组，初始化成绩，有3名学生，每名学生有4门成绩</span></span><br><span class="line">	<span class="type">float</span> *p;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = search(score + i);</span><br><span class="line">		<span class="comment">//调用search函数，如不及格则返回score[i][0]的地址</span></span><br><span class="line">		<span class="comment">//否则返回NULL</span></span><br><span class="line">		<span class="keyword">if</span>(p == *(score+i))  <span class="comment">//若返回的不是NULL，则输出学生成绩</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;No.%d score:&quot;</span>,i);</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%5.2f &quot;</span>, *(p+j));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>指向指针数据的指针变量</li>
</ul>
<p>指向指针数据的指针，可以嵌套，如： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> *p;</span><br><span class="line">	p = &amp;a;</span><br><span class="line">	<span class="type">int</span> **q;</span><br><span class="line">	q = &amp;p;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, **q);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<p><br><br><br></p>
<h1><span id="x-共用体与结构体">Ⅹ —— 共用体与结构体</span></h1><h2><span id="101-共用体">10.1 共用体</span></h2><p><strong>共用体（Union）</strong> 是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。</p>
<p>为了定义共用体，必须使用 <code>union</code> 语句。 <code>union</code> 语句定义了一个新的数据类型，带有多个成员。定义格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> [<span class="title">union</span> <span class="title">tag</span>]</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	成员定义;</span><br><span class="line">	成员定义;</span><br><span class="line">	...</span><br><span class="line">	成员定义;</span><br><span class="line">&#125; 共用体变量;</span><br></pre></td></tr></table></figure>

<p><code>union tag</code> 是可选的，每个 <code>成员定义</code> 是标准的变量定义，比如 <code>int i;</code> 或者 <code>float f;</code> 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，可以指定一个或多个共用体变量，这是可选的。</p>
<p>下面定义一个名为 <code>Data</code> 的共用体类型，有三个成员 <code>i</code> 、 <code>f</code> 和 <code>str</code> ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">	<span class="type">char</span>  str[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以像枚举类型定义枚举类型的同时定义枚举变量一样，定义共用体类型的同时定义共用体变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">	<span class="type">char</span>  str[<span class="number">10</span>];</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure>

<p><code>Data</code> 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。</p>
<p><strong>共用体占用的内存应足够存储共用体中最大的成员。</strong> 例如，在上面的实例中，<code>Data</code> 将占用10个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。</p>
<p>使用共用体时，我们需要先创建共用体类型变量，再根据变量访问成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br></pre></td></tr></table></figure>

<p>为了访问共用体的成员，使用成员访问运算符 <code>.</code> ，如 <code>data.i</code> 、 <code>data.f</code> 、 <code>data.str</code> ，但是在同一时间只能使用一个成员。</p>
<h2><span id="102-结构体">10.2 结构体</span></h2><p><strong>结构体</strong> 与共用体类似，不同的是结构体的成员并列存在，可同时使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	成员定义;</span><br><span class="line">	成员定义;</span><br><span class="line">	...</span><br><span class="line">	成员定义;</span><br><span class="line">&#125; 结构体变量;</span><br></pre></td></tr></table></figure>

<p><code>tag</code> 是结构体标签，每个 <code>成员定义</code> 是标准的变量定义，比如 <code>int i;</code> 或者 <code>float f;</code> 或者其他有效的变量定义。在结构体定义的末尾，最后一个分号之前，可以指定一个或多个结构体变量，这是可选的。</p>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//同时又声明了结构体变量s1</span></span><br><span class="line"><span class="comment">//这个结构体并没有标明其标签</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">double</span> c;</span><br><span class="line">&#125; s1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//结构体的标签被命名为SIMPLE,没有声明变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">t1</span>, <span class="title">t2</span>[20], *<span class="title">t3</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用typedef创建新类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">double</span> c; </span><br><span class="line">&#125; Simple2;</span><br><span class="line"><span class="comment">//现在可以用Simple2作为类型声明新的结构体变量</span></span><br><span class="line">Simple2 u1, u2[<span class="number">20</span>], *u3;</span><br></pre></td></tr></table></figure>

<p>第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 <code>t3=&amp;s1</code> ，则是非法的。</p>
<p>如果将结构体与基本数据类型做对比的话，举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">double</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tag</span> <span class="title">b</span>；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">typedef</span> <span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> number;</span><br><span class="line">&#125; Tag2;</span><br><span class="line">Tag2 c;</span><br></pre></td></tr></table></figure>

<p>那么 <code>int</code> 、 <code>struct Tag</code> 、 <code>Tag2</code> 是对等的，都是数据类型；而 <code>a</code> 、 <code>b</code> 和 <code>c</code> 是同级的，都是变量。 </p>
<p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针。如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span>    <span class="comment">//对结构体B进行不完整声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体A中包含指向结构体B的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了访问结构的成员，使用成员访问运算符 <code>.</code> 。对于结构体的初始化，可以使用 <code>&#123;&#125;</code> ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//book.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   	<span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   	<span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   	<span class="type">int</span>   book_id;</span><br><span class="line">&#125; book = &#123;<span class="string">&quot;C 语言&quot;</span>, <span class="string">&quot;RUNOOB&quot;</span>, <span class="string">&quot;编程语言&quot;</span>, <span class="number">123456</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;</span>, book.title, book.author, book.subject, book.book_id);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体作为函数的参数传入时，传参方式与其他类型的变量或指针类似，如： <code>void printBooks(struct Books b);</code> ，之后在函数里访问成员即可。</p>
<p>可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">struct_pointer</span>;</span></span><br><span class="line">struct_pointer = &amp;Book1;</span><br><span class="line">struct_pointer-&gt;title; <span class="comment">// 指针访问成员时</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，使用指向该结构的指针访问结构的成员时，必须使用 <code>-&gt;</code> 运算符。</p>
<p>使用 <code>sizeof</code> 运算符来计算结构体的大小，这在使用链表时有帮助。</p>
<p><br><br><br></p>
<h1><span id="xi-链表">Ⅺ —— 链表</span></h1><h2><span id="111-链表及其构成">11.1 链表及其构成</span></h2><p><strong>链表</strong>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。而这些储存单元需要及时开辟，此时需要使用动态储存分配函数。</p>
<p><strong>链表</strong>由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的 <strong>数据域</strong> ，另一个是存储下一个结点地址的 <strong>指针域</strong> 。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> num;		<span class="comment">// 数据域</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">5</span>];		<span class="comment">// 数据域</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">next</span>;</span> 	<span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>链表还可分为动态链表和静态链表，此处不讨论静态链表，均为动态链表。</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>
<p>链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_arrayandlist.png" alt="链表与数组"></p>
<h2><span id="112-内存管理的函数">11.2 内存管理的函数</span></h2><p>关于动态储存分配函数有 <code>calloc()</code> 、 <code>malloc()</code> 、 <code>free()</code> 、 <code>realloc()</code> 。他们都存在于 <code>stdlib.h</code> 头文件中。</p>
<p>有的编译系统要求用 <code>malloc.h</code> 头文件而不是 <code>stdlib.h</code> 头文件，实际上这两个头文件都包含以上的动态储存分配函数。</p>
<p>除 <code>free()</code> 函数，其他函数都会返回一定的地址，需要对地址进行强制类型转换，转换为我们所需的数据类型。</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">函数原型</th>
<th align="center">功能</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>calloc()</code></td>
<td align="center"><code>void *calloc(unsigned n, unsign size)</code></td>
<td align="center">分配n个大小为size的内存连续空间</td>
<td align="center">成功时返回分配内存的起始地址，不成功返回0</td>
</tr>
<tr>
<td align="center"><code>malloc()</code></td>
<td align="center"><code>void *calloc(unsigned size)</code></td>
<td align="center">分配1个大小为size的储存区</td>
<td align="center">成功时返回分配内存起始地址，内存不足返回0</td>
</tr>
<tr>
<td align="center"><code>free()</code></td>
<td align="center"><code>void free(void *p)</code></td>
<td align="center">释放p所指的内存区</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center"><code>realloc()</code></td>
<td align="center"><code>void *calloc(viod *p, unsigned isze)</code></td>
<td align="center">将p所指的已分配内存区大小改为size，size可大于或小于原来大小</td>
<td align="center">返回指向该内存的指针</td>
</tr>
</tbody></table>
<h2><span id="113-单向链表">11.3 单向链表</span></h2><p><strong>单向链表</strong>，指针指向单向，连接方向单向，优点是简单，缺点是效率略低。</p>
<p>单向链表是由结点构成，所讨论的单向链表结点如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>链表的创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表创建，返回一个表头head</span></span><br><span class="line"><span class="keyword">struct</span> test *<span class="title function_">creat</span><span class="params">()</span>  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">p1</span>, *<span class="title">p2</span>;</span></span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	p1 = p2 = (<span class="keyword">struct</span> test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> test));  <span class="comment">//开辟一个内存单元</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p1-&gt;num);  <span class="comment">//输入第一个信息</span></span><br><span class="line">	head = <span class="literal">NULL</span>;  <span class="comment">//指针必须初始化，无地址则指向NULL</span></span><br><span class="line">	<span class="keyword">while</span>(p1-&gt;num != <span class="number">0</span>) <span class="comment">// 设计当输入0时停止创建链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		n += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>)  head = p1; <span class="comment">// 当链表为空，即创建的是第一个结点，则使头结点指向p1的地址</span></span><br><span class="line">		<span class="keyword">else</span>  p2-&gt;next = p1;	<span class="comment">// 当链表非空，用next指针连接</span></span><br><span class="line">		p2 = p1; <span class="comment">// p2指向p1所指的地址，p2为当前链表末尾</span></span><br><span class="line">		p1 = (<span class="keyword">struct</span> test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> test));  <span class="comment">//再开辟内存单元，并将起始地址赋值给p1</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p1-&gt;num);   <span class="comment">//循环输入信息</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(p1); <span class="comment">// 释放最后一个结点，即释放输入为0的结点</span></span><br><span class="line">	p2-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 链表的末尾指向NULL</span></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述代码，演示过程如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_create.png" alt="链表创建过程"></p>
<ul>
<li>链表的插入</li>
</ul>
<p>链表的插入思路如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_insert.png" alt="链表的插入"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在某链表中插入一个新的由指针引用的结构体</span></span><br><span class="line"><span class="keyword">struct</span> test *<span class="title function_">add</span><span class="params">(<span class="keyword">struct</span> test *head, <span class="keyword">struct</span> test *insert)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">p0</span>, *<span class="title">p1</span>, *<span class="title">p2</span>;</span></span><br><span class="line">	p0 = insert;  <span class="comment">//将新的由指针引用的结构体赋值给p0</span></span><br><span class="line">	p1 = head;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>)<span class="comment">//判断是否为空链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		head = p0;  <span class="comment">//是空链表则从头插入，头指针为p0</span></span><br><span class="line">		p0-&gt;next = <span class="literal">NULL</span>;<span class="comment">//后面无新的数据</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>    <span class="comment">//链表非空，按num排序，找到适合的位置或者到链表末端停下</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>((p0-&gt;num &gt; p1-&gt;num) &amp;&amp; (p1-&gt;next != <span class="literal">NULL</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			p2=p1;</span><br><span class="line">			p1=p1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(p0-&gt;num &lt;= p1-&gt;num) <span class="comment">// 找到合适的位置</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(head == p1) head = p0;</span><br><span class="line">			<span class="keyword">else</span>  p2-&gt;next = p0;</span><br><span class="line">			p0-&gt;next = p1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">// 找不到合适位置，插入到链表末尾</span></span><br><span class="line">		&#123;</span><br><span class="line">			p1-&gt;next = p0;</span><br><span class="line">			p0-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;		</span><br><span class="line">	<span class="keyword">return</span> head; <span class="comment">// 返回更新后的链表表头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>链表的删除</li>
</ul>
<p>链表的删除思路如图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_delete.png" alt="链表的删除"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在某链表中查找num并删除该结构体，返回更新后的表头</span></span><br><span class="line"><span class="keyword">struct</span> test *<span class="title function_">del</span><span class="params">(<span class="keyword">struct</span> test *head, <span class="type">int</span> num)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">p1</span>, *<span class="title">p2</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>)  <span class="comment">// 判断是否为空链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这是一个空链表\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;  </span><br><span class="line">	</span><br><span class="line">	p1 = head;</span><br><span class="line">	<span class="comment">// 链表非空，将创建好的链表头指针head赋值给p1</span></span><br><span class="line">	<span class="comment">// 不能直接对表头进行操作，否则变动完之后找不到表头</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 当没匹配到元素或者已经到链表末端，停止循环</span></span><br><span class="line">	<span class="keyword">while</span>(p1-&gt;num != num &amp;&amp; p1-&gt;next != <span class="literal">NULL</span>)  </span><br><span class="line">	&#123;</span><br><span class="line">		p2 = p1;		<span class="comment">// p2指向的是p1的前一个结点</span></span><br><span class="line">		p1 = p1-&gt;next;		<span class="comment">// p1指针遍历链表</span></span><br><span class="line">	&#125; <span class="comment">// 此处寻找元素</span></span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span>(p1-&gt;num == num)  <span class="comment">// 如果是找到了元素而停止循环的情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p1 == head)</span><br><span class="line">		&#123;</span><br><span class="line">			head = p1-&gt;next;<span class="comment">// 如果删除的是头指针，则将头指针指向下一个，修改表头</span></span><br><span class="line">			<span class="built_in">free</span>(p1);</span><br><span class="line">		&#125;  </span><br><span class="line">			</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p2-&gt;next = p1-&gt;next;  <span class="comment">// 删除节点，即跳过某结构体直接连向下一个</span></span><br><span class="line">			<span class="built_in">free</span>(p1);</span><br><span class="line">		&#125;  </span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Not found!&quot;</span>);   <span class="comment">// 到链表末端而停止循环的情况，也就是没找到</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> head;	<span class="comment">// 返回修改后的表头</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>链表的查找</li>
</ul>
<p>思路简单，自行理解代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在链表中查找值为obj的结构体，找到返回该结构体的指针，找不到返回NULL</span></span><br><span class="line"><span class="keyword">struct</span> test *<span class="title function_">find</span><span class="params">(<span class="keyword">struct</span> test *head, <span class="type">int</span> obj)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">p</span>, *<span class="title">res</span> =</span> <span class="literal">NULL</span>; <span class="comment">// res作为返回的结构体</span></span><br><span class="line">	<span class="keyword">if</span>(head == <span class="literal">NULL</span>)	<span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 链表为空返回空</span></span><br><span class="line">	</span><br><span class="line">	p = head;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>) <span class="comment">// 遍历链表</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;num == obj) <span class="comment">// 找到目标</span></span><br><span class="line">		&#123;</span><br><span class="line">			res = p;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next; <span class="comment">// 往下顺延</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>链表的输出</li>
</ul>
<p>思路简单，自行理解代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// while循环输出链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="keyword">struct</span> test *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">p</span>;</span></span><br><span class="line">	p = head;</span><br><span class="line">	<span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;num);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="114-双向链表">11.4 双向链表</span></h2><p><strong>双向链表</strong>，指针指向双向，连接方向双向。</p>
<p>双向链表是由结点构成，所讨论的双向链表结点如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">next</span>;</span>	<span class="comment">// 指向后一个结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">test</span> *<span class="title">pre</span>;</span>	<span class="comment">// 指向前一个结构体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>双向链表结构如下图：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_dlist.png" alt="双向链表"></p>
<p>至于双向链表的创建，插入，删除，查找，不详细介绍。多一个方向的指针使得该链表可以往前遍历，提高其方便性。</p>
<h2><span id="115-循环链表">11.5 循环链表</span></h2><p>循环链表的首位是相接的，构成一个环。所以还可以分成单向循环链表和双向循环链表。</p>
<ul>
<li>循环单向链表</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_clist.png" alt="循环单向链表"></p>
<ul>
<li>循环双向链表</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/c_cdlist.png" alt="循环双向链表"></p>
<p><br><br><br></p>
<h1><span id="xii-对文件的读写">Ⅻ —— 对文件的读写</span></h1><h2><span id="121-打开文件">12.1 打开文件</span></h2><p>可以使用 <code>fopen()</code> 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 <code>FILE</code> 的一个对象，类型 <code>FILE</code> 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure>

<p>函数的第一参数是打开的文件名，常量字符指针类型，也能看成字符串类型；第二参数是打开文件的模式，有如下模式：</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>r</code></td>
<td align="center">打开一个已有的文本文件，允许读取文件</td>
</tr>
<tr>
<td align="center"><code>r+</code></td>
<td align="center">打开一个已有的文本文件，允许读写文件</td>
</tr>
<tr>
<td align="center"><code>w</code></td>
<td align="center">打开一个文本文件，允许写入。若文件不存在将新建文件，若文件存在则覆盖原有内容重新写入</td>
</tr>
<tr>
<td align="center"><code>w+</code></td>
<td align="center">打开一个文本文件，允许读写。若文件不存在将新建文件，若文件存在则覆盖原有内容重新写入</td>
</tr>
<tr>
<td align="center"><code>a</code></td>
<td align="center">打开一个文本文件，允许写入。若文件不存在将新建文件，若文件存在则在原有内容上追加写入</td>
</tr>
<tr>
<td align="center"><code>a+</code></td>
<td align="center">打开一个文本文件，允许读写。若文件不存在将新建文件，若文件存在则在原有内容上追加写入</td>
</tr>
</tbody></table>
<p>如果是处理二进制文件的情况，则在原来的基础上加上 <code>b</code> ，如： <code>rb</code> ， <code>wb</code> ， <code>ab</code> ， <code>rb+</code> ， <code>r+b</code> ， <code>wb+</code> ， <code>w+b</code> ， <code>ab+</code> ， <code>a+b</code> 。</p>
<p><strong>打开文件处理完成之后记得关闭文件</strong>，使用 <code>fclose()</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>

<p>如果成功关闭文件， <code>fclose()</code> 函数返回零，如果关闭文件时发生错误，函数返回  <code>EOF</code> 。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。 <code>EOF</code> 是一个定义在头文件 <code>stdio.h</code> 中的常量，上述打开文件函数和关闭文件函数也都在 <code>stdio.h</code> 头文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp;	<span class="comment">// 文件对象</span></span><br><span class="line">	fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>); <span class="comment">// 打开文件并把文件指针绑定到该文件</span></span><br><span class="line">	fclose(fp); <span class="comment">// 关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="122-写入文件">12.2 写入文件</span></h2><ul>
<li>函数 <code>fputc()</code> ：把参数 <code>c</code> 的字符值写入到 <code>fp</code> 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <code>EOF</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *fp)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数 <code>fputs()</code> ：把字符串 <code>s</code> 写入到 <code>fp</code> 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <code>EOF</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *fp)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数 <code>fprintf</code> ：把一个字符串写入到文件中。该函数形式与 <code>printf</code> 函数类似，参考 <code>printf</code> 函数使用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *fp,<span class="type">const</span> <span class="type">char</span> *format, ...)</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两函数比较</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%d&quot;</span>, a, b);</span><br><span class="line"><span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d %d&quot;</span>, a, b);</span><br></pre></td></tr></table></figure>

<h2><span id="123-读取文件">12.3 读取文件</span></h2><ul>
<li>函数 <code>fgetc()</code> ：从 <code>fp</code> 所指向的输入文件中读取一个字符，返回值是读取的字符，发生错误时返回 <code>EOF</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数 <code>fgets()</code> ：从 <code>fp</code> 所指向的输入文件中读取n-1个字符，并把字符串复制到 <code>buf</code> 中，最后追加 <code>NULL</code> 终止字符串。该函数如果在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 <code>EOF</code> ，则只会返回读取到的字符，包括换行符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> n, FILE *fp )</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数 <code>fscanf()</code> ：从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。该函数形式与 <code>scanf</code> 函数类似，参考 <code>scanf</code> 函数使用，记得添加取地址符 <code>&amp;</code> 。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两函数比较</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>OI Wiki，一个整合了编程竞赛的知识整合站点</title>
    <url>/%E5%85%B6%E4%BB%96%E5%88%86%E4%BA%AB/oiwiki/</url>
    <content><![CDATA[<p>Github分享</p>
<p>关键词：算法、数据结构、竞赛</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#%E6%98%AF%E4%BB%80%E4%B9%88">是什么</a></li>
<li><a href="#%E5%86%85%E5%AE%B9%E9%93%BE%E6%8E%A5">内容链接</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">如何使用</a></li>
</ul>
<!-- tocstop -->

<h1><span id="是什么">是什么</span></h1><p>“OI Wiki 致力于成为一个免费开放且持续更新的知识整合站点，大家可以在这里获取关于 编程竞赛 (competitive programming) 有趣又实用的知识，我们为大家准备了竞赛中的基础知识、常见题型、解题思路以及常用工具等内容，帮助大家更快速深入地学习编程竞赛。”</p>
<h1><span id="内容链接">内容链接</span></h1><p><a href="https://oi-wiki.org/">OI Wiki——网页使用</a><br><a href="https://github.com/OI-wiki/OI-wiki">Github 仓库</a><br><a href="https://gitee.com/OI-wiki/OI-wiki">Gitee 仓库</a></p>
<h1><span id="如何使用">如何使用</span></h1><p>在Github主页上有详细介绍。</p>
<p>可以直接点击上面的OI Wiki链接使用。</p>
<p>我在此用Windows 10做一个简单的 <strong>离线版</strong> 使用示例。</p>
<ol>
<li>直接或git方式下载仓库压缩包。</li>
</ol>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_download.jpg" alt="下载"></p>
<ol start="2">
<li><p>解压压缩包</p>
</li>
<li><p>在Python下（没有Python的可以<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/8/#more">安装Python</a>），使用命令建立静态网页：在解压后的目录下地址栏输入cmd，接着输入下面的命令启动网页。</p>
</li>
</ol>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_run.jpg" alt="打开cmd"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 如果是 python3</span><br><span class="line">python3 -m http.server</span><br><span class="line"># 如果是 python2</span><br><span class="line">python2 -m SimpleHTTPServer</span><br><span class="line"># 有些环境下找不到名叫 python3/python2 的可执行文件，不妨运行 python 试试</span><br></pre></td></tr></table></figure>

<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_run2.jpg" alt="启动网页服务"></p>
<ul>
<li>如上图则为启动网页服务成功。我在此输入的是<code>python</code>，可以试试<code>python3</code>或者<code>python2</code>能不能运行。</li>
<li>在浏览器地址栏中输入<code>http://localhost:8000/</code>或<code>127.0.0.1:8000</code>即可进入网页，其中<code>8000</code>为上图启动网页服务的端口，并不一定是<code>8000</code>。</li>
</ul>
<ol start="4">
<li>页面如下图即可进行阅读学习</li>
</ol>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/oiwiki_home.jpg" alt="OI Wiki"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>其他分享</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GPU服务器的选用</title>
    <url>/%E5%85%B6%E4%BB%96%E5%88%86%E4%BA%AB/gpuserver/</url>
    <content><![CDATA[<p>介绍关于GPU服务器：租用、使用</p>
<p>关键词：深度学习、GPU服务器</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#gpu%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%8D%E5%8A%A1%E5%95%86">GPU服务器服务商</a></li>
<li><a href="#gpu%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8">GPU服务器使用</a></li>
</ul>
<!-- tocstop -->

<h1><span id="gpu服务器服务商">GPU服务器服务商</span></h1><ol>
<li>AutoDL算力云</li>
</ol>
<ul>
<li>网站：<a href="https://www.autodl.com/home">AutoDL算力云</a></li>
<li>个人评价：本人具有使用经历，价格偏便宜，镜像有现成，适合新手入门尝试。</li>
</ul>
<ol start="2">
<li><a href="https://mistgpu.com/">MistGPU</a></li>
</ol>
<ul>
<li>网站：<a href="https://mistgpu.com/">MistGPU</a></li>
<li>个人评价：价格还行，备用选择。</li>
</ul>
<ol start="3">
<li>阿里云</li>
</ol>
<ul>
<li>网站：<a href="https://www.aliyun.com/product/ecs/gpu">阿里云</a></li>
<li>个人评价：阿里云，不多说，可靠也不便宜。</li>
</ul>
<h1><span id="gpu服务器使用">GPU服务器使用</span></h1><ol>
<li>选择适合的GPU型号、显存大小、浮点算力、存储盘大小。</li>
<li>选择合适的镜像进行环境配置。</li>
<li>一般无图形窗口，命令行使用，文件上传下载。</li>
<li>详细可参考各个服务商的帮助文档。</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>其他分享</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>GPU服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>给大一的你</title>
    <url>/%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/tofreshman/</url>
    <content><![CDATA[<p>如今大二将完，给大一朋友的一些话。</p>
<p>关键词：经验</p>
<span id="more"></span>

<hr>
<!-- toc -->



<!-- tocstop -->

<p><font face="kaiti">刚高考完就像是刚解放了一样，有的人安排得忙忙的：把好久没看的纪录片、电视剧、电影看个遍；有的人还不知道干什么，日复一日看手机无聊度过。</font></p>
<p><font face="kaiti">在我自己看来，大一的你可以是这样：</font></p>
<ul>
<li><p><font face="kaiti">广泛阅读，看看文学，看看历史等等；</font></p>
</li>
<li><p><font face="kaiti">广泛交友，识得良师益友；</font></p>
</li>
<li><p><font face="kaiti">进入一两个社团组织，培养技能，提高能力；</font></p>
</li>
<li><p><font face="kaiti">……</font></p>
</li>
</ul>
<p><font face="kaiti">大一其实还算处于一种很自由，很空闲的状态。这个时候拥有很多试错的机会，可以去长见识。</font></p>
<p><font face="kaiti">如果说你想拼搏努力地度过大一，那就去关注比赛等学术上的活动，同样也是获得经验的过程。如果说你想时而摆烂，不想逼得自己那么紧，那也完全可以，慢慢提升自己。你可以走得很慢，但绝不后退。</font></p>
<p><font face="kaiti">趁着大一，我觉得最好是提高广度。更重要的是，你是你，无需别人怎么样你也怎么样。有时候遇到的室友、同学摆烂或者很卷，你可以不受他们影响，自个过自个的。注意，这个观念很简单，做到其实很难。</font></p>
<p><font face="kaiti">其实还有一点，大一是视野逐渐开阔的过程，这个过程中也有很多骗子趁机而入，希望能够三思，能够谨慎，能够小心，谨防诈骗。</font></p>
<hr>
<p>接下来，我想说一些计算机专业相关的建议。其实很多同学大一之前对于计算机的知识是不全面的，更不用说丰富，你可以当作从零开始慢慢积累。</p>
<p>计算机并不是一门单纯地如何如何敲代码的学科，它其实更多是一门综合学科。你不用担心高中怎么偏科带来的影响，你可以先把高中带来的放到一边。</p>
<p>我个人觉得，计算机专业大一应该学习了解：</p>
<ul>
<li><p>一门基础编程语言：C语言或者C++（这两者差不多的）或者其他基础语言</p>
</li>
<li><p>计算机导论&#x2F;计算机概论：至少知道计算机的部分术语和基本内容</p>
</li>
<li><p><a href="https://www.bilibili.com/video/av21376839/?vd_source=2accbe36e414045d5297e94e0d032887">计算机组成原理</a>：关于计算机硬件方面的知识</p>
</li>
<li><p><a href="https://xiaolincoding.com/network/">计算机网络</a>：计算机网络方面的内容，比较抽象，作了解</p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1EW411u7th?p=14&vd_source=2accbe36e414045d5297e94e0d032887">数据结构</a>：编程基础</p>
</li>
<li><p><a href="https://xiaolincoding.com/os/">操作系统</a>：选择性学习</p>
</li>
</ul>
<p>上面的这些内容可能大一的时候还没开始学，但是个人大一学是很好的机会。通过对这些方面的了解，会更好地认识计算机这一专业甚至行业。</p>
<p>还有一些很平常，学校不会怎么教学但很重要的内容：</p>
<ul>
<li><p>学会使用<a href="https://www.github.com/">Github（国外）</a>和<a href="https://www.gitee.com/">Gitee（国内）</a></p>
</li>
<li><p>如何从编程语言变成程序运行</p>
</li>
<li><p>编程工具的使用</p>
</li>
<li><p>编程代码的习惯</p>
</li>
<li><p>程序项目的管理</p>
</li>
</ul>
<p>暂时想到这么多，如若再想到再添加。</p>
<hr>
<p>最后，如果想和我交流的，欢迎<u>QQ：1192697361</u></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>经验之谈</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记1</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cnetwork1/</url>
    <content><![CDATA[<p>计算机网络：引言+物理层+数据链路层</p>
<p>关键词：物理层、数据链路层</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#%E5%BC%95%E8%A8%80">引言</a><ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9C%A8%E4%BF%A1%E6%81%AF%E6%97%B6%E4%BB%A3%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">计算机网络在信息时代中的作用</a></li>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E6%A6%82%E8%BF%B0">互联网概述</a><ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BD%91%E7%BB%9C">网络的网络</a></li>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%8F%91%E5%B1%95%E7%9A%84%E4%B8%89%E9%98%B6%E6%AE%B5">互联网基础结构发展的三阶段</a></li>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%A5%E4%BD%9C">互联网的标准化工作</a></li>
</ul>
</li>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E7%BB%84%E6%88%90">互联网的组成</a><ul>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%BE%B9%E7%BC%98%E9%83%A8%E5%88%86">互联网的边缘部分</a><ul>
<li><a href="#%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E5%BC%8F">客户-服务器方式</a></li>
<li><a href="#%E5%AF%B9%E7%AD%89%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">对等连接方式</a></li>
</ul>
</li>
<li><a href="#%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86">互联网的核心部分</a><ul>
<li><a href="#%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2">电路交换</a></li>
<li><a href="#%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2">分组交换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%B1%BB%E5%88%AB">计算机网络的类别</a><ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9A%E4%B9%89">计算机网络的定义</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%88%AB%E7%9A%84%E7%BD%91%E7%BB%9C">不同类别的网络</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD">计算机网络的性能</a><ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">计算机网络的性能指标</a><ul>
<li><a href="#%E9%80%9F%E7%8E%87">速率</a></li>
<li><a href="#%E5%B8%A6%E5%AE%BD">带宽</a></li>
<li><a href="#%E5%90%9E%E5%90%90%E9%87%8F">吞吐量</a></li>
<li><a href="#%E6%97%B6%E5%BB%B6">时延</a><ul>
<li><a href="#%E5%8F%91%E9%80%81%E6%97%B6%E5%BB%B6">发送时延</a></li>
<li><a href="#%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6">传播时延</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%97%B6%E5%BB%B6">处理时延</a></li>
<li><a href="#%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6">排队时延</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF">时延带宽积</a></li>
<li><a href="#%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4rtt">往返时间RTT</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E7%8E%87">利用率</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9D%9E%E6%80%A7%E8%83%BD%E7%89%B9%E5%BE%81">计算机网络的非性能特征</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机网络的体系结构</a><ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E5%BD%A2%E6%88%90">计算机网络体系结构的形成</a></li>
<li><a href="#%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%92%E5%88%86%E5%B1%82%E6%AC%A1">协议与划分层次</a></li>
<li><a href="#%E5%85%B7%E6%9C%89%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">具有五层协议的体系结构</a></li>
<li><a href="#%E5%AE%9E%E4%BD%93-%E5%8D%8F%E8%AE%AE-%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%82%B9">实体、协议、服务和服务访问点</a></li>
<li><a href="#tcpip-%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">TCP&#x2F;IP 的体系结构</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%89%A9%E7%90%86%E5%B1%82">物理层</a><ul>
<li><a href="#%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">物理层的基本概念</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">数据通信的基础知识</a><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A8%A1%E5%9E%8B">数据通信系统的模型</a><ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD">常用术语</a></li>
</ul>
</li>
<li><a href="#%E6%9C%89%E5%85%B3%E4%BF%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">有关信道的几个基本概念</a></li>
<li><a href="#%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F">信道的极限容量</a></li>
</ul>
</li>
<li><a href="#%E7%89%A9%E7%90%86%E5%B1%82%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">物理层下面的传输媒体</a><ul>
<li><a href="#%E5%AF%BC%E5%BC%95%E5%9E%8B%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">导引型传输媒体</a><ul>
<li><a href="#%E5%8F%8C%E7%BB%9E%E7%BA%BF">双绞线</a></li>
<li><a href="#%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86">同轴电缆</a></li>
<li><a href="#%E5%85%89%E7%BC%86">光缆</a></li>
</ul>
</li>
<li><a href="#%E9%9D%9E%E5%AF%BC%E5%BC%95%E5%9E%8B%E4%BC%A0%E8%BE%93%E5%AA%92%E4%BD%93">非导引型传输媒体</a></li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF">信道复用技术</a><ul>
<li><a href="#%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8-%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8%E5%92%8C%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8">频分复用、时分复用和统计时分复用</a><ul>
<li><a href="#%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8fdmfrequency-division-multiplexing">频分复用FDM（Frequency Division Multiplexing）</a></li>
<li><a href="#%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8tdmtime-division-multiplexing">时分复用TDM（Time Division Multiplexing）</a></li>
<li><a href="#%E7%BB%9F%E8%AE%A1%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8statistic-tdm">统计时分复用（Statistic TDM）</a></li>
</ul>
</li>
<li><a href="#%E6%B3%A2%E5%88%86%E5%A4%8D%E7%94%A8wavelength-division-multiplexing">波分复用（Wavelength Division Multiplexing）</a></li>
<li><a href="#%E7%A0%81%E5%88%86%E5%A4%8D%E7%94%A8code-division-multiplexing">码分复用（Code Division Multiplexing）</a><ul>
<li><a href="#%E7%A0%81%E5%88%86%E5%A4%8D%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E8%AE%A1%E7%AE%97">码分复用的应用计算</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E5%AD%97%E4%BC%A0%E8%BE%93%E7%B3%BB%E7%BB%9F">数字传输系统</a></li>
<li><a href="#%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF">宽带接入技术</a><ul>
<li><a href="#adsl%E6%8A%80%E6%9C%AF">ADSL技术</a></li>
<li><a href="#%E5%85%89%E7%BA%A4%E5%90%8C%E8%BD%B4%E6%B7%B7%E5%90%88%E7%BD%91hfchybrid-fiber-coax%E7%BD%91">光纤同轴混合网（HFC（Hybrid Fiber Coax）网）</a></li>
<li><a href="#fttxfiber-to-the-%E6%8A%80%E6%9C%AF">FTTx（Fiber To The ……）技术</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">数据链路层</a><ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%82%B9%E5%AF%B9%E7%82%B9%E4%BF%A1%E9%81%93%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">使用点对点信道的数据链路层</a><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%92%8C%E5%B8%A7">数据链路和帧</a></li>
<li><a href="#%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">三个基本问题</a><ul>
<li><a href="#%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7">封装成帧</a></li>
<li><a href="#%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93">透明传输</a></li>
<li><a href="#%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6">差错控制</a><ul>
<li><a href="#crc%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8Ccyclic-redundancy-check">CRC循环冗余校验（Cyclic Redundancy Check）</a><ul>
<li><a href="#crc%E7%A0%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">CRC码的基本思想</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0">如何构造</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%A3%80%E9%94%99%E7%BA%A0%E9%94%99">如何检错纠错</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AEppppoint-to-point-protocol">点对点协议PPP（Point-to-Point Protocol）</a><ul>
<li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9">PPP协议的特点</a></li>
<li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B8%A7%E6%A0%BC%E5%BC%8F">PPP协议的帧格式</a><ul>
<li><a href="#%E5%B8%A7%E5%90%84%E5%AD%97%E6%AE%B5%E7%9A%84%E6%84%8F%E4%B9%89">帧各字段的意义</a></li>
<li><a href="#%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85">字节填充</a></li>
<li><a href="#%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85">零比特填充</a></li>
</ul>
</li>
<li><a href="#ppp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81">PPP协议的工作状态</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%B9%BF%E6%92%AD%E9%80%9A%E4%BF%A1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">使用广播通信的数据链路层</a><ul>
<li><a href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82">局域网的数据链路层</a><ul>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%87%E5%87%86">以太网的两个标准</a></li>
<li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8">适配器的作用</a></li>
</ul>
</li>
<li><a href="#csmacd%E5%8D%8F%E8%AE%AE">CSMA&#x2F;CD协议</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BA%BF%E5%99%A8%E7%9A%84%E6%98%9F%E5%BD%A2%E6%8B%93%E6%89%91">使用集线器的星形拓扑</a></li>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87">以太网的信道利用率</a><ul>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8F%82%E6%95%B0%CE%B1">以太网参数α</a></li>
<li><a href="#%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BCs_max">信道利用率的最大值$S_{max}$</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84mac%E5%B1%82">以太网的MAC层</a><ul>
<li><a href="#mac%E5%B1%82%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80">MAC层的硬件地址</a><ul>
<li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A3%80%E6%9F%A5mac%E5%9C%B0%E5%9D%80">适配器检查MAC地址</a></li>
</ul>
</li>
<li><a href="#mac%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F">MAC帧的格式</a><ul>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91v2%E6%A0%87%E5%87%86%E7%9A%84mac%E5%B8%A7%E6%A0%BC%E5%BC%8F">以太网V2标准的MAC帧格式</a></li>
<li><a href="#ieee8023mac-%E5%B8%A7%E6%A0%BC%E5%BC%8F">IEEE802.3MAC 帧格式</a></li>
<li><a href="#%E6%97%A0%E6%95%88mac%E5%B8%A7">无效MAC帧</a></li>
<li><a href="#%E5%B8%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E9%97%B4%E9%9A%94">帧的最小间隔</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%89%A9%E5%B1%95%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91">扩展的以太网</a><ul>
<li><a href="#%E5%9C%A8%E7%89%A9%E7%90%86%E5%B1%82%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91">在物理层扩展以太网</a></li>
<li><a href="#%E5%9C%A8%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%9B%B4%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95">在数据链路层扩展以太网(更常用的方法)</a><ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%BD%91%E6%A1%A5">使用网桥</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA">使用以太网交换机</a><ul>
<li><a href="#%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E8%87%AA%E5%AD%A6%E4%B9%A0%E5%8A%9F%E8%83%BD">以太网交换机的自学习功能</a></li>
<li><a href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AE">交换机使用生成树协议</a></li>
<li><a href="#%E4%BB%8E%E6%80%BB%E7%BA%BF%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%88%B0%E6%98%9F%E5%BD%A2%E4%BB%A5%E5%A4%AA%E7%BD%91">从总线以太网到星形以太网</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91">虚拟局域网</a><ul>
<li><a href="#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E6%A0%BC%E5%BC%8F">虚拟局域网使用的以太网帧格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%AB%98%E9%80%9F%E4%BB%A5%E5%A4%AA%E7%BD%91">高速以太网</a><ul>
<li><a href="#100base-t%E4%BB%A5%E5%A4%AA%E7%BD%91">100BASE-T以太网</a></li>
<li><a href="#%E5%90%89%E6%AF%94%E7%89%B9%E4%BB%A5%E5%A4%AA%E7%BD%91">吉比特以太网</a></li>
<li><a href="#10%E5%90%89%E6%AF%94%E7%89%B9%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%92%8C%E6%9B%B4%E5%BF%AB%E7%9A%84%E4%BB%A5%E5%A4%AA%E7%BD%91">10吉比特以太网和更快的以太网</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%A4%AA%E7%BD%91%E8%BF%9B%E8%A1%8C%E5%AE%BD%E5%B8%A6%E6%8E%A5%E5%85%A5">使用以太网进行宽带接入</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="引言">引言</span></h1><h2><span id="计算机网络在信息时代中的作用">计算机网络在信息时代中的作用</span></h2><ul>
<li>数字化、网络化、信息化</li>
<li>三大类网络：电信网络、有线电视网络、计算机网络<br>“三网融合”概念</li>
<li>网络是信息社会的命脉和发展知识经济的重要基础</li>
<li>互联网具有两个重要基本特点：连通性（Connectivity）、共享（Sharing）</li>
</ul>
<h2><span id="互联网概述">互联网概述</span></h2><h3><span id="网络的网络">网络的网络</span></h3><ul>
<li>互联网Internet</li>
<li>计算机网络，由若干结点（node）和连接这些结点的链路（link）组成</li>
<li>互连网，通过路由器把网络互连起来，构成覆盖范围更大的计算机网络</li>
<li>网络的网络，network of networks</li>
<li>与网络相连的计算机常称为主机。</li>
<li>Internet指互联网或因特网，internet泛指多个计算机网络互连而成的网络。</li>
</ul>
<h3><span id="互联网基础结构发展的三阶段">互联网基础结构发展的三阶段</span></h3><ul>
<li>一、从单个网络ARPANET向互联网发展的过程</li>
<li>二、建成了三级结构的互联网<br>主干网、地区网、校园网（企业网）</li>
<li>三、逐渐形成了多层次ISP结构的互联网<br>ISP，Internet Service Provider。<br>ISP也分成不同层次的ISP：主干ISP、地区ISP和本地ISP</li>
</ul>
<h3><span id="互联网的标准化工作">互联网的标准化工作</span></h3><ul>
<li>制定互联网的正式标准要经过三阶段：互联网草案、建议标准、互联网标准</li>
</ul>
<h2><span id="互联网的组成">互联网的组成</span></h2><ul>
<li>边缘部分：由所欲连接在互联网上的主机组成。</li>
<li>核心部分：由大量网络和连接这些网络的路由器组成。</li>
</ul>
<h3><span id="互联网的边缘部分">互联网的边缘部分</span></h3><ul>
<li>处在互联网边缘的部分就是连接在互联网上的所有的主机，这些主机又称为端系统（end system）。<br>端系统在功能上可能有很大的差别。<br>主机A的某个进程和主机B上的另一个进程进行通信，简称计算机之间的通信。</li>
<li>端系统之间的通信方式分为两类：<br>客户-服务器方式（C&#x2F;S方式）<br>对等方式（P2P方式）</li>
</ul>
<h4><span id="客户-服务器方式">客户-服务器方式</span></h4><ul>
<li>客户（client）和服务器（server）都是通信中所涉及的两个应用进程。</li>
<li>客户是服务请求方，服务器是服务提供方。</li>
<li>客户程序必须知道服务器程序的地址。</li>
<li>服务器程序不需要直到客户程序的地址。</li>
<li>客户与服务器通信关系建立后，通信是双向的。</li>
</ul>
<h4><span id="对等连接方式">对等连接方式</span></h4><ul>
<li>peer-to-peer，P2P</li>
<li>通信时不区分服务请求方还是服务提供方。</li>
<li>需要运行P2P程序。</li>
</ul>
<h3><span id="互联网的核心部分">互联网的核心部分</span></h3><ul>
<li>互联网的核心部分是由许多网络和把他们互连起来的路由器组成。</li>
<li>在网络核心部分起特殊作用的是路由器（router）。<br>路由器实现分组交换（packet switching）的关键构件。</li>
<li>互联网核心部分中的路由器之间一般用高速链路相连接。</li>
<li>路由器的用途是用来转发分组的，即进行分组交换的。</li>
</ul>
<h4><span id="电路交换">电路交换</span></h4><ul>
<li>N部电话机只需要N(N-1)&#x2F;2对电线直接连接就能够互相通话。</li>
<li>每一部电话直接连接到交换机上，而交换机使用交换的方法，让用户彼此间方便通信，这种方式就是电路交换。<br>此处交换的含义是转接。</li>
<li>特点：<font color="red">面向连接</font>的。</li>
<li>电路交换三阶段：建立连接、通信、释放连接。</li>
<li>缺点：计算机数据具有突发性，传送计算机数据时，通信线路的利用率很低。</li>
</ul>
<h4><span id="分组交换">分组交换</span></h4><ul>
<li>采用<font color="red">存储转发</font>技术。<br>在发送端，先把较长的报文划分成较短的、固定长度的数据段。<br>每一个数据段前面添加上首部构成分组（packet）。<br>在接收端，收到分组后剥去首部还原成报文。</li>
<li>每一个分组的首部都含有地址等控制信息。</li>
<li>分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一结点交换机。</li>
<li>每个分组在互联网中独立地选择传输路径。</li>
<li><font color="blue">优点</font><br>高效：在分组传输过程中动态分配传输带宽，对通信链路是逐段占用。<br>灵活：为每一个分组独立地选择最适合的转发路由。<br>迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组。<br>可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。</li>
<li>问题<br>分组在各结点存储转发时需要排队，造成一定时延。<br>分组必须携带的首部也造成一定的开销。</li>
</ul>
<h2><span id="计算机网络的类别">计算机网络的类别</span></h2><h3><span id="计算机网络的定义">计算机网络的定义</span></h3><ul>
<li>计算机网络主要是由一些通用的、可编程的硬件（包含CPU）互连而成的，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</li>
</ul>
<h3><span id="不同类别的网络">不同类别的网络</span></h3><ol>
<li>按照网络的作用分为进行分类：<br>广域网WAN（Wide Area Network）、城域网MAN（Metropolitan Area Network）、局域网LAN（Local Area Network）、个人局域网PAN（Personal Area Network）</li>
<li>按照网络的使用者进行分类：<br>公用网（public network）、专用网（private network）</li>
<li>用来把用户接入到互联网的网络：接入网（Access Network），又称为本地接入网或居民接入网。</li>
</ol>
<h2><span id="计算机网络的性能">计算机网络的性能</span></h2><h3><span id="计算机网络的性能指标">计算机网络的性能指标</span></h3><h4><span id="速率">速率</span></h4><ul>
<li>比特是计算机中的数量的单位。比特是一个二进制数字。</li>
<li>速率指的是数据的传送速率，也称数据率或比特率。</li>
<li>速率的单位是bit&#x2F;s、kbit&#x2F;s、Mbit&#x2F;s等。</li>
<li>速率往往是额定速率，非实际速率。</li>
</ul>
<h4><span id="带宽">带宽</span></h4><ul>
<li>带宽表示网络中某通道传送数据的能力，在单位时间内网络中某信道所能通过的最高数据率。</li>
<li>带宽的单位就是数据率的单位。</li>
</ul>
<h4><span id="吞吐量">吞吐量</span></h4><ul>
<li>吞吐量表示单位时间内通过某个网络（信道、接口）的数据量。</li>
<li>用于对现实世界中网络的一种测量。</li>
</ul>
<h4><span id="时延">时延</span></h4><ul>
<li>时延是指数据从网络的一端传送到另一端的时间。<br>有时也称为延迟或迟延。</li>
<li>时延由发送时延、传播时延、处理时延、排队时延组成。</li>
</ul>
<h5><span id="发送时延">发送时延</span></h5><ul>
<li>发送时延是发送数据时数据帧从结点进入到传输媒体所需要的时间。<br>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送给完毕所需的时间。<br>$$<br>发送时延&#x3D;\frac {数据帧长度(bit)}{发送频率(bit&#x2F;s)}<br>$$</li>
</ul>
<h5><span id="传播时延">传播时延</span></h5><ul>
<li>传播时延是电磁波在信道中传播一定距离所需要的时间。<br>$$<br>传播时延&#x3D;\frac {信道长度(m)}{电磁波在信道上的传播速率(m&#x2F;s)}<br>$$</li>
</ul>
<h5><span id="处理时延">处理时延</span></h5><ul>
<li>主机或路由器在收到分组时，需要花费时间进行处理的时间。</li>
</ul>
<h5><span id="排队时延">排队时延</span></h5><ul>
<li>分组在经过网络传输时，要经过许多的路由器。但分组在进入路由器后要先输入队列中排队等待处理。在路由器确定了转发接口后，还要输出队列中排队等候转发。</li>
</ul>
<h4><span id="时延带宽积">时延带宽积</span></h4><ul>
<li>时延带宽积是传播时延和带宽相乘。</li>
</ul>
<h4><span id="往返时间rtt">往返时间RTT</span></h4><ul>
<li>往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。<br>$$<br>发送时间&#x3D;\frac {数据长度}{发送速率}<br>$$</li>
</ul>
<h4><span id="利用率">利用率</span></h4><ul>
<li>分为信道利用率和网络利用率</li>
<li>信道利用率指某通道有百分之几的时间是被利用的。</li>
<li>网络利用率是全网络的信道利用率的加权平均值。</li>
<li>信道利用率增大时，该信道引起的时延也迅速增加。</li>
<li>令$D_0$表示网络空闲时的时延，$D$表示网络当前的时延，$U$为利用率。<br>$$<br>D&#x3D;\frac {D_0}{1-U}<br>$$</li>
</ul>
<h3><span id="计算机网络的非性能特征">计算机网络的非性能特征</span></h3><ul>
<li>费用、质量、标准化、可靠性、可拓展性和升级性、易于管理和维护。</li>
</ul>
<h2><span id="计算机网络的体系结构">计算机网络的体系结构</span></h2><h3><span id="计算机网络体系结构的形成">计算机网络体系结构的形成</span></h3><ul>
<li>计算机网络是个非常复杂的系统。</li>
<li>相互通信的两个计算机系统必须高度协调工作。</li>
<li>“分层”可将庞大而复杂的问题，转化为若干较小的局部问题。</li>
<li>1974年，IBM公司宣布了系统网络体系结构SNA。<br>按照分层方法制定。</li>
<li>由于网络体系结构不同，不同公司的设备很难互相连通。</li>
<li>开放系统互连基本参考模型（OSI&#x2F;RM）</li>
</ul>
<h3><span id="协议与划分层次">协议与划分层次</span></h3><ul>
<li>为网络中的数据交换而建立的规则，标准或约定称为网络协议。</li>
<li>网络协议三个组成要素：语法、语义、同步。<br>语法：数据与控制信息的结构或格式。<br>语义：需要发出何种控制信息，完成何种动作或做出何种相应。<br>同步：时间实现顺序的详细说明。</li>
<li>协议的两种形式：一种是使用便于人来阅读和理解的文字描述；另一种是使用让计算机能够理解的程序代码。<br>必须能够对网络上的信息交换过程做出精确的解释。</li>
<li>协议结构应该是层次性的。</li>
<li>分层的好处：各层之间是独立的；灵活性好；结构上可分割开；易于实现和维护；能促进标准化工作。</li>
<li>分层各层完成的主要功能：<br>差错控制：使相应层次对等方的通信更加可靠。<br>流量控制：发送端发送速率必须使接收端来得及接收。<br>分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。<br>复用和分用：发送端几个高层会话复用一条底层的连接，在接收端在进行分用。<br>连接建立和释放：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li>
</ul>
<h3><span id="具有五层协议的体系结构">具有五层协议的体系结构</span></h3><ul>
<li>计算机的网络体系结构是计算机网络的各层及其协议的集合。</li>
<li>OSI的七层协议：7应用层、6表示层、5会话层、4运输层、3网络层、2数据链路层、1物理层。</li>
<li>TCP&#x2F;IP是四层体系结构：应用层、运输层、网际层、网络接口层。</li>
<li>五层协议：5应用层（Application layer）、4运输层（Transport layer）、3网络层（Network layer）、2数据链路层（Data link layer）、1物理层（Physical layer）。<br>运输层最重要的协议是TCP和UDP协议。<br>网络层最重要的协议是IP协议。</li>
<li>假定主机1的应用进程$AP_1$向主机2的应用进程$AP_2$传送数据。$AP_1$先将数据交给本主机的应用层。应用层加上必要控制信息$H_5$就变成了下一层的数据单元。运输层收到数据单元，加上本层的控制信息$H_4$，再交给网络层，称为网络层的数据单元。以此类推。在数据链路层后，控制信息被分成两部分，分别加到数据链路层数据单元的首部$H_2$和尾部$T_2$；而物理层是比特流的传送，不需加上控制信息。传送比特流时应从首部开始传送。当比特流离开主机1经网络的物理媒体传送到路由器时，经过每一层去除控制信息，最后交到$AP_2$。</li>
</ul>
<h3><span id="实体-协议-服务和服务访问点">实体、协议、服务和服务访问点</span></h3><ul>
<li>实体表示任何可发送或接收信息的硬件或软件进程。</li>
<li>协议时控制两个对等实体进行通信的规则的集合。<br>协议的实现保证了能够向上一层提供服务。<br>下面协议对上面的服务用户是透明不可见的。本层用户只能看见服务而看不见下层的协议。</li>
<li>协议是“水平的”，控制对等实体之间通信的规则。</li>
<li>服务是“垂直的”，由下层向上层通过层间接口提供的。</li>
<li>同一系统相邻两层的实体进行交互的地方，称为服务访问点SAP。</li>
</ul>
<h3><span id="tcpx2fip-的体系结构">TCP&#x2F;IP 的体系结构</span></h3><ul>
<li>TCP&#x2F;IP协议族的特点是上下两头大而中间小：应用层和网络接口层都有很多种协议，而中间的IP层很小。</li>
<li>这种很像沙漏计时器形状的TCP&#x2F;IP协议族表明：TCP&#x2F;IP协议可以为各式各样的应用提供服务。</li>
<li>TCP&#x2F;IP协议允许IP协议在各式各样的网络构成的互联网上运行。</li>
</ul>
<h1><span id="物理层">物理层</span></h1><h2><span id="物理层的基本概念">物理层的基本概念</span></h2><ul>
<li><p>物理层考虑传输数据比特流。</p>
</li>
<li><p>物理层的作用要尽可能屏蔽掉不同传输媒体和通信手段的差异。</p>
</li>
<li><p>用于物理层的协议被称为物理层规程。</p>
</li>
<li><p>物理层的主要任务：确定与传输媒体的接口的一些特性。</p>
</li>
</ul>
<p>机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。</p>
<p>电气特性：指明在接口电缆的各条线上出现的电压范围。</p>
<p>功能特性：指明某条线上出现的某一电平的电压表示何种意义。</p>
<p>过程特性：指明对于不同功能的各种可能事件的出现顺序。</p>
<h2><span id="数据通信的基础知识">数据通信的基础知识</span></h2><h3><span id="数据通信系统的模型">数据通信系统的模型</span></h3><ul>
<li>一个数据通信系统分为三部分：源系统（发送端、发送方）、传输系统（传输网络）和目的系统（接收端、接收方）。</li>
</ul>
<h4><span id="常用术语">常用术语</span></h4><ul>
<li><p>数据data——运送消息的实体。</p>
</li>
<li><p>信号signal——数据的电气的或电磁的表现。</p>
</li>
<li><p>模拟数据analogous data——表示时间上和幅度取值上是连续的。</p>
</li>
<li><p>数字数据digital data——表示在时间上离散的，在幅值上是经过量化的数据。</p>
</li>
<li><p>模拟信号analogous signal——代表消息的参数的取值是连续的。</p>
</li>
<li><p>数字信号digital signal——代表消息的参数的取值是离散的。</p>
</li>
<li><p>码元code——在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p>
</li>
<li><p>信道——一般用来表示向某一方向传送信息的媒体。</p>
</li>
<li><p>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。</p>
</li>
<li><p>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送或接收。</p>
</li>
<li><p>双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。</p>
</li>
<li><p>串行传输：数据的二进制代码在一条物理信道上将数据一位位地依次传输。</p>
</li>
<li><p>并行传输：数据以成组的方式在多条并行信道上同时传输。</p>
</li>
<li><p>基带信号（基本频带信号）——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p>
</li>
</ul>
<p>基带信号往往包含低频成分，甚至直流成分，而许多信道并不能传输这种低频分量或直流分量，所以对基带信号进行调制。</p>
<ul>
<li>调制分为两大类：</li>
</ul>
<ol>
<li>基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍为基带信号。这种过程称为编码（coding）。<br>常用编码方式：</li>
</ol>
<p>不归零制：正电平代表1，负电平代表0。</p>
<p>归零制：正脉冲代表1，负脉冲代表0。</p>
<p>曼彻斯特编码：位周期中心的向上跳变代表0，位周期中心向下跳变代表1.可反过来定义。</p>
<p>差分曼彻斯特编码：每一位的中心处始终都有跳变。位开始边界有跳变代表0，而位开始边界没有跳变代表1。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/cnetwork_%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F.jpg" alt="编码方式"></p>
<ol start="2">
<li>带通调制：使用载波（carrier）进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道）。</li>
</ol>
<p>带通信号：经过载波调制后的信号。</p>
<p>最基本的二元制调制方法：</p>
<p>调幅（AM）：载波的振幅随基带数字信号而变化。</p>
<p>调频（FM）：载波的频率随基带数字信号而变化。</p>
<p>调相（PM）：载波的初始相位随基带数字信号而变化。</p>
<h3><span id="有关信道的几个基本概念">有关信道的几个基本概念</span></h3><h3><span id="信道的极限容量">信道的极限容量</span></h3><ul>
<li><p>码元传输速率越高或信号传输距离越远或传输媒体质量越差，在信道的输出端波形的失真就越严重。</p>
</li>
<li><p>限制码元在信道上的传输速率：信道能够通过的频率范围、信噪比。</p>
</li>
</ul>
<ol>
<li>信道能够通过的频率范围</li>
</ol>
<p>码元的传输速率有上限，否则出现码间串扰的问题。如果信道的频带越宽，也就是能够通过的信号高频分量越多，可以用更高速率传送码元而不出现码间串扰。</p>
<ol start="2">
<li>信噪比</li>
</ol>
<p>噪声存在于所有电子设备和通信信道中。噪声随机产生，会使接收端对码元的判决产生错误。</p>
<p>信噪比就是信号的平均功率和噪声的平均功率之比，记作$S&#x2F;N$，度量单位为分贝（dB）。</p>
<p>$$<br>信噪比（dB）&#x3D;10log_{10}(\frac SN)（dB）<br>$$</p>
<p>香农公式：极限、无差错的信息传输速率</p>
<p>$$<br>信道极限信息传输速率C&#x3D;Wlog_2(1+\frac SN)（bit&#x2F;s）<br>$$<br>W为信道带宽，Hz为单位；S为信道内所传信号的平均功率；N为信道内部的高斯噪声功率。</p>
<p>香农公式表明：</p>
<p>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法实现无差错传输。若W和S&#x2F;N没有上限，则C也没有上限。实际信道传输速率远比香农公式算出来的低。</p>
<h2><span id="物理层下面的传输媒体">物理层下面的传输媒体</span></h2><ul>
<li>传输媒体也称为传输介质或传输媒介。</li>
</ul>
<h3><span id="导引型传输媒体">导引型传输媒体</span></h3><ul>
<li>电磁波被导引沿着固体媒体传播。</li>
</ul>
<h4><span id="双绞线">双绞线</span></h4><ul>
<li><p>最常用</p>
</li>
<li><p>模拟传输和数字传输皆可，通信距离为几到十几公里。</p>
</li>
<li><p>分为屏蔽双绞线STP和无屏蔽双绞线UTP。</p>
</li>
<li><p>根据绞合分为3类线和5类线。</p>
</li>
<li><p>对于传送数据，最常用的UTP是5类线。</p>
</li>
</ul>
<h4><span id="同轴电缆">同轴电缆</span></h4><ul>
<li><p>很好的抗干扰特性，广泛用于传输较高速率的数据。</p>
</li>
<li><p>同轴电缆的带宽取决于电缆质量。</p>
</li>
<li><p>50Ω同轴电缆——LAN&#x2F;数字传输常用</p>
</li>
<li><p>75Ω同轴电缆——有线电视&#x2F;模拟传输常用</p>
</li>
</ul>
<h4><span id="光缆">光缆</span></h4><ul>
<li><p>光纤是光纤通信的传输媒体。</p>
</li>
<li><p>光纤通信系统的传输带宽远远大于目前其他传输媒体的带宽。</p>
</li>
<li><p>多模光纤：存在多条不同角度入社的光线在一条光纤中传输。</p>
</li>
<li><p>单模光纤：光纤直径减少到只有一个光的波长，光线可以一直向前传播而不会产生多次反射。</p>
</li>
<li><p>光波优点：通信容量非常大；传输损耗小，中继距离长；抗雷电和电磁干扰好；无串音干扰，保密性好；体积小，重量轻。</p>
</li>
</ul>
<h3><span id="非导引型传输媒体">非导引型传输媒体</span></h3><ul>
<li><p>就是指自由空间，这样的电磁波传输也被称为无线传输。</p>
</li>
<li><p>短波通信（高频通信）通信质量差、传输速率低。</p>
</li>
<li><p>微波主要以直线传播。</p>
</li>
<li><p>传统微波：地面微波接力通信和卫星通信。</p>
</li>
</ul>
<h2><span id="信道复用技术">信道复用技术</span></h2><ul>
<li>复用（multiplexing）是通信技术中的基本概念。它允许用户使用一个共享的信道进行通信，降低成本，提高利用率。</li>
</ul>
<h3><span id="频分复用-时分复用和统计时分复用">频分复用、时分复用和统计时分复用</span></h3><h4><span id="频分复用fdmfrequency-division-multiplexing">频分复用FDM（Frequency Division Multiplexing）</span></h4><ul>
<li><p>将整个带宽分为多份，用户在分配到一定频带后，通信过程自始至终都占用这个频带。</p>
</li>
<li><p>频分复用的所有用户在同样时间占用不同的带宽资源。（“带宽”指的是频率带宽而不是数据的发送频率）</p>
</li>
</ul>
<h4><span id="时分复用tdmtime-division-multiplexing">时分复用TDM（Time Division Multiplexing）</span></h4><ul>
<li><p>将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用的份额相等。</p>
</li>
<li><p>时分复用可能会造成线路资源的浪费。由于计算机数据的突发性，用户对分配到的子信道的利用率不高。</p>
</li>
</ul>
<h4><span id="统计时分复用statistic-tdm">统计时分复用（Statistic TDM）</span></h4><ul>
<li>STDM帧按需动态分配时隙。</li>
</ul>
<h3><span id="波分复用wavelength-division-multiplexing">波分复用（Wavelength Division Multiplexing）</span></h3><ul>
<li>光的频分复用，使用一根光纤传播。</li>
</ul>
<h3><span id="码分复用code-division-multiplexing">码分复用（Code Division Multiplexing）</span></h3><ul>
<li><p>在发送端将不同的用户信息采用相互正交的扩频码序列进行调制后再发送，在接收端采用相关解调来恢复原始数据。它是一种共享信道的方法，每个用户可在同一时间使用同样的频带进行通信，但使用基于码型的分割信道的方法。每个用户分配一个地址码，各个码型互不重叠，通信各方之间不会相互干扰，且抗干拢能力强。</p>
</li>
<li><p>常用名词码分多址CDMA（Code Division Multiple Access）</p>
</li>
<li><p>码片序列（chip sequence），在实用的系统中使用的是伪随机码序列。</p>
</li>
</ul>
<p>一个简单的码分复用的例子是在CDMA中，每个比特时间再划分为m个短的间隔，称为码片。通常m值为64或128。每个站被指派一个唯一的mbit码片序列。码片序列实现了扩频。</p>
<ul>
<li>CMDA的重要特点：每个站分配的码片序列不仅必须各不相同，并且还必须互相正交。</li>
</ul>
<h4><span id="码分复用的应用计算">码分复用的应用计算</span></h4><ul>
<li><p>一个站如果要发送比特1，则发送它自己的m bit码片序列，如果要发送0，则发送该码片序列的二进制反码。按照惯例将码片中的0写成<code>-1</code>，将1写成<code>+1</code>。</p>
</li>
<li><p>例如，假设有两个用户A和B，他们分别被分配了不同的码片序列：A的码片序列为<code>+1+1+1-1-1+1-1-1</code>，B的码片序列为<code>+1-1-1+1-1+1+1-1</code>。当A要发送比特0时，它会发送<code>-1-1-1+1+1-1+1+1</code>；当B要发送比特0时，它会发送<code>-1+1+1-1+1-1-1+1</code>。这样，在接收端就可以根据接收到的信号和已知的各用户的码片序列来解调并恢复原始数据。</p>
</li>
<li><p>当收到的码片序列存在大于1的值，说明该码片序列是混合叠加得到的，接收端收到的混合信号是各个站发送的码片序列之和。接收端用相同的码片序列进行<strong>规格化内积</strong>，就可以将不属于本码片序列的其他信号全部去除，只接受本码片序列所携带的信息。（即使多用户同时通信时，其信号电压会相互叠加或抵消。）</p>
</li>
</ul>
<p>通过<br>$$<br>S·T&#x3D;\frac 1m\sum^m_{i&#x3D;1}S_iT_i<br>$$</p>
<p>计算规格化内积，其中结果为+1，说明这个站发送比特1；结果为-1，说明这个站发送比特0；结果为0，说明这个站没有发送信息。</p>
<ul>
<li>例：共有4个站进行码分多址CDMA通信，4个站的码片序列为：<code>A：(-1 -1 -1 +1 +1 -1 +1 +1) 、B：(-1 -1 +1 -1 +1 +1 +1 -1)、C：(-1 +1 -1 +1 +1 +1 -1 -1) 、D：(-1 +1 -1 -1 -1 -1 +1 -1)</code>。现收到这样的码片序列：<code>( +1 -3 +3 -1 +1 +1 +1 +1)</code>，求发送站及发送的数据。</li>
</ul>
<p>由$S·T&#x3D;\frac 1m\sum^m_{i&#x3D;1}S_iT_i$计算$S·T_1&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{1i}&#x3D;1$，所以A站发送的是<code>1</code>；$S·T_2&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{2i}&#x3D;-1$，所以B站发送的是<code>0</code>；$S·T_3&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{3i}&#x3D;1$，所以C站没有发送数据；$S·T_4&#x3D;\frac 18\sum^8_{i&#x3D;1}S_iT_{4i}&#x3D;1$，所以D站发送的是<code>1</code>。</p>
<h2><span id="数字传输系统">数字传输系统</span></h2><ul>
<li><p>长途干线大都采用时分复用PCM的数字传输方式。</p>
</li>
<li><p>脉码调制PCM体制最初是为了在电话局之间的中继线上传送多路电话。</p>
</li>
<li><p>PCM有两个标准，北美的24路PCM（T1）和欧洲的30路PCM（E1）。我国采用E1标准。</p>
</li>
<li><p>旧的数字传输系统存在缺点：导致速率标准不统一，不是同步传输。</p>
</li>
<li><p>同步光纤网SONET（Synchronous Optical Network）</p>
</li>
</ul>
<p>SONET为光纤传输系统定义了同步传输的线路速率等级结构。</p>
<ul>
<li>同步数字系列SDH（Synchronous Digital Hierarchy）</li>
</ul>
<p>SDH一般可以跟SONET称为同义词，不同的点是SDH速率更快。</p>
<h2><span id="宽带接入技术">宽带接入技术</span></h2><h3><span id="adsl技术">ADSL技术</span></h3><ul>
<li>非对称数字用户线（Asymmetric Digital Subscriber Line）技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。</li>
</ul>
<p>把0~4kHz低端频谱留给传统电话，而把原来没有利用的高端频谱留给用户上网使用。</p>
<ul>
<li>ADSL的传输距离取决于数量和用户线的线径。</li>
</ul>
<p>用户线越细，信号传输时的衰减就越大。</p>
<ul>
<li><p>ADSL所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。</p>
</li>
<li><p>ADSL的特点</p>
</li>
</ul>
<ol>
<li><p>上行和下行带宽做成不对称的。上行指从用户到ISP，下行指从ISP到用户。</p>
</li>
<li><p>ADSL在用户线（铜线）的两端各安装一个ADSL调制解调器。</p>
</li>
<li><p>我国目前采用离散多音调DMT（Discrete Multi-Tone）调制技术。“多音调”就是“多载波”或“多子信道”。</p>
</li>
</ol>
<ul>
<li>ADSL的数据率</li>
</ul>
<p>ADSL采用自适应调制技术使用户线能够传送尽可能高的数据率。</p>
<p>ADSL不能保证固定的数据率。</p>
<ul>
<li><p>DSL：数字用户线。</p>
</li>
<li><p>HDSL：高速数字用户线。</p>
</li>
<li><p>SDSL：1对线的数字用户线。</p>
</li>
<li><p>VDSL：甚高速数字用户线。</p>
</li>
<li><p>RADSL：速率自适应DSL。</p>
</li>
</ul>
<h3><span id="光纤同轴混合网hfchybrid-fiber-coax网">光纤同轴混合网（HFC（Hybrid Fiber Coax）网）</span></h3><ul>
<li><p>HFC是目前覆盖面很广的有线电视网CATV的基础上开发的一种居民宽带接入网。</p>
</li>
<li><p>HFC网对CATV网进行了改造。</p>
</li>
</ul>
<p>HFC网将原CATV网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。</p>
<ul>
<li><p>用户接口盒UIB（User Interface Box），连接在同轴电缆和用户的电视机之间。</p>
</li>
<li><p>电缆调制解调器（Cable Modem），电缆调制解调器是为HFC网而使用的调制解调器。</p>
</li>
</ul>
<h3><span id="fttxfiber-to-the-技术">FTTx（Fiber To The ……）技术</span></h3><ul>
<li>FTTx是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。</li>
</ul>
<p>如：Fiber To The Home，FTTH，光纤到户；Fiber To The Building，FTTB，光纤到楼……</p>
<h1><span id="数据链路层">数据链路层</span></h1><ul>
<li><p>数据链路层使用的信道：点对点信道；广播信道。</p>
</li>
<li><p>点对点信道：使用一对一的点对点通信方式。</p>
</li>
<li><p>广播信道：使用一对多的广播通信方式。</p>
</li>
</ul>
<h2><span id="使用点对点信道的数据链路层">使用点对点信道的数据链路层</span></h2><h3><span id="数据链路和帧">数据链路和帧</span></h3><ul>
<li>链路（link）是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</li>
</ul>
<p>一条链路只是一条通路的一个组成部分。</p>
<ul>
<li>数据链路（data link）除了物理线路外，还必须有通信协议来控制这些数据的传输。</li>
</ul>
<p>若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
<ul>
<li><p>另外的术语：物理链路和逻辑链路，逻辑链路&#x3D;物理链路+协议。</p>
</li>
<li><p>点对点信道的数据链路层的协议数据单元是帧，数据链路层传送的是帧。</p>
</li>
</ul>
<p>数据链路层像个数字管道，在这条管道上传输的数据单位是帧。</p>
<ul>
<li>点对点信道的数据链路层在进行通信时的主要步骤如下：</li>
</ul>
<ol>
<li><p>结点A的数据链路层把网络层交下来的IP数据报添加首部和尾部封装成帧。</p>
</li>
<li><p>结点A把封装好的帧发送给结点B的数据链路层。</p>
</li>
<li><p>若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报交给上面的网络层；否则丢弃这个帧。</p>
</li>
</ol>
<h3><span id="三个基本问题">三个基本问题</span></h3><h4><span id="封装成帧">封装成帧</span></h4><ul>
<li><p>封装成帧就是在一段数据的前后分别添加首部和尾部，这样构成一个帧。</p>
</li>
<li><p>首部和尾部具有许多控制信息，一个重要作用就是进行帧定界。</p>
</li>
<li><p>每一种数据链路层协议都规定了所能传送的帧的数据部分长度上限——最大传送单元MTU。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>帧开始</th>
<th>IP数据报</th>
<th>帧结束</th>
</tr>
</thead>
<tbody><tr>
<td>帧首部</td>
<td>帧的数据部分$\leq MTU$</td>
<td>帧尾部</td>
</tr>
</tbody></table>
<ul>
<li>用控制字符进行帧定界。</li>
</ul>
<p>控制字符<code>SOH</code>（Start Of Header），表示帧的首部开始。控制字符<code>EOT</code>（End of Transmission），表示帧的结束。</p>
<p>具有明确的帧定界符才是完整的帧。</p>
<h4><span id="透明传输">透明传输</span></h4><ul>
<li>透明传输：不管所传数据是什么样的比特组合，都能在链路上传输。</li>
</ul>
<p><strong>“透明”表示：某一个实际存在的事物看起来却好像不存在一样。</strong></p>
<p>由于帧的开始和结束的标记使用专门指明的控制字符，因此，所传输的数据中任何8比特的组合一定不允许和用作帧定界的控制字符的比特编码一样。否则会出现帧定界的错误。当遇到数据中碰巧出现字符“EOT”时就传不过去。数据中的“EOT”被接收端错误地解释为“传输结束”的控制字符，而在其后面的数据因找不到“SOH”被接收端当作无效帧而丢弃。</p>
<ul>
<li>解决透明传输：字节填充或字符填充。<br>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。而在接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。如果转义字符也出现在数据中，那么仍在转义字符的前面插入一个转义字符。</li>
</ul>
<h4><span id="差错控制">差错控制</span></h4><ul>
<li><p>产生比特差错：1和0的变换。</p>
</li>
<li><p>误码率：传输错误的比特占所传输比特总数的比率。</p>
</li>
</ul>
<p>误码率与信噪比关系很大。</p>
<ul>
<li>循环冗余检验CRC，能够实现无比特差错传输。</li>
</ul>
<h5><span id="crc循环冗余校验cyclic-redundancy-check">CRC循环冗余校验（Cyclic Redundancy Check）</span></h5><h6><span id="crc码的基本思想">CRC码的基本思想</span></h6><ul>
<li><p>数据发送接受方约定一个“除数”（二进制）。</p>
</li>
<li><p>K个信息位和R个校验位作为“被除数”，添加校验位后需保证除法的余数为0。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">信息位</th>
<th align="center">校验位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">K位</td>
<td align="center">R位</td>
</tr>
</tbody></table>
<ul>
<li>收到数据后，进行除法检查余数是否为0。</li>
</ul>
<h6><span id="如何构造">如何构造</span></h6><ul>
<li>假设生成多项式为$G(x)&#x3D;x^3+x^2+1$，信息码为101001，求对应CRC码。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">信息位</th>
<th align="center">校验位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">K位</td>
<td align="center">R位</td>
</tr>
</tbody></table>
<ol>
<li>确定K、R以及生成多项式对应的二进制编码。</li>
</ol>
<p>由生成多项式$G(x)&#x3D;1·x^3+1·x^2+0·x+1·x^0$，得对应的二进制编码为1101。</p>
<p>$K&#x3D;信息码长度&#x3D;6$，$R&#x3D;生成多项式最高次幂&#x3D;3$，CRC位数<code>N=K+R=9</code>。</p>
<ol start="2">
<li>移位</li>
</ol>
<p>信息码左移<code>R</code>位，低位补0。</p>
<ol start="3">
<li>相除</li>
</ol>
<p>对移位后的信息码，用生成多项式进行模2除法，产生余数。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/cnetwork_1.jpg" alt="CRC过程"></p>
<p>得到对应CRC码：<code>101001001</code></p>
<h6><span id="如何检错纠错">如何检错纠错</span></h6><ul>
<li><p>如发送：<code>101001001</code>记为$C_9C_8C_7C_6C_5C_4C_3C_2C_1$。</p>
</li>
<li><p>接收方：<code>101001001</code>用<code>1101</code>进行模2除，余数为<code>000</code>代表没有出错。</p>
</li>
<li><p>接收方：<code>101001011</code>用<code>1101</code>进行模2除，余数为<code>010</code>代表出错。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">接受</th>
<th align="center">余数</th>
<th align="center">出错位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10100100<font color="red">0</font></td>
<td align="center">001</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1010010<font color="red">1</font>1</td>
<td align="center">010</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">101001<font color="red">1</font>01</td>
<td align="center">100</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">10100<font color="red">0</font>001</td>
<td align="center">101</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">1010<font color="red">1</font>1001</td>
<td align="center">111</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">101<font color="red">1</font>01001</td>
<td align="center">011</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">10<font color="red">0</font>001001</td>
<td align="center">110</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">1<font color="red">1</font>1001001</td>
<td align="center">001</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center"><font color="red">0</font>01001001</td>
<td align="center">010</td>
<td align="center">9</td>
</tr>
</tbody></table>
<ul>
<li>K个信息位，R个校验位，若生成多项式选择得当，且$2^R\geq K+R+1$，则CRC码可纠正1位错。</li>
</ul>
<p>上述例子中，总位数有9位，而校验位只有3位，$2^3&#x3D;8$，则不能表示所有的错误位置。</p>
<ul>
<li>理论上可以得出CRC校验码的特点：</li>
</ul>
<ol>
<li><p>可检测出所有奇数个错误；</p>
</li>
<li><p>可检测出所有双比特的错误；</p>
</li>
<li><p>可检测出所有小于等于校验位长度的连续错误。</p>
</li>
</ol>
<ul>
<li><p>在数据后面添加上冗余码称为帧检验序列FCS。</p>
</li>
<li><p>CRC是一种常用的检错方法，而FCS是添加在数据后面的冗余码。</p>
</li>
<li><p>仅用循环冗余检验CRC差错检测技术只能做到无差错接受。</p>
</li>
</ul>
<p>凡是接收端数据链路层接受的帧，都能以非常接近1的概率认为这些帧在传输过程中没有产生差错。</p>
<p>无比特差错和无传输差错是不同的概念。</p>
<h2><span id="点对点协议ppppoint-to-point-protocol">点对点协议PPP（Point-to-Point Protocol）</span></h2><h3><span id="ppp协议的特点">PPP协议的特点</span></h3><ul>
<li><p>用户计算机和ISP进行通信时所使用的数据链路层协议就是PPP协议。</p>
</li>
<li><p>PPP协议应该满足的需求</p>
</li>
</ul>
<ol>
<li><p>简单——首要要求。</p>
</li>
<li><p>封装成帧——必须规定特殊的字符作为帧定界符。</p>
</li>
<li><p>透明性——必须保证数据传输的透明性。</p>
</li>
<li><p>多种网络协议——能够在同一条物理链路上同时支持多种网络层协议。</p>
</li>
<li><p>多种类型网络——能够在多种类型网络上使用。</p>
</li>
<li><p>差错检测——必须能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p>
</li>
<li><p>检测连接状态——能够即使自动检测出链路是否处于正常工作状态。</p>
</li>
<li><p>最大传送单元——必须对每一种类型的点对点链路设置最大传送单元MTU的标准默认值，促进各种实现之间的互操作性。</p>
</li>
<li><p>网络层地址协商——必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。</p>
</li>
<li><p>数据压缩协商——必须提供一种方法来协商使用数据压缩算法。</p>
</li>
</ol>
<ul>
<li>PPP协议不需要的功能</li>
</ul>
<ol>
<li><p>纠错</p>
</li>
<li><p>流量控制</p>
</li>
<li><p>序号</p>
</li>
<li><p>多点线路</p>
</li>
<li><p>半双工或单工线路</p>
</li>
</ol>
<ul>
<li>PPP协议组成部分：</li>
</ul>
<ol>
<li><p>一个将IP数据报封装到串行链路的方法。</p>
</li>
<li><p>链路控制协议LCP（Link Control Protocol）。</p>
</li>
<li><p>网络控制协议NCP（Network Control Protocol）。</p>
</li>
</ol>
<h3><span id="ppp协议的帧格式">PPP协议的帧格式</span></h3><h4><span id="帧各字段的意义">帧各字段的意义</span></h4><ul>
<li><p>PPP帧首部和尾部分别为4个字段和2个字段。</p>
</li>
<li><p>首部</p>
</li>
</ul>
<p>标志字段F（Flag），规定为<code>0x7E</code>，是PPP帧的定界符，占用1个字节；</p>
<p>地址字段A，规定为<code>0xFF</code>，占用1个字节；</p>
<p>控制字段C，规定为<code>0x03</code>，占用1个字节；</p>
<p>协议占用2个字节。当协议字段为<code>0x0021</code>时，PPP帧的信息字段就是IP数据报。当协议字段为<code>0xC021</code>时，则信息字段是PPP链路控制协议LCP的数据。当协议字段为<code>0x8021</code>时，表示这是网络层的控制数据。</p>
<ul>
<li><p>信息字段的长度是可变的，不超过1500字节。</p>
</li>
<li><p>尾部第一个字段是使用CRC的帧检验序列FCS，第二个字段是标志字段F。</p>
</li>
</ul>
<h4><span id="字节填充">字节填充</span></h4><ul>
<li>当信息字段中出现和标志字段一样的比特<code>0x7E</code>组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。当</li>
</ul>
<p>PPP使用异步传输时，它把转义字符定义为<code>0x7D</code>即<code>01111101</code>，并使用字节填充。</p>
<ul>
<li>RFC1662规定了填充方法：</li>
</ul>
<ol>
<li><p>把信息字段中出现的每一个<code>0x7E</code>字节转变成为2字节序列<code>0x7D,0x5E</code>。</p>
</li>
<li><p>若信息字段中出现了一个<code>0x7D</code>的字节（即出现了和转义字符一样的比特组合），则把<code>0x7D</code>转变为2字节序列<code>0x7D,0x5D</code>。</p>
</li>
<li><p>若信息字段中出现了ASCII码的控制字符（数值小于<code>0x20</code>的字符），则在该字符前加入一个<code>0x7D</code>字节，同时将该字符的编码加以改变。如出现了<code>0x03</code>（在控制字符中是“传输结束”ETX）就要把它转变为2字节序列<code>0x7D,0x23</code>。<br>发送端进行了修改，但接收端在收到数据在进行于发送端字节填充相反的变换。</p>
</li>
</ol>
<h4><span id="零比特填充">零比特填充</span></h4><ul>
<li><p>零比特填充的具体做法：在发送端，先扫描整个信息字段，只要发现有5个连续1，则立即填入一个0（防止被认为是标志字段F）。接收端在收到一个帧时，先找到标志字段F以确认一个帧的边界，接着再用硬件对其中的比特流进行扫描，当发现5个连续的1时，就把这5个连续1后的一个0删除，还原成原来的信息比特流。</p>
</li>
<li><p>上述方法保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。</p>
</li>
</ul>
<h3><span id="ppp协议的工作状态">PPP协议的工作状态</span></h3><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/cnetwork1_2.jpg" alt="PPP工作状态"></p>
<ul>
<li>PPP协议有5个工作状态：</li>
</ul>
<ol>
<li><p>链路静止（Link Dead）：PPP链路的起始和终止状态永远是链路静止，这个阶段发生在链接失败，或一方被告知断开连接（例如，用户已经完成了他或她的拨号连接）。</p>
</li>
<li><p>链路建立（LCP 连接建立）（Link Establishment Phase）：发送者与接收者之间建立连接。</p>
</li>
<li><p>鉴别用户身份（身份验证）（Authentication Phase）：使用用户名和口令对建立的链接进行身份验证，确定对方的身份是否合法。</p>
</li>
<li><p>网络层协议（NCP 建立）（Network-Layer Protocol Phase）：在建立的PPP链路上，根据具体需要选择所要使用的网络层协议，并为该协议建立NCP（网络控制协议）。</p>
</li>
<li><p>链路终止（LCP连接终止）（Link Termination Phase）：链路连接的关闭及资源的释放。</p>
</li>
</ol>
<ul>
<li><p>当用户拨号接入ISP时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。PC 机向路由器发送一系列的链路控制协议 LCP 分组（封装成多个 PPP 帧)这些分组及其响应选择一些PPP参数，并进行网络层配置，网络控制程序NCP 给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</p>
</li>
<li><p>PPP协议不是纯粹的数据链路层的协议，还包括物理层和网络层的内容。</p>
</li>
<li><p>当用户个人电脑通过调制解调器呼叫路由器时，路由器就能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP就进入“链路建立”（Link Establish）状态，其目的是建立链路层的LCP连接。这时LCP开始协商一些配置选项，即发送LCP的配置请求帧（Configure-Request）。这是个 PPP帧，其协议字段置为 LCP 对应的代码，而信息字段包含特定的配置请求。</p>
</li>
<li><p>链路的另一端可以发送以下几种响应中的一种：</p>
</li>
</ul>
<ol>
<li><p>配置确认帧（Configure-Ack）所有选项都接受。</p>
</li>
<li><p>配置否认帧（Configure-Nak）所有选项都理解但不能接受。</p>
</li>
<li><p>配置拒绝帧（Configure-Reject）选项有的无法识别或不能接受，需要协商。</p>
</li>
</ol>
<ul>
<li><p>LCP配置选项包括链路上的最大帧长、所使用的<strong>鉴别协议</strong>（authentication protocol）的规约（如果有的话），以及不使用PPP帧中的地址和控制字段（因为这两个字段的值是固定的，没有任何信息量，可以在PPP帧的首部中省略这两个字节）。协商结束后双方就建立了 LCP链路，接着就进入“<strong>鉴别</strong>”（Authenticate）状态。在这一状态，只允许传送LCP协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用口令鉴别协议PAP（Password Authentication Protocol），则需要发起通信的一方发送身份标识符和口令。系统可允许用户重试若干次。如果需要有更好的安全性，则可使用更加复杂的口令握手鉴别协议 CHAP <strong>（Challenge-Handshake Authentication Protocol）。若鉴别身份失败，则转到“</strong>链路终止<strong>”（Link Terminate）状态。若鉴别成功，则进入“</strong>网络层协议**”（Network-Layer Protocol）状态。</p>
</li>
<li><p>在“<strong>网络层协议</strong>”状态，PPP链路的两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。这个步骤是很重要的，因为现在的路由器都能够同时支持多种网络层协议。总之，PPP协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个PPP协议进行通信。</p>
</li>
<li><p>如果在PPP链路上运行的是IP协议，则对PPP链路的每一端配置IP协议模块（如分配 IP 地址）时就要使用 NCP 中支持 IP的协议——<strong>IP 控制协议 IPCP</strong> （IP Control Protocol）。IPCP 分组也封装成PPP帧（其中的协议字段为<code>0x8021</code>）在PPP链路上传送。在低速链路上运行时，双方还可以协商使用压缩的TCP和IP首部，以减少在链路上发送的比特数。</p>
</li>
<li><p>当网络层配置完毕后，链路就进入可进行数据通信的“<strong>链路打开</strong>”（Link Open）状态。链路的两个 PPP端点可以彼此向对方发送分组。两个 PPP端点还可发送<strong>回送请求</strong>LCP分组（Echo-Request）和<strong>回送回答</strong>LCP分组（Echo-Reply），以检查链路的状态。</p>
</li>
<li><p>数据传输结束后，可以由链路的一端发出终止请求LCP分组（Terminate-Request）请求终止链路连接，在收到对方发来的终止确认 LCP 分组（Terminate-Ack）后，转到“<strong>链路终止</strong>”状态。如果链路出现故障，也会从“<strong>链路打开</strong>”状态转到“<strong>链路终止</strong>”状态。当调制解调器的载波停止后，则回到“<strong>链路静止</strong>”的状态。</p>
</li>
</ul>
<h2><span id="使用广播通信的数据链路层">使用广播通信的数据链路层</span></h2><h3><span id="局域网的数据链路层">局域网的数据链路层</span></h3><ul>
<li><p>特点：网络为一个单位所拥有；地理范围和站点数目有限。</p>
</li>
<li><p>局域网具有如下主要优点：</p>
</li>
</ul>
<ol>
<li><p>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</p>
</li>
<li><p>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</p>
</li>
<li><p>提高了系统的可靠性、可用性和残存性。</p>
</li>
</ol>
<ul>
<li>共享信道：静态划分信道和动态媒体接入控制。</li>
</ul>
<p>静态划分信道包括频分复用、时分复用、波分复用和码分复用灯，但代价较高不适合局域网使用。动态媒体接入控制又称多点接入，特点是信道并非在用户通信时固定分配给用户。</p>
<ul>
<li>动态媒体接入又分为随机接入和受控接入。</li>
</ul>
<p>随机接入的特点是所有用户可随机地发送信息，但如果恰巧多用户同时发送信息时，出现信息碰撞冲突，所以要有解决碰撞的网络协议。受控接入的特点是用户不能随机地发送信息而必须服从一定的控制，这类典型代表有分散控制的令牌环局域网和集中控制的多点线路探询（又称轮询）。</p>
<h4><span id="以太网的两个标准">以太网的两个标准</span></h4><ul>
<li><p>以太网的两个标准：DIX Ethernet V2和IEEE 802.3。</p>
</li>
<li><p>IEEE802委员会把局域网的数据链路层拆成两个子层：逻辑链路控制LLC（Logical Link Control）和媒体接入控制MAC（Medium Access Control）。与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种传输媒体和MAC子层的局域网对LLC子层来说都是透明的。</p>
</li>
</ul>
<h4><span id="适配器的作用">适配器的作用</span></h4><ul>
<li><p>计算机与外界局域网的连接时通过通信适配器（adapter）进行的。</p>
</li>
<li><p>适配器本来是一块网络接口板，又称为通信适配器或网络接口卡NIC，或“网卡”。</p>
</li>
<li><p>重要功能：串行&#x2F;并行转换；数据缓存；安装设备驱动程序；实现以太网协议。</p>
</li>
</ul>
<h3><span id="csmax2fcd协议">CSMA&#x2F;CD协议</span></h3><ul>
<li>以太网采用广播方式发送。</li>
</ul>
<p>总线上的每一个工作的计算机都能检测到发送的数据信号。但由于数据帧首部写入地址匹配问题，只有某个计算机才能接收。</p>
<ul>
<li>以太网采用两种重要措施</li>
</ul>
<ol>
<li>采用较为灵活的无连接的工作方式。</li>
</ol>
<p>不必先建立连接就可以直接发送数据。对发送的数据帧不进行编号，也不要求对方发回确认。</p>
<p>以太网提供的服务时不可靠的交付，即尽最大努力的交互。</p>
<p>当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。</p>
<p>如果发现了数据帧丢失了一些数据，于是把这些数据重新传递给以太网进行重传，但以太网并不知道这是重传帧，而是当作新的数据帧来发送。</p>
<ol start="2">
<li>以太网发送的数据都是用曼彻斯特编码。</li>
</ol>
<p>曼彻斯特编码的缺点是：它所占的频带宽度比原始的基带信号增加了一倍。</p>
<ul>
<li><p>CSMA&#x2F;CD含义： 载波监听多点接入&#x2F;碰撞检测（Carrier Sense Multiple Access with Collision Detection）。</p>
</li>
<li><p>“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。</p>
</li>
<li><p>“载波监听”是指每一个站在发送数据之前先要检测总线上是否有其他计算机在发送数据，如果有，则暂时不发送数据，以免发生碰撞。</p>
</li>
</ul>
<p>总线上并没有什么“载波”。因此，“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</p>
<ul>
<li>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。“碰撞检测”也成为“冲突检测”。</li>
</ul>
<p>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将增大。当适配器检测到的信号电压变化幅度超过一定的门限值，就认为总线上至少有两个站同时在发送数据。</p>
<ul>
<li><p>为什么要进行碰撞检测？<br>由于电磁波在总线上的传播速率是有限的。 碰撞的结果是两个帧都变得无用。</p>
</li>
<li><p>使用CSMA&#x2F;CD协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</p>
</li>
<li><p>争用期</p>
</li>
</ul>
<p>最先发送数据帧的站，在发送数据帧后至多经过时间$2τ$就可知道发送的数据帧是否遭受了碰撞。以太网的端到端往返时延$2τ$称为争用期或碰撞窗口。经过争用期后还没有检测到碰撞，才能肯定此次发送不会发生碰撞。</p>
<p>10Mbit&#x2F;s以太网取51.2μs为争用期长度。对于10Mbit&#x2F;s以太网，在争用期可发送512bit，即64字节。这意味着以太网在发送数据时，若前64字节没有发送冲突，则后续的数据就不会发送冲突。</p>
<p>如果发生冲突，一定在发送前64字节之内。由于冲突而终止发送，此时发送出去的数据一定小于64字节。<strong>以太网规定了最短有效帧长为64字节</strong>，凡长度小于64字节的帧都是由于冲突而异常终止的无效帧。</p>
<ul>
<li>最短帧长计算</li>
</ul>
<p>$$<br>最短帧长 &#x3D; 争用期长度 × 数据传输速率<br>$$</p>
<p>$$<br>争用期长度是指端到端传输时延 τ 的两倍。<br>$$</p>
<p>$$<br>最短帧长 &#x3D; 2τ × 数据传输速率<br>$$</p>
<ul>
<li>二进制指数类型退避算法</li>
</ul>
<p>发送碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能在发送数据。基本退避时间取为争用期$2τ$。从整数集合$[0,1,…,(2^k-1)]$中随机取出一个数，记为$r$。重传所需时延就是$r$倍的基本退避时间。</p>
<p>参数$k$计算：$k&#x3D;Min[重传次数,10]$，当$k\leq 10$时，参数$k$等于重传次数。</p>
<p>当重传达16次仍不能成功时丢弃此帧，并向高层报告。</p>
<ul>
<li>强化碰撞</li>
</ul>
<p>一旦发生了碰撞：立即停止发送数据；再继续发送32比特或48比特的人为干扰信号。</p>
<ul>
<li>CSMA&#x2F;CD协议的要点</li>
</ul>
<ol>
<li><p>准备发送。在发送之前，必须先检测信道。</p>
</li>
<li><p>检测信道。若检测到信道忙，应不停检测，一直等待信道转为空闲。若检测到信道空闲，并在96比特时间内保持空闲（保证了帧间最小间隔），就发送这个帧。</p>
</li>
<li><p>检查碰撞。在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里有两种可能性。</p>
</li>
</ol>
<p>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做，回到步骤1。</p>
<p>发送失败：在争用期内检测到碰撞。这是立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法。等待r倍512比特时间后，返回到步骤2，继续检测信道。但若重传达16次仍不成功，则停止重传而向上报错。</p>
<h3><span id="使用集线器的星形拓扑">使用集线器的星形拓扑</span></h3><ul>
<li>物理上是星型，逻辑上是总线型。</li>
</ul>
<p>为了降低成本，最初由粗的同轴电缆变成细的同轴电缆最后变成无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收；</p>
<ul>
<li><p>采用双绞线的以太网采用星形拓扑，在星形中心则增加了一种可靠性非常高的设备，叫作集线器（hub）。</p>
</li>
<li><p>1990年，IEEE制定星形以太网10BASE-T的标准802.3i。10表示速度10Mbit&#x2F;s，BASE指的是连接线上的信号是基带信号，T代表双绞线。</p>
</li>
</ul>
<p>使用无屏蔽双绞线，采用星形拓扑。每个站需要两队双绞线用于发送和接收。双绞线两端使用RJ-45插头。</p>
<ul>
<li>集线器的一些特点</li>
</ul>
<p>逻辑上仍是一个总线网，各工作站使用的还是CSMA&#x2F;CD协议，并共享逻辑上的总线，在同一时刻至多只允许一个站发送数据。</p>
<ol>
<li><p>能够扩展网络：集线器可以将多个网络设备连接在一起，扩展网络的范围和接入设备的数量。</p>
</li>
<li><p>传输速率较慢：集线器的传输速率较慢，一般为10Mbps或100Mbps，无法满足高速数据传输的需求。</p>
</li>
<li><p>无法分割网络：集线器不具备分割网络的能力，所有连接的设备共享同一个网络地址。</p>
</li>
<li><p>无法过滤数据：集线器无法过滤数据包，所有的数据包都会被广播到所有连接的设备上。</p>
</li>
<li><p>便宜易用：集线器的价格较为低廉，且使用简单，适合小型网络的搭建。</p>
</li>
<li><p>可靠性较低：由于集线器无法检测网络中的故障点，不进行碰撞检测，一旦出现故障，整个网络将会受到影响。</p>
</li>
</ol>
<h3><span id="以太网的信道利用率">以太网的信道利用率</span></h3><ul>
<li>以太网的信道利用率是指在一定时间内，实际传输数据的时间与总时间的比值。</li>
</ul>
<p>由于在以太网中，传输数据需要占用一定的时间，而且在传输数据时可能会出现冲突、重传等情况，因此实际传输数据的时间会比总时间要短，信道利用率也就相应地降低。</p>
<ul>
<li><p>以太网总的信道利用率并不能达到100%。</p>
</li>
<li><p>假设发送帧需要的时间是$T_0$，则成功发送一个帧需要占用信道的时间是$T_0+τ$，多一个单程端到端时延$τ$。因此必须经过时间$T_0+τ$后以太网的媒体才完全进入空闲状态，才能允许其他站发送数据。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">争用期</th>
<th align="center">争用期</th>
<th align="center">……</th>
<th align="center">争用期</th>
<th align="center">发送成功</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">$2τ$</td>
<td align="center">$2τ$</td>
<td align="center"></td>
<td align="center">$2τ$</td>
<td align="center">$T_0$</td>
<td align="center">$τ$</td>
</tr>
</tbody></table>
<p>前面争用期时间为发生碰撞的情况，后面从发送成功到一个$τ$时间为占用信道时间。</p>
<h4><span id="以太网参数α">以太网参数α</span></h4><ul>
<li><p>定义参数$α$，以太网单程端到端时延$τ$与帧发送时间$T_0$之比，$α&#x3D;\frac t {T_0}$。当$α\rightarrow 0$，表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。$α$越大，表明争用期所占的比例增大，每发生一次碰撞浪费许多信道资源，使得信道利用率明显降低。</p>
</li>
<li><p>从式子可得当数据率一定时，以太网的连线的长度受到限制，同时以太网的帧长不能太短。</p>
</li>
</ul>
<h4><span id="信道利用率的最大值s_max">信道利用率的最大值$S_{max}$</span></h4><ul>
<li>使用非常理想化的考虑，计算极限信道利用率：</li>
</ul>
<p>$$<br>S_{max}&#x3D;\frac {T_0}{T_0+τ}&#x3D;\frac 1 {1+a}<br>$$</p>
<p>只有参数$α$远小于1才能得到尽可能高的极限信道利用率。若参数$α$远大于1，则极限信道利用率就远小于1，而此时实际的信道利用率就更小。当以太网的利用率达到30%时就已经处于重载的情况。</p>
<h3><span id="以太网的mac层">以太网的MAC层</span></h3><h4><span id="mac层的硬件地址">MAC层的硬件地址</span></h4><ul>
<li>MAC地址（Media Access Control Address），又称硬件地址或物理地址，是用于唯一标识网络设备的地址。在计算机网络中，MAC地址是以太网协议中的一个重要参数，用于识别数据包发送者和接收者。</li>
</ul>
<p>MAC地址，实际上就是适配器地址或适配器标识符EUI-48。</p>
<p>802标准所说的“地址”严格说应该是每一个站的“名字”或标识符。</p>
<ul>
<li>MAC地址由48位二进制数表示，通常被表示为12个十六进制数，每两个十六进制数之间用冒号或短横线隔开。MAC地址由两部分组成：厂商代码和设备标识符。</li>
</ul>
<p>厂商代码是由IEEE（Institute of Electrical and Electronics Engineers）注册管理机构分配的，占用24位二进制数。设备标识符是由厂商自己分配的，占用24位二进制数。</p>
<p>IEEE规定地址字段的第一字节最低位为I&#x2F;G位。I&#x2F;G表示Individual&#x2F;Group。当I&#x2F;G位&#x3D;0，地址字段表示一个单站地址；当I&#x2F;G位&#x3D;1，地址字段表示一个组地址。所有48位都为1，地址字段是广播地址。</p>
<p>IEEE规定地址字段的第一字节最低位为G&#x2F;L位。G&#x2F;L表示Global&#x2F;Local。当G&#x2F;L位&#x3D;0，是全球管理（保证在全球没有相同的地址），厂商向IEEE购买的OUI都属于全球管理。当G&#x2F;L位&#x3D;1，是本地管理，这时用户可任意分配网络上的地址。</p>
<ul>
<li>MAC地址是<strong>唯一</strong>的，每个网络设备都会被分配一个唯一的MAC地址。MAC地址通常被写在设备的网卡上，由网卡芯片固化在硬件中。在以太网中，MAC地址被用于识别数据包发送者和接收者。</li>
</ul>
<p>当一个数据包从源设备发送到目的设备时，数据包中会包含源MAC地址和目的MAC地址。网络设备通过比对数据包中的目的MAC地址和自己的MAC地址，来判断是否接收该数据包。如果目的MAC地址与设备的MAC地址相同，设备就会接收该数据包并进行处理，否则就会忽略该数据包。<br>总之，MAC地址是网络设备的一个重要标识，它是由网络设备的物理硬件决定的，一般情况下不会改变。它在网络通信中起到了重要的作用。</p>
<h5><span id="适配器检查mac地址">适配器检查MAC地址</span></h5><ul>
<li><p>适配器（Network Adapter）是计算机中用于连接计算机与网络之间的设备，也称为网卡（Network Interface Card）。在计算机网络中，适配器通常用于接收和发送网络数据包。</p>
</li>
<li><p>适配器通常具有一个硬件地址，也称为MAC地址。检查MAC地址是指在数据包到达适配器时，适配器会首先检查数据包中的目的MAC地址是否与自己的MAC地址相同。</p>
</li>
</ul>
<p>相同，接收该数据包并将其传递给计算机进行处理。</p>
<p>不同，忽略该数据包。</p>
<ul>
<li><p>“发往本站的帧”包括：单播帧（一对一，即收到的帧的MAC地址与本站硬件地址相同）、广播帧（一对全体，即发送给本局域网上所有站点的帧，全1地址）和多播帧（一对多，即发送给本局域网一部分站点的帧）。</p>
</li>
<li><p>所有的适配器都至少能够识别前两种帧，即能识别单播地址和广播地址。</p>
</li>
<li><p>只有目的地址才能使用广播地址和多播地址。</p>
</li>
</ul>
<h4><span id="mac帧的格式">MAC帧的格式</span></h4><ul>
<li>常用的以太网MAC帧格式有两种标准：DIX Ethernet V2标准（以太网V2标准）和IEEE的802.3标准。</li>
</ul>
<h5><span id="以太网v2标准的mac帧格式">以太网V2标准的MAC帧格式</span></h5><p>以太网的帧最短是64字节，而现在目的地址，原地址，类型和FCS占了18字节，所以IP数据报有效数据最小是46字节。</p>
<table>
<thead>
<tr>
<th align="center">前同步码</th>
<th align="center">SFD</th>
<th align="center">目的地址</th>
<th align="center">源地址</th>
<th align="center">类型</th>
<th align="center">数据（IP数据报）</th>
<th align="center">FCS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7byte</td>
<td align="center">1byte</td>
<td align="center">6byte</td>
<td align="center">6byte</td>
<td align="center">2byte</td>
<td align="center">46~1500byte</td>
<td align="center">4byte</td>
</tr>
</tbody></table>
<p>从目的地址到FCS为一个以太网MAC帧。</p>
<ol>
<li><p>前导码（前同步码）（Preamble）：7个字节的前导码，用于标识一个数据帧的开始，具体内容为1010……1010。</p>
</li>
<li><p>帧起始定界符（Start Frame Delimiter，SFD）：1个字节的帧起始定界符，用于标识前导码的结束，内容为10101011。</p>
</li>
<li><p>目的MAC地址（Destination MAC Address）：6个字节的目的MAC地址，表示接收数据包的设备的MAC地址。</p>
</li>
<li><p>源MAC地址（Source MAC Address）：6个字节的源MAC地址，表示发送数据包的设备的MAC地址。</p>
</li>
<li><p>以太网类型（Ethernet Type）：2个字节的以太网类型字段，用于指示数据帧中携带的数据的类型。常见的以太网类型有IP协议、ARP协议等。</p>
</li>
<li><p>数据（Data）：46~1500个字节的数据，用于携带传输的信息。当数据字段的长度小于46字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的MAC帧长不小于64字节。</p>
</li>
<li><p>帧校验序列（Frame Check Sequence，FCS）：4个字节的帧校验序列，用于检测数据帧是否出错。FCS是通过CRC算法生成的，它包含了整个数据帧的数据内容。当传输媒体的误码率为$1×10^{-8}$时，MAC子层可使未检测到的差错小于$1×10^{-14}$。</p>
</li>
</ol>
<h5><span id="ieee8023mac-帧格式">IEEE802.3MAC 帧格式</span></h5><ol>
<li><p>前导码（Preamble）：7个字节的前导码，用于标识一个数据帧的开始，具体内容为1010……1010。</p>
</li>
<li><p>帧起始定界符（Start Frame Delimiter，SFD）：1个字节的帧起始定界符，用于标识前导码的结束，内容为10101011。</p>
</li>
<li><p>目的MAC地址（Destination MAC Address）：6个字节的目的MAC地址，表示接收数据包的设备的MAC地址。</p>
</li>
<li><p>源MAC地址（Source MAC Address）：6个字节的源MAC地址，表示发送数据包的设备的MAC地址。</p>
</li>
<li><p>长度&#x2F;类型（Length&#x2F;Type）：2个字节的长度&#x2F;类型字段，用于指示数据帧中携带的数据的类型。如果该字段的值小于等于1500，则表示该字段指示了数据的长度；否则，表示该字段指示了数据的类型，例如IP协议、ARP协议等。</p>
</li>
<li><p>数据（Data）：46~1500个字节的数据，用于携带传输的信息。</p>
</li>
<li><p>帧校验序列（Frame Check Sequence，FCS）：4个字节的帧校验序列，用于检测数据帧是否出错。FCS是通过CRC算法生成的，它包含了整个数据帧的数据内容。</p>
</li>
<li><p>帧间隔（Interframe Gap，IFG）：12个字节的帧间隔，用于在两个数据帧之间进行时序的调整，以保证数据传输的稳定性。</p>
</li>
</ol>
<ul>
<li>与以太网V2MAC帧格式相似，区别在于：</li>
</ul>
<ol>
<li>IEEE 802.3规定的MAC帧的第三个字段是“长度&#x2F;类型”。</li>
</ol>
<p>当这个字段值大于0x0600时（相当于十进制的1536），就表示“类型”。这样的帧和以太网V2 MAC 帧完全一样。</p>
<p>当这个字段值小于0x0600时才表示“长度”。</p>
<ol start="2">
<li>当“长度&#x2F;类型”字段值小于0x0600时，数据字段必须装入上面的逻辑链路控制LLC子层的LLC帧。</li>
</ol>
<p>现在市场上流行的都是以太网V2的MAC帧，但大家也常常称为IEEE 802.3标准的MAC帧。</p>
<h5><span id="无效mac帧">无效MAC帧</span></h5><ul>
<li><p>数据字段的长度与长度字段的值不一致；</p>
</li>
<li><p>帧的长度不是整数个字节；</p>
</li>
<li><p>用收到的帧检验序列FCS查出有差错;</p>
</li>
<li><p>数据字段的长度不在46~1500字节之间。</p>
</li>
<li><p>有效的MAC帧长度为64~1518字节之间。</p>
</li>
<li><p>对于检查出的无效MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</p>
</li>
</ul>
<h5><span id="帧的最小间隔">帧的最小间隔</span></h5><ul>
<li>帧间最小间隔为9.6 μs，相当于96 bit的发送时间。</li>
</ul>
<p>一个站在检测到总线开始空闲后，还要等待9.6μs才能再次发送数据。</p>
<p>这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p>
<h2><span id="扩展的以太网">扩展的以太网</span></h2><h3><span id="在物理层扩展以太网">在物理层扩展以太网</span></h3><ul>
<li><p>使用光纤扩展</p>
</li>
<li><p>使用集线器扩展</p>
</li>
</ul>
<p>集线器集联：使网络中计算机增加，变成一个大的冲突域，冲突域数量变少了，但是数量增加了，会造成效率降低。（越多效率越低，不适合使用超过30个集线器）</p>
<p>优点：使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。扩大了以太网覆盖的地理范围。</p>
<p>缺点：碰撞域增大了，但总的吞吐量并未提高。如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</p>
<h3><span id="在数据链路层扩展以太网更常用的方法">在数据链路层扩展以太网(更常用的方法)</span></h3><ul>
<li>早期使用网桥，现在使用以太网交换机。</li>
</ul>
<h4><span id="使用网桥">使用网桥</span></h4><ul>
<li><p>在数据链路层扩展局域网是使用网桥。使用网桥可以拓展以太网的覆盖范围和提高网络性能。网桥是一种数据链路层设备，它可以连接多个以太网段，将它们组成一个逻辑上的单一网络。网桥通过学习每个网络中的MAC地址，将数据包从一个网络转发到另一个网络，从而实现不同网络之间的通信。</p>
</li>
<li><p>网桥工作在数据链路层，他根据MAC帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到对应的接口，或把它丢弃。</p>
</li>
<li><p>使用网桥拓展以太网的步骤如下：</p>
</li>
</ul>
<ol>
<li><p>确定网络拓扑结构：首先需要确定网络中存在的以太网段，以及它们之间的连接方式和拓扑结构。根据网络拓扑结构，选择合适的网桥类型和数量。</p>
</li>
<li><p>配置网桥参数：将网桥接入网络中，配置网桥的参数，如MAC地址、IP地址、子网掩码等。这些参数可以通过网桥设备的管理接口进行配置。</p>
</li>
<li><p>学习MAC地址：网桥通过学习每个以太网段中的MAC地址，建立MAC地址表，记录每个MAC地址所在的网络段。当网桥收到一个数据包时，它会查询MAC地址表，将数据包转发到目标网络段中的设备。</p>
</li>
<li><p>转发数据包：当网桥接收到一个数据包时，它会首先检查目标MAC地址所在的网络段是否与源MAC地址所在的网络段相同。如果目标MAC地址不在同一网络段中，则网桥会将数据包转发到目标网络段中；否则，网桥会将数据包丢弃。<br>使用网桥可以将多个以太网段组成一个逻辑上的单一网络，提高网络的可靠性和性能。同时，网桥还可以隔离不同的网络段，防止网络中的广播风暴和冲突，提高网络的安全性和稳定性。</p>
</li>
</ol>
<ul>
<li>网桥的自学习算法：</li>
</ul>
<p>若从A发出的帧从接口x进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到A。网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面。在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。</p>
<ul>
<li>好处</li>
</ul>
<p>过滤了通信量；扩大了物理范围；提高了可靠性；可互联不同的物理层，不同MAC子层和不同速率。</p>
<ul>
<li>坏处</li>
</ul>
<p>存储转发增加了时延；在MAC地址子层并没有流量控制功能；具有不同MAC子层的网段桥接在一起时时延更大；网桥值适合于用户数不太多和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。</p>
<h4><span id="使用以太网交换机">使用以太网交换机</span></h4><ul>
<li><p>以太网交换机实质上就是一个多接口的网桥，通常都有十几个或更多的接口。</p>
</li>
<li><p>每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。</p>
</li>
<li><p>以太网交换机的交换方式：存储转发方式、直通（cutthrough）方式</p>
</li>
<li><p>以太网交换机的特点：</p>
</li>
</ul>
<ol>
<li><p>高性能：以太网交换机采用硬件转发方式，能够实现高速数据传输和低延迟。通过交换机的缓存和转发能力，可以提高网络的吞吐量和性能。</p>
</li>
<li><p>灵活性：以太网交换机支持多种接口类型和速率，可以适应不同的网络环境和需求。同时，交换机还支持多种协议和网络服务，如VLAN、QoS等，提供更加灵活的网络配置和管理方式。</p>
</li>
<li><p>自学习：交换机可以自动学习网络中每个设备的MAC地址，并建立MAC地址表，记录设备的物理地址和端口号。当交换机收到一个数据包时，它会查询MAC地址表，将数据包转发到目标设备的端口上。</p>
</li>
<li><p>分割冲突域：以太网交换机将每个端口作为一个独立的冲突域，可以防止网络中的冲突和广播风暴。这种方式可以提高网络的可靠性和稳定性。</p>
</li>
<li><p>透明性：以太网交换机对网络上的设备和协议是透明的，不会影响设备之间的通信和网络协议的运行。同时，交换机还支持多种网络协议，如TCP&#x2F;IP、UDP、ICMP等，提供更加灵活的网络应用方式。</p>
</li>
</ol>
<h5><span id="以太网交换机的自学习功能">以太网交换机的自学习功能</span></h5><ul>
<li>以太网交换机的自学习功能的具体操作流程</li>
</ul>
<ol>
<li><p>当交换机接收到一个新的数据帧时，它会检查该帧的目标MAC地址，并将该地址与其端口关联起来，将该地址记录到其转发表中。</p>
</li>
<li><p>如果转发表中已经有了目标MAC地址的条目，则交换机可以直接将数据帧发送到对应的端口，而无需对所有端口进行广播。</p>
</li>
<li><p>如果转发表中没有目标MAC地址的条目，则交换机会将数据帧广播到所有连接的端口上，并记录下发送这个数据帧的源MAC地址和相应的端口信息。</p>
</li>
<li><p>一旦交换机确定了结构记录在转发表中的目标地址所对应的端口，它就只向那一个端口发送数据帧。</p>
</li>
<li><p>当交换机接收到新的数据帧时，它会再次更新转发表，删除多余或错误的信息，并学习记录新的MAC地址和端口信息。</p>
</li>
</ol>
<h5><span id="交换机使用生成树协议">交换机使用生成树协议</span></h5><ul>
<li><p>IEEE802.1D标准制定了一个生成树协议STP，用于消除兜圈子死循环现象。</p>
</li>
<li><p>生成树协议（Spanning Tree Protocol，STP）是一种用于以太网交换机网络中避免环路的协议。STP通过建立一棵生成树，保证网络中只有一条主干路径，从而避免数据包在网络中不断循环，造成网络拥塞和死锁。</p>
<ul>
<li>生成树算法（Spanning Tree Algorithm）是用于实现生成树协议的具体算法，最常用的是经典的 IEEE 802.1D 标准，该标准定义了以下步骤：</li>
</ul>
</li>
</ul>
<ol>
<li><p>选举根桥：在网络中，选举一个交换机作为根桥。根桥的选择通常是根据交换机的优先级和MAC地址来确定的。</p>
</li>
<li><p>计算路径开销：每个交换机计算到根桥的路径开销，路径开销包括端口的开销和链路的开销。其中，端口的开销是指端口的优先级和状态，链路的开销是指链路的带宽和延迟等因素。</p>
</li>
<li><p>选举根端口：每个非根交换机选举一个根端口，选举原则是选择路径开销最小的端口作为根端口。如果有多个端口开销相等，则根据端口的优先级和MAC地址来选择。</p>
</li>
<li><p>选举指定端口：每个交换机选举一个指定端口，指定端口是指连接网络中某个设备的端口。选举原则是选择路径开销次小的端口作为指定端口。如果有多个端口开销相等，则根据端口的优先级和MAC地址来选择。</p>
</li>
<li><p>阻塞端口：在生成树中，如果存在环路，则需要选择一些端口进行阻塞，从而避免数据包在网络中不断循环。阻塞端口是指连接到环路上的端口，选举原则是选择路径开销最大的端口进行阻塞。</p>
</li>
</ol>
<h5><span id="从总线以太网到星形以太网">从总线以太网到星形以太网</span></h5><ul>
<li><p>从总线以太网到星形以太网是以太网架构的演进历程，总线以太网是最早的以太网架构，所有设备共享同一条传输介质。而星形以太网采用了集线器&#x2F;交换机来分割网络，将每个设备连接到一个中心节点，从而提高了网络的可靠性和性能。</p>
</li>
<li><p>总线以太网使用CSMA&#x2F;CD协议，以半双工方式工作，存在碰撞问题。而以太网交换机实现的星形以太网以全双工方式工作，不存在碰撞问题，但由于帧结构未改变，仍采用以太网的帧结构，所以还叫做以太网。</p>
</li>
</ul>
<h3><span id="虚拟局域网">虚拟局域网</span></h3><ul>
<li><p>虚拟局域网（Virtual Local Area Network，VLAN）是一种将物理网络划分为多个逻辑网络的技术。VLAN可以通过软件配置来实现，无需更改物理网络拓扑结构，从而方便网络管理和配置。</p>
</li>
<li><p>VLAN可以将一组网络设备划分为一个独立的逻辑网络，不同的VLAN之间可以相互隔离，从而提高网络安全性和灵活性。例如，可以将某个部门的计算机划分到一个VLAN中，使得该部门的计算机只能与该VLAN中的其他设备进行通信，而无法与其他VLAN中的设备通信。</p>
</li>
<li><p>VLAN的实现可以基于端口、MAC地址、IP地址等多种方式，常见的实现方式包括：</p>
</li>
</ul>
<ol>
<li><p>基于端口：将交换机的端口划分到不同的VLAN中，不同VLAN之间通过路由器进行通信。</p>
</li>
<li><p>基于MAC地址：将设备的MAC地址作为VLAN的标识符，相同VLAN中的设备拥有相同的MAC地址前缀。</p>
</li>
<li><p>基于IP地址：将设备的IP地址作为VLAN的标识符，相同VLAN中的设备拥有相同的IP地址前缀。</p>
</li>
</ol>
<ul>
<li>VLAN的优点包括：</li>
</ul>
<ol>
<li><p>提高网络安全性：不同的VLAN之间可以相互隔离，从而避免未经授权的访问和攻击。</p>
</li>
<li><p>灵活性高：可以根据不同的需求和场景，灵活地划分不同的VLAN，从而提高网络的灵活性和可扩展性。</p>
</li>
<li><p>管理和配置方便：VLAN的管理和配置可以通过软件进行，无需更改物理网络拓扑结构，从而方便网络管理和配置。<br>综上所述，VLAN是一种将物理网络划分为多个逻辑网络的技术，可以提高网络安全性和灵活性，方便网络管理和配置。</p>
</li>
</ol>
<ul>
<li>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</li>
</ul>
<h4><span id="虚拟局域网使用的以太网帧格式">虚拟局域网使用的以太网帧格式</span></h4><ul>
<li>虚拟局域网（VLAN）使用的以太网帧格式与普通的以太网帧格式基本一致，但在帧头和帧尾中加入了VLAN标记。下面是VLAN使用的以太网帧格式：</li>
</ul>
<ol>
<li><p>目的MAC地址（6个字节）：表示帧的接收方的MAC地址。</p>
</li>
<li><p>源MAC地址（6个字节）：表示帧的发送方的MAC地址。</p>
</li>
<li><p>VLAN标记（4个字节）：包含802.1Q标记类型和标记控制信息。</p>
</li>
</ol>
<p>VLAN标记的前两个字节总是设置为0x8100（即二进制10000001 00000000），称为IEEE802.1Q标记类型。</p>
<p>当数据链路层检测到MAC帧的源地址字段后面的两个字节值为0x8100时，就知道现在插入了4字节的VLAN标记。于是就接着检查后面两个字节的内容。后面的两个字节，前3位时用户优先级字段，接着的一位时规范格式提示符CFI（Canonical Format Indicator），最后12位时该虚拟局域网VLAN标识符VID（VLAN ID）唯一标志这个以太网帧属于哪一个VLAN。</p>
<ol start="4">
<li><p>类型&#x2F;长度字段（2个字节）：表示帧中上层协议的类型或数据长度。</p>
</li>
<li><p>数据字段（46~1500个字节）：表示上层协议的数据。</p>
</li>
<li><p>帧校验序列（FCS）（4个字节）：对整个帧进行校验，用于检测传输错误。</p>
</li>
<li><p>帧尾（1个字节）：表示帧的结束。</p>
</li>
</ol>
<h2><span id="高速以太网">高速以太网</span></h2><ul>
<li>高速以太网（High-Speed Ethernet)是一种以太网技术，用于实现高速数据传输。</li>
</ul>
<h3><span id="100base-t以太网">100BASE-T以太网</span></h3><ul>
<li><p>100BASE-T是一种以太网技术，也被称为快速以太网。它可以在100Mbps的传输速度下运行，并且使用双绞线作为物理媒介来传输数据。</p>
</li>
<li><p>100BASE-T以太网使用了交织的4B&#x2F;5B编码方案来将字节转换为信号。这种编码方案可以保证数据传输的稳定性和可靠性。它还使用了基带传输技术，即直接将数字信号发送到传输媒介上，避免了模拟信号的转换，从而提高了传输效率。</p>
</li>
<li><p>在100BASE-T以太网中，数据通过RJ-45插座连接到双绞线上，双绞线再连接到集线器或交换机等网络设备上。由于采用了CSMA&#x2F;CD协议，所以多台计算机可以同时使用同一个以太网来进行通信。</p>
</li>
<li><p>100Base-T以太网的物理层标准</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">媒体</th>
<th align="center">网段的最大长度</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100BASE-TX</td>
<td align="center">铜缆</td>
<td align="center">100m</td>
<td align="center">两对UTP5类线或屏蔽双绞线STP</td>
</tr>
<tr>
<td align="center">100BASE-T4</td>
<td align="center">铜缆</td>
<td align="center">100m</td>
<td align="center">4对UTP3类线或5类线</td>
</tr>
<tr>
<td align="center">100BASE-FX</td>
<td align="center">光缆</td>
<td align="center">2000m</td>
<td align="center">两根光纤，发送和接收各一根</td>
</tr>
</tbody></table>
<ul>
<li>特点</li>
</ul>
<p>可以实现全双工通信(注意，如果交换机上某一路连接着集线器(半双工)，则这一路不能实现全双工)而无冲突，此时不使用CSMA&#x2F;CD协议。</p>
<p>MAC帧格式不变，仍是802.3 标准。</p>
<p>最短帧长度不变，但是一个网段的最大电缆长度减少到100m。</p>
<p>帧间间隔从9.6微秒缩小到0.96微秒。</p>
<h3><span id="吉比特以太网">吉比特以太网</span></h3><ul>
<li><p>允许在1 Gb&#x2F;s下全双工或半双工工作方式。</p>
</li>
<li><p>使用802.3标准的帧格式。</p>
</li>
<li><p>在半双工下使用CSMA&#x2F;CD协议。</p>
</li>
<li><p>当吉比特以太网在全双工方式时，不用载波延伸和分组冲突。</p>
</li>
<li><p>与10Base-T和100Base-T技术向后兼容。</p>
</li>
<li><p>1000Base-X以太网的物理层：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">媒体</th>
<th align="center">网段最大长度</th>
<th align="center">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000BASE-SX</td>
<td align="center">光缆</td>
<td align="center">550m</td>
<td align="center">多模光纤（50和62.5μm）</td>
</tr>
<tr>
<td align="center">1000BASE-LX</td>
<td align="center">光缆</td>
<td align="center">5000m</td>
<td align="center">单模光纤（10μm）多模光纤（50和62.5μm）</td>
</tr>
<tr>
<td align="center">1000BASE-CX</td>
<td align="center">铜缆</td>
<td align="center">25m</td>
<td align="center">使用2对屏蔽双绞线电缆STP</td>
</tr>
<tr>
<td align="center">1000BASE-T</td>
<td align="center">铜缆</td>
<td align="center">100m</td>
<td align="center">使用4对UTP5类线</td>
</tr>
</tbody></table>
<h3><span id="10吉比特以太网和更快的以太网">10吉比特以太网和更快的以太网</span></h3><ul>
<li><p>MAC帧格式不变，仍是802.3 标准。</p>
</li>
<li><p>使用光纤而不是铜线。</p>
</li>
<li><p>只能工作在全双工方式，没有争用问题。</p>
</li>
<li><p>它的出现使工作范围从局域网扩大到城域网和广域网，实现了端到端的以太网传输。</p>
</li>
<li><p>优点：技术成熟；互操作性好；广域网中使用以太网便宜；统一的帧格式。</p>
</li>
<li><p>40GB&#x2F;100GB以太网物理层标准</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">物理层</th>
<th align="center">40GB以太网</th>
<th align="center">10GB以太网</th>
</tr>
</thead>
<tbody><tr>
<td align="center">在背板上传输至少超过1m</td>
<td align="center">40GBASE-KR4</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">在铜缆上传输至少超过7m</td>
<td align="center">40GBASE-CR4</td>
<td align="center">100GBASE-CR10</td>
</tr>
<tr>
<td align="center">在多模光纤上传输至少超过10m</td>
<td align="center">40GBASE-SR4</td>
<td align="center">100GBASE-SR10，100GBASE-SR4</td>
</tr>
<tr>
<td align="center">在单模光纤上传输至少超过10km</td>
<td align="center">40GBASE-LR4</td>
<td align="center">100GBASE-LR4</td>
</tr>
<tr>
<td align="center">在单模光纤上传输至少超过40km</td>
<td align="center">40GBASE-ER4</td>
<td align="center">100GBASE-ER4</td>
</tr>
</tbody></table>
<ul>
<li>以太网时可扩展的（速率从100Mbit&#x2F;s到100Gbit&#x2F;s）、灵活的（多媒体、全&#x2F;半双工、共享&#x2F;交换）、易于安装、稳健性好。</li>
</ul>
<h3><span id="使用以太网进行宽带接入">使用以太网进行宽带接入</span></h3><ul>
<li>以太网是一种计算机局域网技术，它可以通过使用特定的物理介质（如双绞线或光纤）将计算机设备连接到互联网服务提供商（ISP）的网络中。在宽带接入方案中，以太网通常用于将用户家庭或办公室内的路由器或调制解调器与ISP提供的宽带调制解调器相连接。这种连接方式可以提供高速、可靠的互联网连接，并且可以支持多个用户同时访问互联网。在以太网上实现宽带接入需要使用特定的协议和技术，例如动态主机配置协议（DHCP）、传输控制协议&#x2F;互联网协议（TCP&#x2F;IP）和数据包交换技术等。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>物理层</tag>
        <tag>数据链路层</tag>
      </tags>
  </entry>
  <entry>
    <title>一个小巧的Markdown编辑工具</title>
    <url>/%E8%BD%AF%E4%BB%B6/tools1/</url>
    <content><![CDATA[<p>介绍一个小巧方便的编写Markdown语言工具。</p>
<ol>
<li><p>什么是Markdown</p>
</li>
<li><p>MarkText</p>
</li>
<li><p>进阶使用</p>
</li>
</ol>
<p>关键词：Markdown工具</p>
<span id="more"></span>

<hr>
<h1><span id="什么是markdown">什么是Markdown</span></h1><ul>
<li><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
</li>
<li><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
</li>
<li><p>Markdown可用于编写记录笔记、博客、电子书等电子文档。</p>
</li>
</ul>
<h1><span id="marktext">MarkText</span></h1><ul>
<li>MarkText是一款开源的Markdown工具，可用于编辑输出Markdown文件。本人推荐的是英文语言软件，如何汉化自行研究。</li>
</ul>
<p>软件地址：建议安装到非系统盘（非C盘）</p>
<p><a href="https://github.com/marktext/marktext/releases">MarkText下载 - 官网</a></p>
<p><a href="https://www.aliyundrive.com/s/CoADkVDj1Sq">MarkText下载 - 个人网盘（Windows64位）</a></p>
<ul>
<li>MarkText具有多个明暗主题选择，软件菜单内容明确，主打轻便，是一款很不错的小工具。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%B8%BB%E7%95%8C%E9%9D%A2.jpg" alt="软件界面（明亮主题）"></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%B8%BB%E7%95%8C%E9%9D%A22.jpg" alt="软件界面（灰暗主题）"></p>
<ul>
<li>使用方法</li>
</ul>
<p>输入<code>@</code>选择插入的模块，包括段落、分割线、标题、表格、数学公式、引用块、列表等。如果本身对于Markdown语言有一定基础的话，也可直接建立该模块。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%BD%BF%E7%94%A81.jpg" alt="使用过程"></p>
<p>在编写完内容后，可以直接保存为Markdown文件（<code>.md</code>后缀），也可以导出为PDF文件和HTML文件。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E4%BF%9D%E5%AD%98.jpg" alt="选择保存"></p>
<h1><span id="进阶使用">进阶使用</span></h1><ul>
<li>有时候对于PDF文件，会有显示目录大纲的需求，但是该软件直接导出并不能设置，此时需要借助另一个工具：wkhtmltopdf。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.jpg" alt="带目录的PDF文件"></p>
<ul>
<li><strong>wkhtmltopdf</strong></li>
</ul>
<p>一款<strong>将HTML文件转化为PDF文件</strong>的小工具，但是其并没有软件UI界面，对小白不友好，但是万能的网络能搜到使用方法，此处针对如何导出带目录的PDF进行介绍。</p>
<ol>
<li>下载软件</li>
</ol>
<p>下载地址：可能提示有风险，建议安装到非系统盘（非C盘）</p>
<p><a href="https://wkhtmltopdf.org/downloads.html">wkhtmltopdf下载 - 官网</a></p>
<p><a href="https://www.aliyundrive.com/s/V4SBUcntBAv">wkhtmltopdf下载 - 个人网盘（Windows64位）</a></p>
<ol start="2">
<li>安装并配置</li>
</ol>
<p>安装后，需要记住安装的具体位置，比如我是安装在D盘，位置就是<code>D:\wkhtmltopdf</code>，接着进行系统环境变量的配置。在电脑设置中搜索环境变量，打开编辑页面。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.jpg" alt="配置环境变量"></p>
<p>具体步骤：编辑→新建→输入安装的位置里面的bin文件夹即<code>D:\wkhtmltopdf\bin</code>→确定所有系统设置窗口。</p>
<p>（添加错误的环境变量并不会对电脑造成严重伤害，但不要胡乱删除环境变量）</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%90%8E.jpg" alt="配置环境变量后"></p>
<p>再接着确认环境变量是否配置成功：按快捷键<code>win+r</code>，输入cmd，打开黑窗口，在窗口内输入<code>wkhtmltopdf -V</code>（查询wkhtmltopdf的版本），如果出现类似于版本号的数字，则说明添加环境变量成功。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_cmd.jpg" alt="配置成功"></p>
<ol start="3">
<li>软件使用</li>
</ol>
<p>在cmd黑窗口切换到想要HTML文件转换为PDF文件的位置，直接输入<code>F:</code>切换到不同的盘，输入<code>cd xx</code>可以进入不同文件夹。如果不知道自己是什么路径，可以先进入所在盘，再打开文件所在文件夹，在地址栏点击获得路径，然后复制粘贴到黑窗口进入。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E8%BF%9B%E5%85%A5%E6%96%87%E4%BB%B6%E5%A4%B9.jpg" alt="进入工作文件夹"></p>
<p>接着回到MarkText软件，将文件导出为HTML文件，保存在特定文件夹，该文件夹应该跟cmd黑窗口进入的文件夹一样。举例时，我将该文件保存为<code>test.html</code>文件在<code>F:\14.Books</code>文件夹。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E5%AF%BC%E5%87%BAHTML.jpg" alt="导出HTML"></p>
<p>再回到黑窗口，使用命令<code>wkhtmltopdf 目的文件名字 新文件名字</code>转换，我这里应该是<code>wkhtmltopdf test.html test.pdf</code>。等待转换成功。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_%E8%BD%AC%E6%8D%A2%E6%88%90%E5%8A%9F.jpg" alt="转换成功"></p>
<p>此时回到文件夹，就可以看到转换完成的带目录的PDF文件。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools1_test.jpg" alt="转换成功的PDF文件"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Markdown工具</tag>
      </tags>
  </entry>
  <entry>
    <title>一个便捷的启动小工具</title>
    <url>/%E8%BD%AF%E4%BB%B6/tools2/</url>
    <content><![CDATA[<p>介绍一个便捷的启动工具、搜索工具——Flow Launcher</p>
<p>关键词：启动工具</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#1-flow-launcher">1. Flow Launcher</a></li>
<li><a href="#2%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C">2.使用体验</a></li>
<li><a href="#3%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD">3.软件下载</a></li>
<li><a href="#4%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE">4.使用建议</a></li>
</ul>
<!-- tocstop -->

<h1><span id="1-flow-launcher">1. Flow Launcher</span></h1><p>Flow Launcher是一款快速启动软件或者打开文件的工具。</p>
<p>其特点有：</p>
<ul>
<li>整合了Everything搜索工具</li>
<li>日期时间显示</li>
<li>文件拖拽</li>
<li>支持缩写</li>
<li>可导入插件</li>
<li>……</li>
</ul>
<h1><span id="2使用体验">2.使用体验</span></h1><p>软件界面简约，可设置多款主题、字体。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E6%95%B4%E4%BD%93%E9%A2%84%E8%A7%88.jpg" alt="软件界面"></p>
<p>设置面板条理清晰，支持自定义，配置一个适合自己的工具。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E8%AE%BE%E7%BD%AE%E9%9D%A2%E6%9D%BF.jpg" alt="设置面板"></p>
<p>搜索过程简单，直接输入马上得到结果，很适合文件太多不想一个个去翻的人。点击即可打开文件或打开应用。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E6%90%9C%E7%B4%A2%E4%BD%93%E9%AA%8C.jpg" alt="搜索过程"></p>
<p>支持各种命令，支持缩写。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E6%8C%87%E4%BB%A4.jpg" alt="关机指令"></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E6%8C%87%E4%BB%A42.jpg" alt="关机指令"></p>
<h1><span id="3软件下载">3.软件下载</span></h1><p><a href="https://www.flowlauncher.com/">官网下载</a><br><a href="https://github.com/Flow-Launcher/Flow.Launcher">Github源码</a></p>
<h1><span id="4使用建议">4.使用建议</span></h1><ul>
<li>开机自启，占用率不算很高，很是方便。</li>
<li>开启便携模式，增加结果显示个数。<br><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E5%BB%BA%E8%AE%AE.jpg" alt="使用建议1"></li>
<li>设置好默认文件管理器，默认浏览器。</li>
<li>自定义插件设置（如默认网页搜索引擎等）。<br><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/tools2_%E5%BB%BA%E8%AE%AE2.jpg" alt="使用建议2"></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>启动工具</tag>
      </tags>
  </entry>
  <entry>
    <title>两个用过的导航页</title>
    <url>/%E7%BD%91%E9%A1%B5/%E5%AF%BC%E8%88%AA%E9%A1%B5/</url>
    <content><![CDATA[<p>介绍两个我常用的导航页。导航页就是一个网站的目录，其包含了很多常用其他网站的快捷方式。</p>
<ol>
<li><p>果汁导航页</p>
</li>
<li><p>青柠起始页</p>
</li>
</ol>
<ul>
<li>附设置浏览器起始页</li>
</ul>
<p>关键词：导航页</p>
<span id="more"></span>

<hr>
<ol>
<li>果汁导航</li>
</ol>
<p>果汁导航页包括互联网搜索功能，还有各种生活学习用到的网页快捷方式。每层目录下还收纳了很多相关网站，包括影视、知识、新闻、等网站，丰富度很高，也很容易因为内容太多眼花缭乱忘记了有这么样的功能。更多功能可以自己探索发现收藏。可登录使用也可不登录使用。</p>
<p>地址：<a href="http://guozhivip.com/">果汁导航 - guozhivip.com</a></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E6%9E%9C%E6%B1%81%E8%B5%84%E6%BA%90%E5%AF%BC%E8%88%AA.png" alt="果汁导航"></p>
<ol start="2">
<li>青柠起始页</li>
</ol>
<p>一个简约的起始页，具有搜索功能，当搜索框聚焦时，背景具有毛玻璃效果。点击时钟可以到达另一页，此页可以添加一些常用的网站快捷方式（需登录），自定义程度高。丰富度不高，简约型网站。</p>
<p>地址：<a href="https://limestart.cn/">青柠起始页 - limestart.cn</a></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E9%9D%92%E6%9F%A0%E8%B5%B7%E5%A7%8B%E9%A1%B5.jpg" alt="青柠起始页主页"></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E9%9D%92%E6%9F%A0%E8%B5%B7%E5%A7%8B%E9%A1%B51.jpg" alt="青柠起始页附页"></p>
<ul>
<li>附：设置为浏览器起始页</li>
</ul>
<p>以Edge浏览器为例，打开设置页面，选择<code>开始、主页和新建标签页</code>，将启动时页面改为想要的导航页，更方便自己浏览器使用。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/%E5%AF%BC%E8%88%AA%E9%A1%B5_%E8%AE%BE%E7%BD%AE.jpg" alt="设置"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>网页</category>
      </categories>
      <tags>
        <tag>导航页</tag>
      </tags>
  </entry>
  <entry>
    <title>基于YOLOv5的电瓶车识别入门级项目记录</title>
    <url>/%E7%AC%94%E8%AE%B0/yolov5/</url>
    <content><![CDATA[<p>一次基于YOLOv5的深度学习项目，在GPU服务器完成模型训练，在Windows 10下进行图像识别推理（C++）。</p>
<p>关键词：深度学习、YOLOv5、C++推演、TensorRT、OpenCV</p>
<span id="more"></span>

<hr>
<!-- toc -->

<ul>
<li><a href="#%E9%9B%B6-%E5%89%8D%E8%A8%80">零 —— 前言</a></li>
<li><a href="#%E5%A3%B9-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87">壹 —— 环境准备</a></li>
<li><a href="#%E8%B4%B0-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">贰 —— 数据准备</a><ul>
<li><a href="#21-%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BB%93%E6%9E%84">2.1 数据集结构</a></li>
<li><a href="#22-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E9%9B%86">2.2 处理数据集</a></li>
</ul>
</li>
<li><a href="#%E5%8F%81-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%8F%8A%E5%88%86%E6%9E%90">叁 —— 模型训练及分析</a><ul>
<li><a href="#31-%E9%83%A8%E7%BD%B2yolov5">3.1 部署YOLOv5</a><ul>
<li><a href="#311-%E4%BD%BF%E7%94%A8%E7%A4%BE%E5%8C%BA%E9%95%9C%E5%83%8F%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2yolov5">3.1.1 使用社区镜像自动部署YOLOv5</a></li>
<li><a href="#312-%E6%89%8B%E5%8A%A8%E9%83%A8%E7%BD%B2yolov5">3.1.2 手动部署YOLOv5</a></li>
</ul>
</li>
<li><a href="#32-%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE">3.2 上传数据</a></li>
<li><a href="#33-%E9%85%8D%E7%BD%AE%E8%AE%AD%E7%BB%83%E5%8F%82%E6%95%B0">3.3 配置训练参数</a><ul>
<li><a href="#331-%E4%BF%AE%E6%94%B9trainpy%E6%96%87%E4%BB%B6">3.3.1 修改train.py文件</a></li>
<li><a href="#332-%E4%BF%AE%E6%94%B9valpy%E6%96%87%E4%BB%B6">3.3.2 修改val.py文件</a></li>
<li><a href="#333-%E4%BF%AE%E6%94%B9%E6%A8%A1%E5%9E%8B%E9%85%8D%E7%BD%AE">3.3.3 修改模型配置</a></li>
</ul>
</li>
<li><a href="#34-%E8%AE%AD%E7%BB%83%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98">3.4 训练可能出现的问题</a></li>
<li><a href="#35-%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90">3.5 训练结果分析</a><ul>
<li><a href="#351-%E4%BF%9D%E5%AD%98%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C">3.5.1 保存训练结果</a></li>
<li><a href="#352-%E6%9B%B2%E7%BA%BF%E7%B1%BB%E5%88%86%E6%9E%90">3.5.2 曲线类分析</a></li>
<li><a href="#353-%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90">3.5.3 混淆矩阵分析</a></li>
<li><a href="#354-%E6%A0%87%E7%AD%BE%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90">3.5.4 标签相关分析</a></li>
<li><a href="#355-%E8%AE%AD%E7%BB%83%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90">3.5.5 训练验证结果分析</a></li>
<li><a href="#356-%E5%85%B6%E4%BD%99%E5%88%86%E6%9E%90">3.5.6 其余分析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%82%86-%E6%A8%A1%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%A4%84%E7%90%86%E5%9F%BA%E4%BA%8Eonnx%E6%96%87%E4%BB%B6%E6%8E%A8%E7%90%86">肆 —— 模型转化处理（基于.onnx文件推理）</a><ul>
<li><a href="#41-%E8%BD%AC%E5%8C%96%E4%B8%BAonnx%E6%96%87%E4%BB%B6">4.1 转化为.onnx文件</a></li>
<li><a href="#42-%E9%80%9A%E8%BF%87c%E5%88%A9%E7%94%A8onnx%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%A8%E7%90%86%E8%AF%86%E5%88%AB">4.2 通过C++利用.onnx文件进行推理识别</a><ul>
<li><a href="#421-%E8%AE%B0%E5%BD%95%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">4.2.1 记录处理的数据结构</a></li>
<li><a href="#422-%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB%E5%87%BD%E6%95%B0">4.2.2 检测识别函数</a></li>
<li><a href="#423-%E9%A2%84%E6%B5%8B%E7%94%BB%E6%A1%86%E5%87%BD%E6%95%B0">4.2.3 预测画框函数</a></li>
<li><a href="#424-%E4%B8%BB%E5%87%BD%E6%95%B0">4.2.4 主函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BC%8D-%E6%A8%A1%E5%9E%8B%E8%BD%AC%E5%8C%96%E5%8A%A0%E9%80%9F%E5%A4%84%E7%90%86%E5%9F%BA%E4%BA%8Eengine%E6%96%87%E4%BB%B6%E6%8E%A8%E7%90%86">伍 —— 模型转化加速处理（基于.engine文件推理）</a><ul>
<li><a href="#51-%E8%BD%AC%E5%8C%96%E4%B8%BAengine%E6%96%87%E4%BB%B6">5.1 转化为.engine文件</a><ul>
<li><a href="#511-%E9%80%9A%E8%BF%87yolov5%E8%87%AA%E5%B8%A6%E7%9A%84exportpy%E8%BD%AC%E6%8D%A2">5.1.1 通过YOLOv5自带的export.py转换</a></li>
<li><a href="#512-%E9%80%9A%E8%BF%87%E8%87%AA%E5%B7%B1%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E7%9A%84tensorrt%E8%BD%AC%E6%8D%A2">5.1.2 通过自己下载安装的TensorRT转换</a></li>
</ul>
</li>
<li><a href="#52-%E9%80%9A%E8%BF%87c%E5%88%A9%E7%94%A8engine%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%8E%A8%E7%90%86%E8%AF%86%E5%88%AB">5.2 通过C++利用.engine文件进行推理识别</a><ul>
<li><a href="#521-%E8%AE%B0%E5%BD%95%E8%AF%86%E5%88%AB%E7%BB%93%E6%9E%9C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">5.2.1 记录识别结果的数据结构</a></li>
<li><a href="#522-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97">5.2.2 日志模块</a></li>
<li><a href="#523-%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E6%A8%A1%E5%9D%97">5.2.3 计算内存大小模块</a></li>
<li><a href="#524-%E6%A3%80%E6%B5%8B%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9D%97">5.2.4 检测识别模块</a></li>
<li><a href="#525-%E4%B8%BB%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1">5.2.5 主函数设计</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%99%86-%E6%89%93%E5%8C%85%E8%BD%AF%E4%BB%B6">陆 —— 打包软件</a><ul>
<li><a href="#61-%E5%9F%BA%E4%BA%8Eonnx%E6%96%87%E4%BB%B6%E5%9B%BE%E5%83%8F%E6%8E%A8%E7%90%86%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85">6.1 基于.onnx文件图像推理程序打包</a></li>
<li><a href="#62-%E5%9F%BA%E4%BA%8Eengine%E6%96%87%E4%BB%B6%E5%9B%BE%E5%83%8F%E6%8E%A8%E7%90%86%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85">6.2 基于.engine文件图像推理程序打包</a></li>
<li><a href="#63-%E6%95%B4%E4%BD%93%E6%89%93%E5%8C%85">6.3 整体打包</a></li>
</ul>
</li>
<li><a href="#%E6%9F%92-%E6%80%BB%E7%BB%93%E5%8F%8A%E5%90%8E%E8%AF%9D">柒 —— 总结及后话</a></li>
</ul>
<!-- tocstop -->

<h1><span id="零-前言">零 —— 前言</span></h1><p>此篇博客是我亲手做的一次项目记录（2023.7.3~2023.7.14），在GPU服务器完成基于YOLOv5的模型训练，在Windows 10下将训练得到的权重文件作基本处理转化为.onnx文件和.engine文件分别进行C++下的推理，最后并做了简单界面，效果如下图。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_chengguo.jpg" alt="成品展示"></p>
<p>本人学术不精，此篇博客可能会因为一些深度学习上的知识不熟悉而造成的表达错误，此博客只是记录此次项目过程，并尽力使其有参考性、使其可复刻。</p>
<p>项目代码放在<a href="https://gitee.com/fingsinz/ele-bicycle-detection/">码云Gitee仓库</a></p>
<p><br><br><br></p>
<h1><span id="壹-环境准备">壹 —— 环境准备</span></h1><p>本项目需要的环境：</p>
<ul>
<li><u>Python环境</u>：YOLOv5所需</li>
<li><u>CUDA环境</u>：调用显卡进行显存加速</li>
<li><u>OpenCV环境</u>：进行图像处理</li>
</ul>
<p>我的环境是CUDA12.0，OpenCV4.5.2，训练所用Python3.8.10，本机Windows 10所用Python3.11.4。</p>
<p>下载安装CUDA可参考<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/5/#more">这篇博客</a><br>配置OpenCV和CUDA环境可参考<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/9/#more">这篇博客</a>。</p>
<p><br><br><br></p>
<h1><span id="贰-数据准备">贰 —— 数据准备</span></h1><h2><span id="21-数据集结构">2.1 数据集结构</span></h2><p>本项目需要的数据集（不公开）：</p>
<ul>
<li><u>校园内电瓶车463张</u>：435张用于训练，28张用于验证</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_dataset.jpg" alt="数据集文件结构"></p>
<p>这个数量上和比例上并不良好，也没有设测试集，建议照片尽量多，并按8:1:1的比例分配在训练集、验证集和测试集。</p>
<ul>
<li>训练集：用于YOLOv5模型调试神经网络；相当于学生的课本，学生根据课本里的内容来掌握知识。</li>
<li>验证集：验证集用来查看训练效果；相当于作业，通过作业可以知道不同学生学习情况、进步的速度快慢。</li>
<li>测试集：用来测试网络的实际学习能力；相当于考试，考的题是平常都没有见过，考察学生举一反三的能力。</li>
</ul>
<p>数据集的文件结构应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dataset</span><br><span class="line">|---images</span><br><span class="line">|   |---train</span><br><span class="line">|   |---val</span><br><span class="line">|   |---test</span><br><span class="line">|---labels</span><br><span class="line">|   |---train</span><br><span class="line">|   |---val</span><br><span class="line">|   |---test</span><br></pre></td></tr></table></figure>


<h2><span id="22-处理数据集">2.2 处理数据集</span></h2><p>使用<a href="https://zhuanlan.zhihu.com/p/550021453">LabelImg</a>进行对图片标记。或自行搜索使用安装教程。</p>
<p>打标签时，选择YOLO格式，生成的是.txt文件，用于模型训练。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_labeling.jpg" alt="使用LabelImg工具对数据集进行打标签"></p>
<p>打完标签后，在labels文件夹下的train文件夹、val文件夹和test文件夹会生成一个对应images各文件夹的.txt文件，还会生成一个classes.txt文件。故labels文件夹下的各个文件夹会多一个文件。</p>
<p>最后命名此数据集为<code>eleb</code>。</p>
<p><br><br><br></p>
<h1><span id="叁-模型训练及分析">叁 —— 模型训练及分析</span></h1><h2><span id="31-部署yolov5">3.1 部署YOLOv5</span></h2><p>训练模型需要在专业的GPU加速服务器上运行， <strong>请勿尝试在自己的电脑上跑模型</strong>。</p>
<p>挑选GPU服务器可参考<a href="https://fingsinz.space/%E5%85%B6%E4%BB%96%E5%88%86%E4%BA%AB/gpuserver/#more">这篇博客</a>。</p>
<h3><span id="311-使用社区镜像自动部署yolov5">3.1.1 使用社区镜像自动部署YOLOv5</span></h3><p>我使用的是AutoDL算力云，其社区镜像默认安装了YOLOv5。在算力市场中寻找合适的地区，GPU型号尽量好，按量计费租用。我此次租用的是：<u>芜湖区-RTX3090</u>，1.58r&#x2F;h，跑四百多张图片估计是四个小时左右。</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_ser.jpg" alt="租用GPU服务器"></p>
<p>租用实例后开机，我选择JupyterLab的方式连接服务器。为了方便，我把默认的<code>yolov5</code>文件夹转到（剪贴粘贴）数据盘。有文件如下：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_yolov5.jpg" alt="yolov5文件夹"></p>
<h3><span id="312-手动部署yolov5">3.1.2 手动部署YOLOv5</span></h3><p>建议租用Ubuntu系统，在有Python、Git等环境下，服务器新建文件夹，使用git命令克隆<a href="https://github.com/ultralytics/yolov5">YOLOv5仓库</a>或者网页下载压缩包解压部署。如果有缺少的库可以<code>pip install</code>安装。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/yolov5.git</span><br></pre></td></tr></table></figure>

<p>至此YOLOv5部署完毕。</p>
<h2><span id="32-上传数据">3.2 上传数据</span></h2><p>将我们准备好的数据集压缩成.zip压缩文件，上传到<code>yolov5/data/eleb</code>（数据集根目录，新建文件夹eleb），由于文件比较大，上传速度也比较慢，比较费时间，也可以在服务器上创建文件夹后多选文件上传。</p>
<p>在终端上进入<code>yolov5/data</code>运行下面的指令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">unzip xx.zip</span><br></pre></td></tr></table></figure>

<p>如果提示有包没下载就去下载。</p>
<p>解压后，复制data文件夹下的<code>coco.yaml</code>，并命名为数据集的名字。在上面我将数据集名字命名为<code>eleb</code>，故复制并命名为<code>eleb.yaml</code>。</p>
<p>将eleb.yaml编辑如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练集、验证集、测试集路径设置</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">./data/eleb</span>    <span class="comment"># 数据集根目录</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">images/train</span>  <span class="comment"># 训练集目录</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">images/val</span>      <span class="comment"># 验证集目录</span></span><br><span class="line"><span class="attr">test:</span>                <span class="comment"># 测试集目录，此处没设立</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签的类，此项目只有一个类</span></span><br><span class="line"><span class="attr">names:</span></span><br><span class="line">  <span class="attr">0:</span> <span class="string">elebike</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Download script/URL (optional) 不管，默认</span></span><br><span class="line"><span class="attr">download:</span> <span class="comment">#https://ultralytics.com/assets/coco128-seg.zip</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="33-配置训练参数">3.3 配置训练参数</span></h2><h3><span id="331-修改trainpy文件">3.3.1 修改train.py文件</span></h3><p><strong>回到<code>yolov5/</code>目录，找到<code>train.py</code>文件打开，找到<code>parse_opt()</code>函数，更改部分参数：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># model.yaml是模型配置文件，在文件夹yolov5/models中，此处我使用yolov5l.yaml</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--cfg&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;yolov5l.yaml path&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置数据集的yaml文件，即eleb.yaml</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--data&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=ROOT / <span class="string">&#x27;data/eleb.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;dataset.yaml path&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置训练轮数，默认300轮</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">300</span>, <span class="built_in">help</span>=<span class="string">&#x27;total training epochs&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置训练时所有GPU的总批量大小，为-1则自动</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--batch-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">16</span>, <span class="built_in">help</span>=<span class="string">&#x27;所有GPU的总批量大小, -1 for autobatch&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 配置训练输入的照片大小，默认为640 × 640</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--imgsz&#x27;</span>, <span class="string">&#x27;--img&#x27;</span>, <span class="string">&#x27;--img-size&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">640</span>, <span class="built_in">help</span>=<span class="string">&#x27;train, val image size (pixels)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面保持默认即可</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># ……</span></span><br></pre></td></tr></table></figure>

<h3><span id="332-修改valpy文件">3.3.2 修改val.py文件</span></h3><p><strong>回到<code>yolov5/</code>目录，找到<code>val.py</code>文件打开，找到<code>parse_opt()</code>函数，更改部分参数：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ……</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置数据集的yaml文件，即eleb.yaml</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--data&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=ROOT / <span class="string">&#x27;data/eleb.yaml&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;dataset.yaml path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ……</span></span><br></pre></td></tr></table></figure>
<h3><span id="333-修改模型配置">3.3.3 修改模型配置</span></h3><p> <strong>（3）进入<code>yolov5/models/</code>目录，找到<code>train.py</code>设置的模型配置.yaml文件，我这里使用的是yolov5l模型，打开yolov5l.yaml，修改<code>nc</code>（分类数），此项目修改为1：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ……</span></span><br><span class="line"><span class="attr">nc:</span> <span class="number">1</span>  <span class="comment"># number of classes</span></span><br><span class="line"><span class="attr">depth_multiple:</span> <span class="number">1.0</span>  <span class="comment"># model depth multiple</span></span><br><span class="line"><span class="attr">width_multiple:</span> <span class="number">1.0</span>  <span class="comment"># layer channel multiple</span></span><br><span class="line"><span class="attr">anchors:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">10</span>,<span class="number">13</span>, <span class="number">16</span>,<span class="number">30</span>, <span class="number">33</span>,<span class="number">23</span>]  <span class="comment"># P3/8</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">30</span>,<span class="number">61</span>, <span class="number">62</span>,<span class="number">45</span>, <span class="number">59</span>,<span class="number">119</span>]  <span class="comment"># P4/16</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">116</span>,<span class="number">90</span>, <span class="number">156</span>,<span class="number">198</span>, <span class="number">373</span>,<span class="number">326</span>]  <span class="comment"># P5/32</span></span><br><span class="line"><span class="comment"># ……</span></span><br></pre></td></tr></table></figure>

<p>至此训练参数配置完毕。</p>
<p>启动终端，进入yolov5文件夹，我这里是进入<code>autodl-tmp/yolov5/</code>，输入命令启动训练：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python train.py</span><br></pre></td></tr></table></figure>

<p>如下图即开始训练</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_train2.jpg" alt="训练开始"></p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_train.jpg" alt="训练结束"></p>
<h2><span id="34-训练可能出现的问题">3.4 训练可能出现的问题</span></h2><p> 如果出现训练过程长时间的<code>R</code>和<code>P</code>值为<code>0</code>或者<code>val/box_loss</code>和<code>val/obj_loss</code>为<code>nan</code>的情况，参考<a href="https://blog.csdn.net/weixin_55249340/article/details/125855686">此篇博客</a>。</p>
<p>如果仍不能解决，可以考虑重新手动部署YOLOv5，接着修改参数运行train.py启动训练，如果缺少库就pip install安装。</p>
<h2><span id="35-训练结果分析">3.5 训练结果分析</span></h2><p>等待训练结束，在 <code>yolov5/runs/train</code> 文件夹就存放在训练的数据，其中weights文件夹中还存放着此次训练的权重文件，用于后续推理。</p>
<h3><span id="351-保存训练结果">3.5.1 保存训练结果</span></h3><p>在训练结果文件夹（我的是<code>runs/train/exp2</code>）中新建.py文件，输入下面代码，接着使用终端进入<code>runs/train/exp2</code>，使用命令<code>python save.py</code>可以变成压缩包，下载压缩包即下载全部训练结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># save.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recursive_files</span>(<span class="params">dir_name=<span class="string">&#x27;.&#x27;</span>, ignore=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">for</span> dir_name,subdirs,files <span class="keyword">in</span> os.walk(dir_name):</span><br><span class="line">        <span class="keyword">if</span> ignore <span class="keyword">and</span> os.path.basename(dir_name) <span class="keyword">in</span> ignore: </span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> ignore <span class="keyword">and</span> file_name <span class="keyword">in</span> ignore:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> os.path.join(dir_name, file_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_tar_file</span>(<span class="params">dir_name=<span class="string">&#x27;.&#x27;</span>, tar_file_name=<span class="string">&#x27;tarfile.tar&#x27;</span>, ignore=<span class="literal">None</span></span>):</span><br><span class="line">    tar = tarfile.<span class="built_in">open</span>(tar_file_name, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> recursive_files(dir_name, ignore):</span><br><span class="line">        tar.add(file_name)</span><br><span class="line"></span><br><span class="line">    tar.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dir_name = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">tar_file_name = <span class="string">&#x27;train.tar&#x27;</span></span><br><span class="line">ignore = &#123;<span class="string">&#x27;.ipynb_checkpoints&#x27;</span>, <span class="string">&#x27;__pycache__&#x27;</span>, tar_file_name&#125;</span><br><span class="line">make_tar_file(dir_name, tar_file_name, ignore)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将训练结果下载到电脑上，解压有如下文件：</p>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_results.jpg"></p>
<h3><span id="352-曲线类分析">3.5.2 曲线类分析</span></h3><ul>
<li>P_curve：准确率Precision和置信度Confidence的关系图，当设置某置信度时对应某个类别的识别准确率。随着置信度设置越高，某个类别识别准确率越高。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_P_curve.png" alt="P曲线"></p>
<ul>
<li>R_curve：召回率Recall和置信度Confidence的关系图，当设置某置信度时对应某个类别的查找完全的概率。随着置信度设置越高，某个类别能被查找完全的概率越低。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_R_curve.png" alt="R曲线"></p>
<ul>
<li>PR_cruve：准确率Precision和召回率Recall的关系图，尽可能希望准确率高的同时召回率也高，即曲线与坐标轴围成的面积越大，模型越好。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_PR_curve.png" alt="PR曲线"></p>
<ul>
<li>F1_curve：精确率和召回率的调和平均数，某个分类对应F1的值，1为最好，0为最差。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_F1_curve.png" alt="F1曲线"></p>
<h3><span id="353-混淆矩阵分析">3.5.3 混淆矩阵分析</span></h3><ul>
<li>confusion_matrix：矩阵的每一列代表一个类的实例预测，而每一行表示一个实际的类的实例，可以方便地看出机器是否将两个不同的类混淆。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_confusion_matrix.png" alt="混淆矩阵"></p>
<h3><span id="354-标签相关分析">3.5.4 标签相关分析</span></h3><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_labels.jpg" alt="标签相关labels.jpg"></p>
<ul>
<li>左上角为训练集的数据量；</li>
<li>右上角是框的尺寸和数量；</li>
<li>左下角是打标签目标框中心点位置，由图可知中心点多为中心偏上。</li>
<li>右下角是打标签目标框的高和宽，由图可知多聚集在0.2×0.2</li>
</ul>
<h3><span id="355-训练验证结果分析">3.5.5 训练验证结果分析</span></h3><p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_results.png" alt="results.png"></p>
<p>前面加<code>train</code>为训练集的情况，加<code>val</code>表示验证集的情况。</p>
<ul>
<li><p>定位损失box_loss：预测框与标定框之间的误差。</p>
</li>
<li><p>置信度损失obj_loss：计算网络的置信度。</p>
</li>
<li><p>分类损失cls_loss：计算锚框与对应标定分类是否正确。</p>
</li>
<li><p>precision：模型精度。</p>
</li>
<li><p>recall：真实为positive的准确率，即正样本有多少被找出来了。</p>
</li>
<li><p>mAP：Mean Average Precision，均值平均精度，mAP_0.5表示阈值大于0.5的平均mAP。</p>
</li>
<li><p>mAP_0.5:0.95：表示不同<a href="https://blog.csdn.net/gaoyu1253401563/article/details/86484851">IoU</a>阈值（从0.5到0.95，步长0.05）上的平均mAP。</p>
</li>
</ul>
<h3><span id="356-其余分析">3.5.6 其余分析</span></h3><ul>
<li><p><code>train_batch</code>、 <code>val_batch</code>表示一批次读取的照片数。</p>
</li>
<li><p><code>results.csv</code>存放着每轮训练的数据。</p>
</li>
</ul>
<p><br><br><br></p>
<h1><span id="肆-模型转化处理基于onnx文件推理">肆 —— 模型转化处理（基于.onnx文件推理）</span></h1><h2><span id="41-转化为onnx文件">4.1 转化为.onnx文件</span></h2><p>将我们的.pt文件经过服务器上YOLOv5自带的<code>export.py</code>处理后即可得到.onnx文件。即下面的命令格式：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python export.py --weights yolov5s.pt --include onnx</span><br></pre></td></tr></table></figure>

<p>我输入的是（位于yolov5文件夹）：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python export.py --weights runs/train/exp2/weights/best.pt --include onnx</span><br></pre></td></tr></table></figure>

<h2><span id="42-通过c利用onnx文件进行推理识别">4.2 通过C++利用.onnx文件进行推理识别</span></h2><h3><span id="421-记录处理的数据结构">4.2.1 记录处理的数据结构</span></h3><p>将置信度阈值<code>confThreshold</code>、NMS非极大值抑制阈值<code>nmsThreshold</code>、目标置信度阈值<code>objThreshold</code>和识别模型路径<code>modelpath</code>打包成结构体，用于识别时参数的配置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义配置结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Configuration</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">float</span> confThreshold; <span class="comment">// Confidence threshold</span></span><br><span class="line">	<span class="type">float</span> nmsThreshold;  <span class="comment">// Non-maximum suppression threshold</span></span><br><span class="line">	<span class="type">float</span> objThreshold;  <span class="comment">// Object Confidence threshold</span></span><br><span class="line">	string modelpath;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建<code>YOLOv5</code>类，其成员变量有置信度阈值<code>confThreshold</code>、NMS非极大值抑制阈值<code>nmsThreshold</code>、目标置信度阈值<code>objThreshold</code>，以及输入图片宽度<code>inpWidth</code>、输入图片高度<code>inpHeight</code>两个照片参数，识别种类数<code>num_classes</code>，类名<code>classes</code>；</p>
<p>主要函数为检测函数<code>detect</code>，辅助函数为预测画框函数<code>drawPred</code>和调整图片大小函数<code>resize_image</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOLOv5</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="built_in">YOLOv5</span>(Configuration config, <span class="type">bool</span> isCuda);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">detect</span><span class="params">(Mat &amp;frame)</span></span>;  <span class="comment">// 检测函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> confThreshold;</span><br><span class="line">	<span class="type">float</span> nmsThreshold;</span><br><span class="line">	<span class="type">float</span> objThreshold;</span><br><span class="line">	<span class="type">int</span> inpWidth;</span><br><span class="line">	<span class="type">int</span> inpHeight;</span><br><span class="line">	<span class="type">int</span> num_classes;</span><br><span class="line">	string classes[<span class="number">1</span>] = &#123; <span class="string">&quot;eleb&quot;</span> &#125;;</span><br><span class="line">	<span class="comment">//vector&lt;string&gt; class_names;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> keep_ratio = <span class="literal">true</span>;</span><br><span class="line">	Net net;   <span class="comment">// dnn里的</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">drawPred</span><span class="params">(<span class="type">float</span> conf, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, Mat &amp;frame, <span class="type">int</span> classid)</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">resize_image</span><span class="params">(Mat srcimg, <span class="type">int</span> *newh, <span class="type">int</span> *neww, <span class="type">int</span> *top, <span class="type">int</span> *left)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3><span id="422-检测识别函数">4.2.2 检测识别函数</span></h3><ol>
<li>进行预处理：对输入图像（帧）进行大小调整和归一化处理，以便为模型做准备。调整后的图像会被转换为Blob，一个具有NCHW 维度（图像数、通道数、高度、宽度）的 4D 矩阵。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat dstimg = <span class="keyword">this</span>-&gt;<span class="built_in">resize_image</span>(frame, &amp;newh, &amp;neww, &amp;padh, &amp;padw);</span><br><span class="line">Mat blob = <span class="built_in">blobFromImage</span>(dstimg, <span class="number">1</span> / <span class="number">255.0</span>, <span class="built_in">Size</span>(<span class="keyword">this</span>-&gt;inpWidth, <span class="keyword">this</span>-&gt;inpHeight), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;net.<span class="built_in">setInput</span>(blob);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>模型推理：在Blob上运行模型以获得输出，即边界框和类别概率列表。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;Mat&gt; outs;</span><br><span class="line"><span class="keyword">this</span>-&gt;net.forward(outs, <span class="keyword">this</span>-&gt;net.<span class="built_in">getUnconnectedOutLayersNames</span>());</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进行后处理：如果输出超过2维，则会对其进行重塑。对于每个边界框，它会检查对象的置信度是否高于阈值。计算最大类得分，同时检查其是否高于置信度阈值。如果超过了，就会保存边界框、置信度和类ID。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_proposal; ++i) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (obj_conf &gt; <span class="keyword">this</span>-&gt;objThreshold)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (max_class_socre &gt; <span class="keyword">this</span>-&gt;confThreshold)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            confidences.<span class="built_in">push_back</span>((<span class="type">float</span>) max_class_socre);</span><br><span class="line">            boxes.<span class="built_in">push_back</span>(<span class="built_in">Rect</span>(left, top, (<span class="type">int</span>) (w * ratiow), (<span class="type">int</span>) (h * ratioh)));</span><br><span class="line">            classIds.<span class="built_in">push_back</span>(class_idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>非最大值抑制 (NMS)：NMS用于移除重叠的边界框。剩余的边界框在原始图像上绘制。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; indices;</span><br><span class="line">dnn::<span class="built_in">NMSBoxes</span>(boxes, confidences, <span class="keyword">this</span>-&gt;confThreshold, <span class="keyword">this</span>-&gt;nmsThreshold, indices);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; indices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">drawPred</span>(confidences[idx], box.x, box.y, box.x + box.width, box.y + box.height, frame, classIds[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="423-预测画框函数">4.2.3 预测画框函数</span></h3><p>预测画框函数用于将预测函数所得到的目标区域，经OpenCV的工具在图片上绘制出方框。首先传入的参数有置信度，图片的四个角落点，Mat类型图片和类id，接着借助OpenCV的<code>rectangle</code>函数和<code>putText</code>函数绘制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绘制预测目标的边界框</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">YOLOv5::drawPred</span><span class="params">(<span class="type">float</span> conf, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom, Mat &amp;frame, <span class="type">int</span> classid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 绘制一个显示边界框的矩形</span></span><br><span class="line">	<span class="built_in">rectangle</span>(frame, <span class="built_in">Point</span>(left, top), <span class="built_in">Point</span>(right, bottom), <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 得到目标的类名和置信度</span></span><br><span class="line">	string label = cv::format(<span class="string">&quot;%.2f&quot;</span>, conf);</span><br><span class="line">	label = <span class="keyword">this</span>-&gt;classes[classid] + <span class="string">&quot;:&quot;</span> + label;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绘制目标的类名和置信度文本</span></span><br><span class="line">	<span class="type">int</span> baseLine;</span><br><span class="line">	Size labelSize = <span class="built_in">getTextSize</span>(label, FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span>, <span class="number">1</span>, &amp;baseLine);</span><br><span class="line">	top = <span class="built_in">max</span>(top, labelSize.height);</span><br><span class="line">	<span class="built_in">putText</span>(frame, label, <span class="built_in">Point</span>(left, top), FONT_HERSHEY_SIMPLEX, <span class="number">0.75</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="424-主函数">4.2.4 主函数</span></h3><p>本程序通过<code>main</code>函数的参数进行传参。如C&#x2F;C++语言语法， <code>argc</code> 是argument count的缩写，表示传入main函数中的参数个数，包括这个程序本身； <code>argv</code> 是 argument vector的缩写，表示传入 <code>main</code> 函数中的参数列表，其中 <code>argv[0]</code> 表示这个程序的名字。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//yolov5-onnx.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Run like this:\n    &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; yolov5s.onnx input.jpg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Configuration yolo_nets = &#123; <span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.3</span>, argv[<span class="number">1</span>] &#125;; <span class="comment">// 初始化数据</span></span><br><span class="line">	<span class="function">YOLOv5 <span class="title">yolo_model</span><span class="params">(yolo_nets, <span class="literal">false</span>)</span></span>;</span><br><span class="line">	Mat srcimg = <span class="built_in">imread</span>(argv[<span class="number">2</span>]);  <span class="comment">// 读入图片</span></span><br><span class="line">	yolo_model.<span class="built_in">detect</span>(srcimg);     <span class="comment">// 进行推理</span></span><br><span class="line">	<span class="built_in">imwrite</span>(<span class="string">&quot;result.jpg&quot;</span>, srcimg); <span class="comment">// 输出图片</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以当调用该程序时，只需在命令提示符的当前目录下，输入指令格式：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">yolov5-onnx.exe best.onnx input.jpg</span><br></pre></td></tr></table></figure>

<p><br><br><br></p>
<h1><span id="伍-模型转化加速处理基于engine文件推理">伍 —— 模型转化加速处理（基于.engine文件推理）</span></h1><h2><span id="51-转化为engine文件">5.1 转化为.engine文件</span></h2><h3><span id="511-通过yolov5自带的exportpy转换">5.1.1 通过YOLOv5自带的export.py转换</span></h3><p>将我们的.pt文件经过服务器上YOLOv5自带的<code>export.py</code>处理后即可得到.engine文件（可能会自动下载TensorRT）。即下面的命令格式：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python export.py --weights yolov5s.pt --include engine</span><br></pre></td></tr></table></figure>

<p>我输入的是（位于yolov5文件夹）：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">python export.py --weights runs/train/exp2/weights/best.pt --include engine</span><br></pre></td></tr></table></figure>

<h3><span id="512-通过自己下载安装的tensorrt转换">5.1.2 通过自己下载安装的TensorRT转换</span></h3><p>在<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/5/#more">安装TensorRT</a>后，在TensorRT文件夹下有一个名为 <code>bin</code> 的文件夹，里面存在一个<code>trtexec.exe</code>文件。可以通过这个文件进行文件转换。在 <code>bin</code> 目录启动命令提示符，命令格式如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">trtexec --onnx=best.onnx --saveEngine=best.engine</span><br></pre></td></tr></table></figure>

<h2><span id="52-通过c利用engine文件进行推理识别">5.2 通过C++利用.engine文件进行推理识别</span></h2><h3><span id="521-记录识别结果的数据结构">5.2.1 记录识别结果的数据结构</span></h3><p>一个记录识别结果的结构体，包括检测物体置信度 <code>score</code>，目标预测框 <code>box</code> 和类ID <code>class_id</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	cv::Rect box;</span><br><span class="line">	<span class="type">int</span> class_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="522-日志模块">5.2.2 日志模块</span></h3><p>在构建TensorRT Runtime时需要作为参数传入。日志模块必须继承自<code>nvinfer1::ILogger</code>类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TensorRT需要日志</span></span><br><span class="line"><span class="comment">// 参考: https://github.com/cyrusbehr/tensorrt-cpp-api</span></span><br><span class="line"><span class="keyword">using</span> Severity = nvinfer1::ILogger::Severity;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> : <span class="keyword">public</span> nvinfer1::ILogger</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(Severity severity, <span class="type">const</span> <span class="type">char</span> *msg)</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(Severity severity, <span class="type">const</span> <span class="type">char</span> *msg)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (severity &lt;= Severity::kWARNING)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger logger;</span><br></pre></td></tr></table></figure>

<h3><span id="523-计算内存大小模块">5.2.3 计算内存大小模块</span></h3><p>一个计算内存大小的辅助函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">get_memory_size</span><span class="params">(<span class="type">const</span> nvinfer1::Dims &amp;dims, <span class="type">const</span> <span class="type">int32_t</span> elem_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">accumulate</span>(dims.d, dims.d + dims.nbDims, <span class="number">1</span>, std::<span class="built_in">multiplies</span>&lt;<span class="type">int64_t</span>&gt;()) * <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(elem_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="524-检测识别模块">5.2.4 检测识别模块</span></h3><p>基于.engine文件的推理识别涉及到显卡的调用，故需用到CUDA的Context。</p>
<p>CUDA的Context是由CUDA驱动程序创建的数据结构，包含执行CUDA操作所需的所有信息，如设备代码、数据以及线程、内存和硬件设置等资源。每个线程都有一个当前Context，该线程上的所有CUDA操作都在该Context中执行。</p>
<ol>
<li>初始化YOLOv5模型</li>
</ol>
<ul>
<li>首先从<code>engine_file_path</code>指定的文件中加载TensorRT引擎。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取TensorRT引擎</span></span><br><span class="line"><span class="function">std::ifstream <span class="title">engine_file</span><span class="params">(engine_file_path, std::ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (engine_file.<span class="built_in">fail</span>())</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Failed to read model file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">engine_file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ifstream::end);</span><br><span class="line"><span class="keyword">auto</span> fsize = engine_file.<span class="built_in">tellg</span>();</span><br><span class="line">engine_file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ifstream::beg);</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">engineData</span><span class="params">(fsize)</span></span>;</span><br><span class="line">engine_file.<span class="built_in">read</span>(engineData.<span class="built_in">data</span>(), fsize);</span><br></pre></td></tr></table></figure>

<ul>
<li>其次，推演运行时 <code>nvinfer1::IRuntime</code> 是一切资源的源头，是第一个需要被初始化的对象，注意运行时的初始化需要将辅助模块中定义好的 <code>logger</code> 作为传入参数。同时这段代码使用 <code>unique_ptr</code> 来跟踪初始化后的运行时对象。引擎 <code>nvinfer1::ICudaEngine</code> 存储了模型的权重参数，它的初始化分2步：首先将模型文件读入内存，然后使用运行时的 <code>deserializeCudaEngine</code> 方法初始化引擎对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化IRuntime和ICudaEngine</span></span><br><span class="line">std::unique_ptr&lt;nvinfer1::IRuntime&gt; runtime&#123; nvinfer1::<span class="built_in">createInferRuntime</span>(logger) &#125;;</span><br><span class="line">std::unique_ptr&lt;nvinfer1::ICudaEngine&gt; mEngine&#123; runtime-&gt;<span class="built_in">deserializeCudaEngine</span>(engineData.<span class="built_in">data</span>(), fsize) &#125;;</span><br><span class="line"><span class="keyword">if</span> (mEngine.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Failed to deserialize CUDA engine.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后创建CUDA的context，并为输入和输出绑定分配CUDA内存。引擎的本质是专为TensorRT优化后的模型。可使用<code>createExecutionContext</code> 方法来构建推演环境 <code>nvinfer1::IExecutionContext</code> 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;nvinfer1::IExecutionContext&gt; context&#123; mEngine-&gt;<span class="built_in">createExecutionContext</span>() &#125;;</span><br><span class="line"><span class="keyword">if</span> (context.<span class="built_in">get</span>() == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Failed to create CUDA context.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>准备模型输入</li>
</ol>
<ul>
<li>了解模型结构，通过<a href="https://netron.app/">netron.app</a>输入.onnx文件查看自己的神经网络结构。我这里输入名字为 <code>images</code> ，尺寸为3×640×640；输出名字为 <code>output0</code> ，尺寸为1×25200×6。</li>
</ul>
<p><img src="https://fblog-img.oss-cn-hangzhou.aliyuncs.com/blog/yolov5_model.jpg" alt="模型结构"></p>
<ul>
<li>TensorRT的模型推演在GPU上进行，需要在显存上为用于计算的数据申请空间。输入尺寸为3×640×640，使用内存大小计算函数得到显存中应当开辟的空间大小，然后使用 <code>cudaMalloc</code> 申请显存。其中 <code>cuda_mem_input</code> 为指向该显存区域的指针。为了方便后续推演，这里使用一个指针数组 <code>bindings</code> 记录下与推演有关的内存区域。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录与推演相关的内存区域</span></span><br><span class="line"><span class="type">void</span> *bindings[<span class="number">5</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *input_name = <span class="string">&quot;images&quot;</span>;</span><br><span class="line"><span class="type">int32_t</span> input_idx = mEngine-&gt;<span class="built_in">getBindingIndex</span>(input_name);</span><br><span class="line"><span class="keyword">if</span> (input_idx == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ERROR: failed to get input by name: &quot;</span> &lt;&lt; input_name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算显存大小并开辟</span></span><br><span class="line"><span class="type">int32_t</span> channels = <span class="number">3</span>, height = <span class="number">640</span>, width = <span class="number">640</span>;</span><br><span class="line">nvinfer1::Dims4 input_dims &#123; <span class="number">1</span>, channels, height, width &#125;;</span><br><span class="line"><span class="type">size_t</span> input_mem_size = <span class="built_in">get_memory_size</span>(input_dims, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"><span class="type">void</span>* cuda_mem_input &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cudaMalloc</span>(&amp;cuda_mem_input, input_mem_size) != cudaSuccess) </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR: input cuda memory allocation failed, size = &quot;</span> &lt;&lt; input_mem_size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bindings[<span class="number">0</span>] = cuda_mem_input;</span><br></pre></td></tr></table></figure>

<ul>
<li>同时还需为输出区域计算并开辟内存。模型的输出包含一个或多个对象，必须为每个输出对象分配独立的显存区域。在循环体中，首先通过 <code>getBindingDimensions</code> 获得输出每个对象的维度，然后计算其占据的显存区域大小，并调用 <code>cudaMalloc</code> 函数分配显存，最后将指向该存储区域的指针存入之前创建好的 <code>bindings</code> 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; output_node_names&#123; <span class="string">&quot;output0&quot;</span> &#125;;</span><br><span class="line">std::vector&lt;<span class="type">size_t</span>&gt; output_mem_sizes;</span><br><span class="line"><span class="type">bool</span> output_mem_initialized = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_node_names.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> output_idx = mEngine-&gt;<span class="built_in">getBindingIndex</span>(output_node_names[i].<span class="built_in">c_str</span>());</span><br><span class="line">	<span class="keyword">if</span> (output_idx == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ERROR: failed to get output by name: &quot;</span> &lt;&lt; output_node_names[i] &lt;&lt; std::endl;</span><br><span class="line">		output_mem_initialized = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> output_dims = context-&gt;<span class="built_in">getBindingDimensions</span>(output_idx);</span><br><span class="line">	<span class="keyword">auto</span> output_size = <span class="built_in">get_memory_size</span>(output_dims, <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">	output_mem_sizes.<span class="built_in">push_back</span>(output_size);</span><br><span class="line">	<span class="type">void</span> *cuda_mem_output&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">cudaMalloc</span>(&amp;cuda_mem_output, output_size) != cudaSuccess)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ERROR: output cuda memory allocation failed, size = &quot;</span> &lt;&lt; output_size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		output_mem_initialized = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		bindings[<span class="number">1</span> + i] = cuda_mem_output;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>显存空间初始化完成后，还需要初始化最后一个对象 <code>cudaStream</code> 。它用来在异步操作中同步结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cudaStream_t stream&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cudaStreamCreate</span>(&amp;stream) != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ERROR: cuda stream creation failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从<code>image_file_path</code>中读取图像，将其调整为所需尺寸，并复制到GPU内存中。输入图像在进入神经网络之前，首先会进行预处理操作。典型的预处理操作包括：缩放到指定尺寸、减去均值、归一化、除方差。另外如果模型对输入通道的顺序有要求，预处理也会调整通道顺序。YOLOv5的输入大小为640x640像素，通道顺序为RGB， 预处理也非常简单，像素值除以255即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cv::Mat img_bgr = cv::<span class="built_in">imread</span>(image_file_path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理</span></span><br><span class="line">cv::<span class="built_in">resize</span>(img_bgr, img_bgr, cv::<span class="built_in">Size</span>(width, height));</span><br><span class="line"><span class="type">int32_t</span> tmp = height * width * channels;</span><br><span class="line"><span class="type">float</span> *input_buffer = <span class="keyword">new</span> <span class="type">float</span>[tmp]();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; channels; c++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>, HW = height * width; j &lt; HW; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		input_buffer[c * HW + j] = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(img_bgr.data[j * channels + <span class="number">2</span> - c]) / <span class="number">255.0f</span>;</span><br><span class="line">		<span class="comment">// 其中 img_bgr.data 为指向像素存储区域的指针，而括号内下表运算中的 +2 实现了BGR数据到RGB的转换。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数据预处理的操作是在HOST（CPU）侧完成，在推演之前还需要将预处理后的数据拷贝到GPU一侧。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">cudaMemcpyAsync</span>(cuda_mem_input, input_buffer, input_mem_size, cudaMemcpyHostToDevice, stream) != cudaSuccess)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ERROR: CUDA memory copy of input failed, size = &quot;</span> &lt;&lt; input_mem_size &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行推理</li>
</ol>
<ul>
<li>使用执行Context的 <code>enqueueV2</code> 方法异步运行模型。 <code>enqueueV2</code> 是真正触发模型推演的操作。参数中的 <code>bindings</code> 是之前记录的指向输入与输出显存的指针数组。 <code>stream</code> 是在初始化资源章节创建的 <code>cudaStream</code> 对象，用于同步数据。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> status = context-&gt;<span class="built_in">enqueueV2</span>(bindings, stream, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (!status)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;ERROR: TensorRT inference failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>模型输出后处理</li>
</ol>
<ul>
<li>首先按照输出数据的规格申请输出内存空间。为输出结果 <code>output0</code> 申请了一份内存空间，并将指向这些内存区域的指针存储在 <code>output_buffers</code> 指针数组中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">float</span> *&gt; output_buffers;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_mem_sizes.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> *buf = <span class="keyword">new</span> <span class="type">float</span>[output_mem_sizes[i] / <span class="built_in">sizeof</span>(<span class="type">float</span>)];</span><br><span class="line">	output_buffers.<span class="built_in">push_back</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接着将输出从GPU内存复制到CPU内存。使用 <code>cudaMemcpyAsync</code> 函数。其中参数 <code>output_buffers</code> 为刚才申请好的内存空间， <code>bindings</code> 为GPU一侧的显存空间， <code>output_mem_sizes</code> 为输出结果所占据的内存大小， <code>cudaMemcpyDeviceToHost</code> 指定了拷贝操作的方向，由于这是一个异步操作，所以要使用 <code>stream</code> 作为同步数据的依据。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; output_mem_sizes.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> mem_to_host_result = <span class="built_in">cudaMemcpyAsync</span>(output_buffers[i], bindings[<span class="number">1</span> + i], output_mem_sizes[i], cudaMemcpyDeviceToHost, stream);</span><br><span class="line">	<span class="keyword">if</span> (mem_to_host_result != cudaSuccess)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;ERROR: CUDA memory copy of output &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; failed, size = &quot;</span> &lt;&lt; output_mem_sizes[i] &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>等待同步，已经调用了3个异步操作函数，因此这里需要使用同步操作来等待执行真正完成。同步之后，模型推演的结果才真正存储在了内存 <code>output_buffers</code> 中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cudaStreamSynchronize</span>(stream);</span><br></pre></td></tr></table></figure>

<ul>
<li>对输出进行后处理。首先定义三个向量分别存储检测获得的物体边界框 <code>boxes</code> 、分值 <code>scores</code> 与类别ID <code>class_ids</code> 。此次训练的YOLOv5模型有1个输出，即 <code>output0</code> 。 其本身是一个巨大的矩阵，其行数为25200，代表模型给出的物体检测结果。为此，可以定义一个指针 <code>p</code> 指向 <code>output0</code> ，然后通过一个循环来轮询结果。 此次训练中， <code>output0</code> 每行具有6个元素：第0~3个元素为物体边界框中心x，物体边界框中心y，物体边界框宽度和物体边界框高度；第4个元素为预测框分值；第5个元素是物体类别ID的概率，可以按照最大值获取到分类结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">float</span>&gt; scores;</span><br><span class="line">std::vector&lt;cv::Rect&gt; boxes;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; class_ids;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> *p = output_buffers[<span class="number">0</span>]; <span class="comment">// 指向output0的第一个元素</span></span><br><span class="line"><span class="type">int</span> step = <span class="number">6</span>, proposal_count = <span class="number">25200</span>;</span><br><span class="line"><span class="type">float</span> score_threshold = <span class="number">0.5</span>, nms_threshold = <span class="number">0.45</span>; <span class="comment">// 分支阈值和NMS阈值</span></span><br><span class="line"><span class="type">float</span> scale = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; proposal_count; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 置信度低于分数阈值</span></span><br><span class="line">	<span class="type">float</span> obj_score = p[<span class="number">4</span>]; <span class="comment">// 第4个元素是预测框分值</span></span><br><span class="line">	<span class="keyword">if</span> (obj_score &lt; score_threshold)</span><br><span class="line">	&#123;</span><br><span class="line">		p += step;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断对象分类</span></span><br><span class="line">	<span class="type">int</span> c_id = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">float</span> c_score = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">1</span>; j &lt; step; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p[j] &gt; c_score)</span><br><span class="line">		&#123;</span><br><span class="line">			c_score = p[j];</span><br><span class="line">			c_id = j - <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	scores.<span class="built_in">push_back</span>(c_score * obj_score);</span><br><span class="line">	class_ids.<span class="built_in">push_back</span>(c_id);</span><br><span class="line">	boxes.<span class="built_in">push_back</span>(cv::<span class="built_in">Rect</span>((p[<span class="number">0</span>] - p[<span class="number">2</span>] / <span class="number">2</span>) / scale, (p[<span class="number">1</span>] - p[<span class="number">3</span>] / <span class="number">2</span>) / scale, p[<span class="number">2</span>] / scale, p[<span class="number">3</span>] / scale));</span><br><span class="line">	p += step; <span class="comment">// 指向下一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用了OpenCV提供的NMS方法 <code>cv::dnn::NMSBoxes</code> 。其中 <code>boxes</code> 为存储了 <code>Rect</code> 类的向量， <code>scores</code> 为存储了分值的向量， <code>score_threshold</code> 为检测分值阈值， <code>nms_threshold</code> 为NMS操作的阈值， <code>indices</code> 为一个空向量，用来存储NMS的结果。最后按照 <code>indices</code> 给出的物体序号提取最终结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行非最大值抑制以消除具有较低置信度的冗余重叠框</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; indices;</span><br><span class="line">cv::dnn::<span class="built_in">NMSBoxes</span>(boxes, scores, score_threshold, nms_threshold, indices);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集检测结果</span></span><br><span class="line">std::vector&lt;Result&gt; results;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : indices) </span><br><span class="line">&#123;</span><br><span class="line">    results.<span class="built_in">push_back</span>(Result &#123; scores[i], boxes[i], class_ids[i] &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>保存结果：它将包含绘制结果的图像保存下来。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : results)</span><br><span class="line">&#123;</span><br><span class="line">	cv::<span class="built_in">rectangle</span>(img_bgr, r.box, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cv::<span class="built_in">imwrite</span>(<span class="string">&quot;result.jpg&quot;</span>, img_bgr);</span><br></pre></td></tr></table></figure>

<h3><span id="525-主函数设计">5.2.5 主函数设计</span></h3><p>此程序主函数与基于.onnx文件推理程序类似，通过<code>main</code>函数的参数进行传参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//yolov5-engine.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Run like this:\n    &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; yolov5s.engine input.jpg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="built_in">run</span>(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以当调用该程序时，只需在命令提示符的当前目录下，输入指令格式：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">yolov5-engine.exe best.engine input.jpg</span><br></pre></td></tr></table></figure>

<p><br><br><br></p>
<h1><span id="陆-打包软件">陆 —— 打包软件</span></h1><h2><span id="61-基于onnx文件图像推理程序打包">6.1 基于.onnx文件图像推理程序打包</span></h2><p>打包程序考虑其可用性，在输出文件的时候做了处理：在当前目录输出一张照片，在<code>output/</code>文件夹也输出一张照片并做名字冲突处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导出名冲突</span></span><br><span class="line"><span class="function">string <span class="title">getUniqueFileName</span><span class="params">(<span class="type">const</span> std::string &amp;fileName, <span class="type">const</span> std::string &amp;outputDirectory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string baseName, extension;</span><br><span class="line">	<span class="type">size_t</span> dotIndex = fileName.<span class="built_in">rfind</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">	<span class="keyword">if</span> (dotIndex != string::npos)</span><br><span class="line">	&#123;</span><br><span class="line">		baseName = fileName.<span class="built_in">substr</span>(<span class="number">0</span>, dotIndex);</span><br><span class="line">		extension = fileName.<span class="built_in">substr</span>(dotIndex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		baseName = fileName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string newFileName = fileName;</span><br><span class="line">	<span class="type">int</span> counter = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ifstream(outputDirectory + newFileName).<span class="built_in">good</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		newFileName = baseName + <span class="string">&quot;_&quot;</span> + <span class="built_in">to_string</span>(counter) + extension;</span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newFileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备份存储</span></span><br><span class="line">string dir = <span class="string">&quot;output/&quot;</span>; <span class="comment">//文件夹路径</span></span><br><span class="line"><span class="keyword">if</span> (_access(dir.<span class="built_in">c_str</span>(), <span class="number">0</span>) == <span class="number">-1</span>)<span class="comment">//判断该文件夹是否存在</span></span><br><span class="line">&#123;</span><br><span class="line">	_mkdir(dir.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;result.jpg&quot;</span>, srcimg);</span><br><span class="line">string newname = <span class="built_in">getUniqueFileName</span>(<span class="string">&quot;result.jpg&quot;</span>, <span class="string">&quot;output/&quot;</span>);</span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;output/&quot;</span> + newname, srcimg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于主函数设计为可用命令提示符运行，故只需使用Visual Studio的Release版本生成.exe文件，再参考<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/11/#more">此博客</a>进行打包即可。</p>
<p>打包之后即可移植到其他PC设备使用。</p>
<h2><span id="62-基于engine文件图像推理程序打包">6.2 基于.engine文件图像推理程序打包</span></h2><p>同理，打包程序考虑其可用性，在输出文件的时候做了处理：在当前目录输出一张照片，在<code>output/</code>文件夹也输出一张照片并做名字冲突处理。</p>
<p>由于主函数设计为可用命令提示符运行，故只需使用Visual Studio的Release版本生成.exe文件，再参考<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/11/#more">此博客</a>进行打包即可。</p>
<p>注意一点，由于.engine文件需要调用显卡驱动，故不能移植到别的电脑使用（暂时我是没成功）。</p>
<h2><span id="63-整体打包">6.3 整体打包</span></h2><p>此次项目整体打包采用Qt作为前端页面，将上面两个打包好的程序结合，使用时只需调用指定程序模块即可。具体Qt打包可参考<a href="https://fingsinz.space/%E6%97%A5%E5%B8%B8/10/">此博客</a></p>
<p>具体代码不细展开，分享于<a href="https://gitee.com/fingsinz/ele-bicycle-detection/">码云仓库</a>。</p>
<p><br><br><br></p>
<h1><span id="柒-总结及后话">柒 —— 总结及后话</span></h1><p>实际上，如5.1的步骤，将参数改为.trt，即可导出.trt文件。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">trtexec --onnx=best.onnx --saveEngine=best.trt</span><br></pre></td></tr></table></figure>

<p>至于如何根据.trt文件设计算法进一步进行推测识别，此次项目未能完成，有待补充，深度学习很多方面的知识也有待补充。故此次项目仅能作为一个带有启发性的入门级别的项目。</p>
<p>深度学习是机器学习领域中的一个新的研究方向，旨在让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据。深度学习试图为数据的高层次摘要进行建模，通过使用多个处理层和对这些层的结果进行线性和非线性的转换，来实现对数据的识别和理解。深度学习在搜索技术、数据挖掘、机器翻译、自然语言处理、多媒体学习、语音、推荐和个性化技术等领域都取得了了很多成果。经过这次项目，我感受到了深度学习的有趣，写下这篇博客，用于记录与分享。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>YOLOv5</tag>
        <tag>TensorRT</tag>
        <tag>C++推演</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
</search>
