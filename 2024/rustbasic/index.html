<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="Rust 语言学习记录" />
    <meta name="hexo-theme-A4" content="v1.8.3" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Fingsinz&#39;s space | 风信梓</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.1.1">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
    
    <style>
        :root {
            --waline-theme-color: #000000; 
            --waline-color: #000000; 
            --waline-border-color: #000000; 
            --waline-white: #000000; 
            --waline-bgcolor-light: white;  
        }
        body {
            color: #000000;
            background: #bed2bb;
        }
        .post-md code {
            background: #e7f7f3;
            color: #7f688d; 
        }
        .post-md pre, .post-md .highlight {
            background: #e7f7f3;
            color: #7f688d; 
        }
        pre .string, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata {
            color: #000000;
        }
        pre .number, pre .preprocessor, pre .built_in, pre .literal, pre .params, pre .constant {
            color: #000000;
        }
        .year-font-color {
            color: #000000 !important;
        }
        .wl-card span.wl-nick {
            color: #000000; 
        }
        .wl-card .wl-badge {
            border: 1px solid #000000;
            color: #000000; 
        }
        .wl-btn {
            border: 1px solid #000000; 
            color:  #000000;  
        }
        .wl-btn.primary {
            color: white; 
        }
        .wl-header label {
            color: #000000;
        }
        a {
            color: #6b798e;
        }

        .post-md a {
            color: #6b798e;
        }

        .nav li a {
            color: #6b798e;
        }

        .archive-main a:link {
            color: #6b798e;
        }
        .archive-main a:visited {
            color: #6b798e; 
        }

        .archive li span {
            color: #000000;
        }

        .post-main-title {
            color: #000000;
        }

        .post-md h1,
        .post-md h2,
        .post-md h3,
        .post-md h4,
        .post-md h5,
        .post-md h6 {
            color: #000000;
        }

        [data-waline] p {
            color: #000000;
        }
        [data-waline] a {
            color: #000000;
        } 
        .wl-sort li.active {
            color: #000000;
        }

        .wl-card .wl-meta>span {
            background: white;
        }

        .paper {
            background: #bed2bb;
        }

        .index-main {
            background: white;
        }

        .paper-main {
            background: white;
        }

        .wl-panel {
            background: white;
        }

        .archive li:nth-child(odd) {
            background: white;
            ;
        }

        .archive li:nth-child(even) {
            background: white;
        }

        .post-md table tr:nth-child(odd) td {
            background: white;
        }

        .post-md table tr:nth-child(even) td {
            background: white;
        }

    
        .progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .progress-wrap::before {
	        background-image: linear-gradient(298deg, #6b798e, #6b798e); /* 鼠标滑过的箭头颜色 */
         }

        .return-to-last-progress-wrap::after {
            color: #000000; /* 箭头的颜色 */
        }
        .return-to-last-progress-wrap svg.progress-circle path {
	        stroke: #000000; /* 边框的颜色 */
        }
        .return-to-last-progress-wrap::before {
	        background-image: linear-gradient(298deg, #6b798e, #6b798e); /* 鼠标滑过的箭头颜色 */
         }

         .left-toc-container::-webkit-scrollbar-thumb {
            background-color: #000000; /* 设置滚动条拖动块的颜色 */
        }

        .bs-docs-sidebar .nav>.active>a,
        .bs-docs-sidebar .nav>li>a:hover,
        .bs-docs-sidebar .nav>li>a:focus {
            color: #6b798e;
            border-left-color: #6b798e;
        }
        .bs-docs-sidebar .nav>li>a {
            color:  #000000;
        }
    </style>

    
    <body>
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Fingsinz&#39;s space</a> 
            <span class="description">我在想，时下你所需要的，应该是痛痛快快换个心情，干干脆脆享受人生。</span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页🏚️</a></li>
            
        
            
                <li><a href="/list/">文章📄</a></li>
            
        
            
                <li><a href="/categories/">分类📁</a></li>
            
        
            
                <li><a href="/notes/">笔记📔</a></li>
            
        
            
                <li><a href="/funny/">趣事💡</a></li>
            
        
            
                <li><a href="/about/">关于🧑</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            Rust 语言学习记录
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%89%8D%E8%A8%80"><span class="post-toc-text">前言</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-rust"><span class="post-toc-text">什么是 Rust</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#rust-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="post-toc-text">Rust 的优势</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#windows-%E4%B8%8B%E5%AE%89%E8%A3%85-rust"><span class="post-toc-text">Windows 下安装 Rust</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9C%A8-vscode-%E4%B8%8A%E4%BD%BF%E7%94%A8-rust"><span class="post-toc-text">在 VSCode 上使用 Rust</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA-rust-%E7%A8%8B%E5%BA%8F"><span class="post-toc-text">第一个 Rust 程序</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98"><span class="post-toc-text">下载依赖卡顿问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#rust-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="post-toc-text">Rust 基础入门</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E6%9E%84"><span class="post-toc-text">变量绑定与解构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A"><span class="post-toc-text">变量绑定</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E4%B8%8E%E5%8F%AF%E5%8F%98"><span class="post-toc-text">变量的不可变与可变</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BF%BD%E7%95%A5%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="post-toc-text">忽略未使用的变量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%84"><span class="post-toc-text">变量解构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F"><span class="post-toc-text">不可变量与常量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E9%81%AE%E8%94%BD"><span class="post-toc-text">变量遮蔽</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">基本类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">数值类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97%E6%BA%A2%E5%87%BA"><span class="post-toc-text">整数运算溢出</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%B7%E9%98%B1"><span class="post-toc-text">浮点数陷阱</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#nan"><span class="post-toc-text">NaN</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B0%E5%AD%97%E8%BF%90%E7%AE%97"><span class="post-toc-text">数字运算</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BA%8F%E5%88%97"><span class="post-toc-text">序列</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8-as-%E5%AE%8C%E6%88%90%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="post-toc-text">使用 As 完成类型转换</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9C%89%E7%90%86%E6%95%B0%E4%B8%8E%E5%A4%8D%E6%95%B0"><span class="post-toc-text">有理数与复数</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6-%E5%B8%83%E5%B0%94-%E5%8D%95%E5%85%83%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">字符、布尔、单元类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="post-toc-text">语句与表达式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0"><span class="post-toc-text">函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%80%9F%E7%94%A8"><span class="post-toc-text">所有权和借用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="post-toc-text">所有权</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%A0%88%E4%B8%8E%E5%A0%86"><span class="post-toc-text">栈与堆</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E5%8E%9F%E5%88%99"><span class="post-toc-text">所有权的原则</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92"><span class="post-toc-text">变量绑定背后的数据交互</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="post-toc-text">拷贝（浅拷贝）</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%85%8B%E9%9A%86-%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="post-toc-text">克隆（深拷贝）</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83"><span class="post-toc-text">转移所有权</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E4%BC%A0%E5%80%BC%E4%B8%8E%E8%BF%94%E5%9B%9E"><span class="post-toc-text">函数传值与返回</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E5%80%9F%E7%94%A8"><span class="post-toc-text">引用和借用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="post-toc-text">引用和解引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="post-toc-text">不可变引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="post-toc-text">可变引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#nll"><span class="post-toc-text">NLL</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8"><span class="post-toc-text">悬垂引用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93"><span class="post-toc-text">借用规则总结</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">复合类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E5%88%87%E7%89%87"><span class="post-toc-text">字符串与切片</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%88%87%E7%89%87"><span class="post-toc-text">切片</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="post-toc-text">字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#string-%E4%B8%8E-str-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="post-toc-text">String 与 &amp;str 的转换</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95"><span class="post-toc-text">字符串索引</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="post-toc-text">字符串的操作</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89"><span class="post-toc-text">字符串转义</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E6%93%8D%E4%BD%9C-utf-8-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="post-toc-text">操作 UTF-8 字符串</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%89%96%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="post-toc-text">剖析字符串</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%83%E7%BB%84"><span class="post-toc-text">元组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%A7%A3%E6%9E%84%E5%85%83%E7%BB%84"><span class="post-toc-text">解构元组</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="post-toc-text">结构体</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="post-toc-text">结构体的语法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F"><span class="post-toc-text">结构体的内存排序</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="post-toc-text">元组结构体</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93"><span class="post-toc-text">单元结构体</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="post-toc-text">结构体数据的所有权</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#derive-debug"><span class="post-toc-text">[derive(Debug)]</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="post-toc-text">枚举</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84"><span class="post-toc-text">数组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="post-toc-text">创建数组</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="post-toc-text">访问数组元素</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87"><span class="post-toc-text">数组切片</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="post-toc-text">流程控制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#if-else-if"><span class="post-toc-text">if-else if</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6"><span class="post-toc-text">循环控制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="post-toc-text">for 循环</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#continue-%E5%92%8C-break"><span class="post-toc-text">continue 和 break</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="post-toc-text">while 循环</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#loop-%E5%BE%AA%E7%8E%AF"><span class="post-toc-text">loop 循环</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="post-toc-text">模式匹配</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#match-%E5%8C%B9%E9%85%8D"><span class="post-toc-text">match 匹配</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#match-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B5%8B%E5%80%BC"><span class="post-toc-text">match 表达式赋值</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%91%E5%AE%9A"><span class="post-toc-text">模式绑定</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%A9%B7%E5%B0%BD%E5%8C%B9%E9%85%8D"><span class="post-toc-text">穷尽匹配</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#if-let-%E5%8C%B9%E9%85%8D"><span class="post-toc-text">if let 匹配</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%98%E9%87%8F%E9%81%AE%E8%94%BD"><span class="post-toc-text">变量遮蔽</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#matches-%E5%AE%8F"><span class="post-toc-text">matches! 宏</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%A7%A3%E6%9E%84-option"><span class="post-toc-text">解构 Option</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="post-toc-text">模式使用场景</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%A8%E6%A8%A1%E5%BC%8F%E5%88%97%E8%A1%A8"><span class="post-toc-text">全模式列表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="post-toc-text">匹配字面值</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8C%B9%E9%85%8D%E5%91%BD%E5%90%8D%E5%8F%98%E9%87%8F"><span class="post-toc-text">匹配命名变量</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8D%95%E5%88%86%E6%94%AF%E5%A4%9A%E6%A8%A1%E5%BC%8F"><span class="post-toc-text">单分支多模式</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%80%9A%E8%BF%87%E5%BA%8F%E5%88%97-%E5%8C%B9%E9%85%8D%E5%80%BC%E8%8C%83%E5%9B%B4"><span class="post-toc-text">通过序列 …&#x3D; 匹配值范围</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%A7%A3%E6%9E%84%E5%B9%B6%E5%88%86%E8%A7%A3%E5%80%BC"><span class="post-toc-text">解构并分解值</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="post-toc-text">解构结构体</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E8%A7%A3%E6%9E%84%E6%9E%9A%E4%B8%BE"><span class="post-toc-text">解构枚举</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E8%A7%A3%E6%9E%84%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE"><span class="post-toc-text">解构嵌套的结构体和枚举</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%83%E7%BB%84"><span class="post-toc-text">解构结构体和元组</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E8%A7%A3%E6%9E%84%E6%95%B0%E7%BB%84"><span class="post-toc-text">解构数组</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%BF%BD%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="post-toc-text">忽略模式中的值</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8C%B9%E9%85%8D%E5%AE%88%E5%8D%AB%E6%8F%90%E4%BE%9B%E7%9A%84%E9%A2%9D%E5%A4%96%E6%9D%A1%E4%BB%B6"><span class="post-toc-text">匹配守卫提供的额外条件</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BB%91%E5%AE%9A"><span class="post-toc-text">@ 绑定</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95"><span class="post-toc-text">方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="post-toc-text">定义方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#self"><span class="post-toc-text">self</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95%E5%90%8D"><span class="post-toc-text">方法名</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F"><span class="post-toc-text">-&gt;运算符？</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B8%A6%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="post-toc-text">带有多个参数的方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0"><span class="post-toc-text">关联函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A4%9A%E4%B8%AA-impl-%E5%AE%9A%E4%B9%89"><span class="post-toc-text">多个 impl 定义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%BA%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="post-toc-text">为枚举实现方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%89%B9%E5%BE%81"><span class="post-toc-text">泛型和特征</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B3%9B%E5%9E%8B-generics"><span class="post-toc-text">泛型 Generics</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="post-toc-text">结构体中使用泛型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9E%9A%E4%B8%BE%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="post-toc-text">枚举中使用泛型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="post-toc-text">方法中使用泛型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E4%B8%BA%E5%85%B7%E4%BD%93%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="post-toc-text">为具体的泛型类型实现方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#const-%E6%B3%9B%E5%9E%8B"><span class="post-toc-text">const 泛型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%80%A7%E8%83%BD"><span class="post-toc-text">泛型的性能</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%B9%E5%BE%81-trait"><span class="post-toc-text">特征 Trait</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%9A%E4%B9%89%E7%89%B9%E5%BE%81"><span class="post-toc-text">定义特征</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E7%89%B9%E5%BE%81"><span class="post-toc-text">为类型实现特征</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E7%89%B9%E5%BE%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="post-toc-text">特征定义与实现的位置</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">默认实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E7%89%B9%E5%BE%81%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="post-toc-text">使用特征作为函数参数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F"><span class="post-toc-text">特征约束</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BA%A6%E6%9D%9F"><span class="post-toc-text">多重约束</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#where-%E7%BA%A6%E6%9D%9F"><span class="post-toc-text">Where 约束</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E4%BE%8B-%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="post-toc-text">例-找最大值</span></a></li><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%88%96%E7%89%B9%E5%BE%81"><span class="post-toc-text">特征约束有条件地实现方法或特征</span></a></li></ol></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%AD%E7%9A%84-impl-trait"><span class="post-toc-text">函数返回中的 impl Trait</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%80%9A%E8%BF%87-derive-%E6%B4%BE%E7%94%9F%E7%89%B9%E5%BE%81"><span class="post-toc-text">通过 derive 派生特征</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5%E7%89%B9%E5%BE%81"><span class="post-toc-text">调用方法需要引入特征</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BB%BC%E5%90%88%E4%BE%8B%E5%AD%90"><span class="post-toc-text">综合例子</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1-todo"><span class="post-toc-text">特征对象 Todo</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B7%B1%E5%85%A5%E7%89%B9%E5%BE%81-todo"><span class="post-toc-text">深入特征 Todo</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-todo"><span class="post-toc-text">集合类型 Todo</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-vector"><span class="post-toc-text">动态数组 Vector</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#kv-%E5%AD%98%E5%82%A8-hashmap"><span class="post-toc-text">KV 存储 HashMap</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%AE%A4%E8%AF%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-todo"><span class="post-toc-text">认识生命周期 Todo</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-todo"><span class="post-toc-text">返回值和错误处理 Todo</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97-todo"><span class="post-toc-text">包和模块 Todo</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8C%85-crate"><span class="post-toc-text">包 Crate</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%A8%A1%E5%9D%97-module"><span class="post-toc-text">模块 Module</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8-use-%E5%BC%95%E5%85%A5%E6%A8%A1%E5%9D%97%E5%8F%8A%E5%8F%97%E9%99%90%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="post-toc-text">使用 use 引入模块及受限可见性</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B3%A8%E9%87%8A%E5%92%8C%E7%A8%B3%E5%AE%9A-todo"><span class="post-toc-text">注释和稳定 Todo</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA-todo"><span class="post-toc-text">格式化输出 Todo</span></a></li></ol></li></ol>
            
        
        <div class=".article-gallery"><p>关键词：Rust</p>
<span id="more"></span>
<hr>
<p><strong>References：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://course.rs/about-book.html">Rust语言圣经(Rust Course)</a></li>
<li><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/book/">Rust 程序设计语言 中文版</a></li>
</ul>
<h2 id="前言">前言</h2>
<h3 id="什么是-rust">什么是 Rust</h3>
<p>Rust 是一门新的静态编译编程语言，其功能定位与 C++ 相似，它的 1.0 版本于 2015 年发布。</p>
<p><code>rustc</code> 使用 LLVM 作为它的后端。</p>
<p>Rust 支持多种平台和架构：x86、ARM、WebAssembly、Linux、Mac、Windows……</p>
<p>Rust 被广泛用于各种设备中：</p>
<ul>
<li>固件和引导程序</li>
<li>智能显示器</li>
<li>手机</li>
<li>桌面</li>
<li>服务器</li>
</ul>
<p>Rust 和 C++ 适用于类似的场景：</p>
<ul>
<li>极高的灵活性。</li>
<li>高度的控制能力。</li>
<li>能够在资源匮乏的设备（如手机）上运行。</li>
<li>没有运行时和垃圾收集。</li>
<li>关注程序可靠性和安全性，而不会牺牲任何性能。</li>
</ul>
<p>Rust 系统由许多工具组成：</p>
<ul>
<li><code>rustc</code>：Rust 编译器，将 <code>.rs</code> 文件转换为二进制文件和其他中间格式。</li>
<li><code>cargo</code>：Rust 依赖项管理器和构建工具（包管理工具）。负责下载依赖项并在构建项目时传递给编译器。其还附带内置的测试运行程序，用于执行单元测试。</li>
<li><code>rustup</code>：Rust 工具链安装和更新工具。当更新版本时，其用于安装并更新 <code>rustc</code> 和 <code>cargo</code>。还可用于下载标准库的文档，同时安装多个 Rust 版本。</li>
</ul>
<p>Rust 区分版本。这些版本支持对语言进行向后不兼容的更改。</p>
<ul>
<li>为防止破坏代码，版本是可选的： 通过 <code>Cargo.toml</code> 文件为 <code>crate</code> 选择合适的版本。</li>
<li>为免分割生态系统，Rust 编译器可以混合使用为不同版本编写的代码。</li>
</ul>
<h4 id="rust-的优势">Rust 的优势</h4>
<p>编译时内存安全：在编译时可防止所有类内存 bug。</p>
<ul>
<li>不存在未初始化的变量。</li>
<li>不存在“双重释放”。</li>
<li>不存在“释放后使用”。</li>
<li>不存在 NULL 指针。</li>
<li>不存在被遗忘的互斥锁。</li>
<li>不存在线程之间的数据竞争。</li>
<li>不存在迭代器失效。</li>
</ul>
<p>没有未定义的运行时行为：每个 Rust 语句的行为都有明确定义。</p>
<ul>
<li>数组访问有边界检查。</li>
<li>整数溢出有明确定义（panic 或回绕）。</li>
</ul>
<p>现代语言功能：具有与高级语言一样丰富且人性化的表达能力。</p>
<ul>
<li>枚举和模式匹配。</li>
<li>泛型。</li>
<li>无额外开销的外部函数接口（FFI）。</li>
<li>零成本抽象。</li>
<li>强大的编译器错误提示。</li>
<li>内置依赖管理器。</li>
<li>对测试的内置支持。</li>
<li>优秀的语言服务协议（Language Server Protocol）支持。</li>
</ul>
<h3 id="windows-下安装-rust">Windows 下安装 Rust</h3>
<p>可执行二进制文件下载地址：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.rust-lang.org/zh-CN/tools/install">https://www.rust-lang.org/zh-CN/tools/install</a></li>
<li><a target="_blank" rel="noopener" href="https://rustup.rs/">https://rustup.rs/</a></li>
<li>两个地址下载一个即可。</li>
</ul>
<p>点击运行 <code>rustup-init.exe</code>。</p>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_install.jpg" title="安装路径提示" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_install.jpg" alt="安装路径提示"></a></p>
<p>显示默认安装在 C 盘。</p>
<ul>
<li>此处已做修改，自定义安装路径。</li>
</ul>
<p>自定义安装路径步骤如下：</p>
<ol>
<li>创建自定义文件夹，我此处为 <code>D:/rust</code>。在内创建两个文件夹，分别为 <code>.cargo</code> 和 <code>.rustup</code>。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_newpath.jpg" title="创建文件夹" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_newpath.jpg" alt="创建文件夹"></a></p>
<ol start="2">
<li>配置环境变量：把新建的文件夹添加到环境变量中。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_cargohome.jpg" title="CargoHome" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_cargohome.jpg" alt="CargoHome"></a></p>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_rustuphome.jpg" title="RustupHome" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_rustuphome.jpg" alt="RustupHome"></a></p>
<ol start="3">
<li>在 <code>PATH</code> 环境变量中加入上两个变量。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_addPath.jpg" title="添加到PATH" class="gallery-item" style="box-shadow: none;"> <img src="https://fblog-1257020106.cos.ap-shanghai.myqcloud.com/imgs/rustbasic_addPath.jpg" alt="添加到PATH"></a></p>
<p>至此再打开 <code>rustup-init.exe</code>，观察路径是否修改。</p>
<p>接着输入 <code>1</code> 执行默认安装即可。</p>
<h3 id="在-vscode-上使用-rust">在 VSCode 上使用 Rust</h3>
<p>步骤如下：</p>
<ol>
<li>在扩展中查找并安装 <code>rust-analyzer</code> 和 <code>Native Debug</code> 两个插件。</li>
</ol>
<ul>
<li>另外两个推荐插件：
<ul>
<li>Even Better TOML，支持 .toml 文件完整特性</li>
<li>Error Lens，更好的获得错误展示</li>
</ul>
</li>
</ul>
<ol start="2">
<li>新建代码文件夹，在终端使用命令生成工程：</li>
</ol>
<figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>编写代码后，在终端使用命令运行：</li>
</ol>
<figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br><span class="line">cargo run</span><br></pre></td></tr></tbody></table></figure>
<h4 id="第一个-rust-程序">第一个 Rust 程序</h4>
<p>每一个语言一开始会有它的 Hello World。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>函数以 <code>fn</code> 开头。</li>
<li>代码块以 <code>{</code> 开头，以 <code>}</code> 结尾。</li>
<li>Rust 有卫生宏，<code>println!</code> 就是一个例子。
<ul>
<li>这意味着它们不会意外地捕获它们所在作用域中的标识符。</li>
</ul>
</li>
<li>Rust 字符串是 <code>UTF-8</code> 编码，可以包含 Unicode 字符。</li>
</ul>
<h3 id="下载依赖卡顿问题">下载依赖卡顿问题</h3>
<p>解决方法是：覆盖默认的镜像地址</p>
<p>在 <code>$HOME/.cargo/config.toml</code> 添加以下内容：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">replace-with = 'ustc'</span><br><span class="line"></span><br><span class="line">[source.ustc]</span><br><span class="line">registry = "git://mirrors.ustc.edu.cn/crates.io-index"</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>创建一个新的镜像源 <code>[source.ustc]</code>，然后将默认的 <code>crates-io</code> 替换成新的镜像源: <code>replace-with = 'ustc'</code>。</li>
</ul>
<h2 id="rust-基础入门">Rust 基础入门</h2>
<p>速览语法：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust 程序入口函数，跟其它语言一样，都是 main，该函数目前无返回值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 使用let来声明变量，进行绑定，默认a是不可变的</span></span><br><span class="line">    <span class="comment">// 此处没有指定a的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>; <span class="comment">// 语句的末尾必须以分号结尾</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主动指定b的类型为i32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">i32</span> = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以在数值中带上类型:30i32表示数值是30，类型是i32</span></span><br><span class="line">    <span class="comment">// 声明变量时添加 mut 表示变量是可变的，mut是mutable的缩写</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = <span class="number">30i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还能在数值和类型中间添加一个下划线，让可读性更好</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = <span class="number">30_i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟其它语言一样，可以使用一个函数的返回值来作为另一个函数的参数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e</span> = <span class="title function_ invoke__">add</span>(<span class="title function_ invoke__">add</span>(a, b), <span class="title function_ invoke__">add</span>(c, d));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// println!是宏调用，看起来像是函数但是它返回的是宏定义的代码块</span></span><br><span class="line">    <span class="comment">// 该函数将指定的格式化字符串输出到标准输出中(控制台)</span></span><br><span class="line">    <span class="comment">// {}是占位符，在具体执行过程中，会把e的值代入进来</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"( a + b ) + ( c + d ) = {}"</span>, e);</span><br><span class="line">    <span class="comment">// println! 会自动推导出具体的类型，因此无需手动指定输出类型</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，输入两个i32类型的32位有符号整数，返回它们的和</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(i: <span class="type">i32</span>, j: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    <span class="comment">// 返回相加值，这里可以省略return</span></span><br><span class="line">    <span class="comment">// 不添加 ;，表示返回 i + j，添加则表示返回空。</span></span><br><span class="line">    i + j</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="变量绑定与解构">变量绑定与解构</h3>
<p>Rust 默认变量是不可修改的，这使得程序运行时性能上的提升。</p>
<p>在命名方面，和其它语言没有区别，不过当给变量命名时，需要遵循 <a target="_blank" rel="noopener" href="https://course.rs/practice/naming.html">Rust 命名规范</a>。</p>
<h4 id="变量绑定">变量绑定</h4>
<p>在其他语言中，如 <code>int a = 1</code> 称为赋值。但 Rust 中， <code>let a = 1</code> 称为 <strong>变量绑定</strong>。</p>
<p>绑定一词源自 Rust 的所有权问题。</p>
<ul>
<li>任何内存对象都是有主人的（Owner），对象完全属于它的主人。</li>
<li>绑定就是把这个对象绑定给一个变量，使变量成为它的主人。</li>
</ul>
<h4 id="变量的不可变与可变">变量的不可变与可变</h4>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {}"</span>, x);</span><br><span class="line">    x = <span class="number">6</span>;  <span class="comment">// 错误：x 是不可变的</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {}"</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {}"</span>, y);</span><br><span class="line">    y = <span class="number">11</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {}"</span>, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这种不可变的优势是：一个变量往往被多处代码所使用，其中一部分代码假定该变量的值永远不会改变，而另外一部分代码却无情的改变了这个值，在实际开发过程中，这个错误是很难被发现的，特别是在多线程编程中。</p>
<h4 id="忽略未使用的变量">忽略未使用的变量</h4>
<p>Rust 的高安全性会认为不使用的变量可能会是个 BUG，所以进行警告。</p>
<p>使用下划线 <code>_</code> 开头的变量名会被忽略。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="变量解构">变量解构</h4>
<p><code>let</code> 不仅可以进行变量的绑定，还可以进行复杂变量的解构。</p>
<ul>
<li>从一个相对复杂的变量中，匹配出该变量的一部分内容。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 匹配 a 和 b</span></span><br><span class="line">    <span class="keyword">let</span> (a, <span class="keyword">mut</span> b): (<span class="type">bool</span>, <span class="type">bool</span>) = (<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {} {}"</span>, a, b);</span><br><span class="line">    b = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world! {} {}"</span>, a, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="不可变量与常量">不可变量与常量</h4>
<p>Rust 默认的是不可变量。常量是经过 <code>const</code> 修饰的量，且在 Rust 中值类型必须标注。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">123</span>; <span class="comment">// 可以编译，但可能有警告，因为该变量没有被使用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> b: <span class="type">i32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">2</span>;  <span class="comment">// 错误：常量不能被重新赋值</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="变量遮蔽">变量遮蔽</h4>
<p>像上面写过的，Rust 允许声明相同的变量名，且后声明的变量名会遮蔽前面声明的。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"x = : {x}"</span>); <span class="comment">// 12</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x = : {x}"</span>); <span class="comment">// 6</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这个程序首先将数值 5 绑定到 <code>x</code>，然后通过重复使用 <code>let x =</code> 来遮蔽之前的 <code>x</code>，并取原来的值加上 1，所以 <code>x</code> 的值变成了 6。第三个 <code>let</code> 语句同样遮蔽前面的 <code>x</code>，取之前的值并乘上 2，得到的 <code>x</code> 最终值为 12。</li>
<li>这和 <code>mut</code> 变量的使用是不同的，第二个 <code>let</code> 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配，而 <code>mut</code> 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。</li>
</ul>
<p>变量遮蔽的用处，在于在某个作用域内无需再使用之前的变量时，就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。</p>
<h3 id="基本类型">基本类型</h3>
<p>内置数据类型有：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">类型</th>
<th style="text-align:center">字面量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">有符号整数</td>
<td style="text-align:center"><code>i8</code>、<code>i16</code>、<code>i32</code>、<code>i64</code>、<code>i128</code>、<code>isize</code></td>
<td style="text-align:center"><code>-10</code>、<code>0</code>、<code>1_000</code>、<code>123_i64</code></td>
</tr>
<tr>
<td style="text-align:center">无符号整数</td>
<td style="text-align:center"><code>u8</code>、<code>u16</code>、<code>u32</code>、<code>u64</code>、<code>u128</code>、<code>usize</code></td>
<td style="text-align:center"><code>0</code>、<code>123</code>、<code>10_u16</code></td>
</tr>
<tr>
<td style="text-align:center">浮点数</td>
<td style="text-align:center"><code>f32</code>、<code>f64</code></td>
<td style="text-align:center"><code>3.14</code>、<code>-10.0e20</code>、<code>2_f32</code></td>
</tr>
<tr>
<td style="text-align:center">Unicode 标量类型</td>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center"><code>'a'</code>、<code>'α'</code>、<code>'∞'</code></td>
</tr>
<tr>
<td style="text-align:center">布尔值</td>
<td style="text-align:center"><code>bool</code></td>
<td style="text-align:center"><code>true</code>、<code>false</code></td>
</tr>
<tr>
<td style="text-align:center">单元类型</td>
<td style="text-align:center"><code>()</code></td>
<td style="text-align:center">其唯一的值也是 <code>()</code></td>
</tr>
</tbody>
</table>
<ul>
<li>数字中的下划线均可忽略，仅方便辨识，即 <code>1_000</code> 可以写成 <code>1000</code>，<code>123_i64</code> 等价 <code>123i64</code></li>
</ul>
<p>每种类型占用空间为：</p>
<ul>
<li><code>iN</code>、<code>uN</code> 和 <code>fN</code> 占用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 位。</li>
<li><code>isize</code> 和 <code>usize</code> 占用一个指针大小的空间。</li>
<li><code>char</code> 占用 4 个字节，32 位空间。</li>
<li><code>bool</code> 占用 1 个字节，8 位空间。</li>
</ul>
<p>类型推导与标注：编译器必须在编译期知道所有变量的类型，但这不意味着你需要为每个变量指定类型。</p>
<ul>
<li>Rust 编译器可以根据变量的值和上下文中的使用方式来自动推导出变量的类型。</li>
<li>在某些情况下，Rust 编译器无法推导出变量类型，需要手动去给予一个类型标注。</li>
</ul>
<h4 id="数值类型">数值类型</h4>
<h5 id="整数运算溢出">整数运算溢出</h5>
<p>关于运算时整数溢出：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mul</span>(a: <span class="type">i16</span>, b: <span class="type">i16</span>, c: <span class="type">i16</span>) <span class="punctuation">-&gt;</span> <span class="type">i16</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> a * b * c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">_product</span> = <span class="title function_ invoke__">mul</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"><span class="comment">// 尝试与溢出相乘，有符号整数16位的最大值为65535</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic（崩溃,Rust 使用这个术语来表明程序因错误而退出）。</li>
</ul>
<p>可以显式处理溢出，通过标准库针对原始数字类型提供的方法：</p>
<ul>
<li><code>wrapping_*</code> 在所有模式下都按照补码循环溢出规则，如 <code>wrapping_add</code>。</li>
<li><code>checked_*</code> 在发生溢出时返回 <code>None</code> 值。</li>
<li><code>overflowing_*</code> 返回该值和一个指示是否存在溢出的布尔值。</li>
<li><code>saturating_*</code> 可以限定计算后的结果不超过目标类型的最大值或低于最小值。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">u8</span> = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">wrapping_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = a.<span class="title function_ invoke__">checked_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = a.<span class="title function_ invoke__">overflowing_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e</span> = a.<span class="title function_ invoke__">saturating_add</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{a}"</span>);    <span class="comment">// 255</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{b}"</span>);    <span class="comment">// 19</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{c:?}"</span>);  <span class="comment">// None</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{d:?}"</span>);  <span class="comment">// (19, true)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{e}"</span>);    <span class="comment">// 255</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="浮点数陷阱">浮点数陷阱</h5>
<p>浮点数的使用需要谨慎，原因：</p>
<ol>
<li>浮点数往往是数字的近似表达（并不是精确的）。</li>
<li>浮点数在某些特性上时反直觉的（比如比较时）。</li>
</ol>
<p>所以：</p>
<ul>
<li>避免在浮点数上判断相等；</li>
<li>当结果在数学上存在未定义时需要小心。</li>
</ul>
<p>一段代码：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">abc</span>: (<span class="type">f32</span>, <span class="type">f32</span>, <span class="type">f32</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">xyz</span>: (<span class="type">f64</span>, <span class="type">f64</span>, <span class="type">f64</span>) = (<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"abc (f32)"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"   0.1 + 0.2: {:x}"</span>, (abc.<span class="number">0</span> + abc.<span class="number">1</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3e99999a</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"         0.3: {:x}"</span>, (abc.<span class="number">2</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3e99999a</span></span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"xyz (f64)"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"   0.1 + 0.2: {:x}"</span>, (xyz.<span class="number">0</span> + xyz.<span class="number">1</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3fd3333333333334</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"         0.3: {:x}"</span>, (xyz.<span class="number">2</span>).<span class="title function_ invoke__">to_bits</span>());</span><br><span class="line">    <span class="comment">// 3fd3333333333333</span></span><br><span class="line">    <span class="built_in">println!</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(abc.<span class="number">0</span> + abc.<span class="number">1</span> == abc.<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(xyz.<span class="number">0</span> + xyz.<span class="number">1</span> == xyz.<span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="nan">NaN</h5>
<p>对于数学上未定义的结果，比如负数取平方根，会返回一个 <code>NaN</code>表示。</p>
<ul>
<li>所有与 <code>NaN</code> 交互的操作都会返回一个 <code>NaN</code>。</li>
<li><code>NaN</code> 并不能用于比较。</li>
</ul>
<p>可以使用 <code>is_nan()</code> 方法判断是否为 <code>NaN</code>。</p>
<h5 id="数字运算">数字运算</h5>
<p>Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。</p>
<p>更多，运算符如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">解释</th>
<th style="text-align:center">是否可重载</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center"><code>ident!(...), ident!{...}, ident![...]</code></td>
<td style="text-align:center">宏展开</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center"><code>!expr</code></td>
<td style="text-align:center">按位非或逻辑非</td>
<td style="text-align:center">Not</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center"><code>var != expr</code></td>
<td style="text-align:center">不等比较</td>
<td style="text-align:center">PartialEq</td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center"><code>expr % expr</code></td>
<td style="text-align:center">算术取模</td>
<td style="text-align:center">Rem</td>
</tr>
<tr>
<td style="text-align:center"><code>%=</code></td>
<td style="text-align:center"><code>var %= expr</code></td>
<td style="text-align:center">算术取模与赋值</td>
<td style="text-align:center">RemAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>&amp;expr</code>, <code>&amp;mut expr</code></td>
<td style="text-align:center">借用</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td>
<td style="text-align:center">借用指针类型</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>expr &amp; expr</code></td>
<td style="text-align:center">按位与</td>
<td style="text-align:center">BitAnd</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;=</code></td>
<td style="text-align:center"><code>var &amp;= expr</code></td>
<td style="text-align:center">按位与及赋值</td>
<td style="text-align:center">BitAndAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center"><code>expr &amp;&amp; expr</code></td>
<td style="text-align:center">逻辑与</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>expr * expr</code></td>
<td style="text-align:center">算术乘法</td>
<td style="text-align:center">Mul</td>
</tr>
<tr>
<td style="text-align:center"><code>*=</code></td>
<td style="text-align:center"><code>var *= expr</code></td>
<td style="text-align:center">算术乘法与赋值</td>
<td style="text-align:center">MulAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>*expr</code></td>
<td style="text-align:center">解引用</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>*const type</code>, <code>*mut type</code></td>
<td style="text-align:center">裸指针</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>trait + trait</code>, <code>'a + trait</code></td>
<td style="text-align:center">复合类型限制</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>expr + expr</code></td>
<td style="text-align:center">算术加法</td>
<td style="text-align:center">Add</td>
</tr>
<tr>
<td style="text-align:center"><code>+=</code></td>
<td style="text-align:center"><code>var += expr</code></td>
<td style="text-align:center">算术加法与赋值</td>
<td style="text-align:center">AddAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>,</code></td>
<td style="text-align:center"><code>expr, expr</code></td>
<td style="text-align:center">参数以及元素分隔符</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>- expr</code></td>
<td style="text-align:center">算术取负</td>
<td style="text-align:center">Neg</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>expr - expr</code></td>
<td style="text-align:center">算术减法</td>
<td style="text-align:center">Sub</td>
</tr>
<tr>
<td style="text-align:center"><code>-=</code></td>
<td style="text-align:center"><code>var -= expr</code></td>
<td style="text-align:center">算术减法与赋值</td>
<td style="text-align:center">SubAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>-&gt;</code></td>
<td style="text-align:center"><code>fn(...) -&gt; type</code>, <code>\|...\| -&gt; type</code></td>
<td style="text-align:center">函数与闭包，返回类型</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center"><code>expr.ident</code></td>
<td style="text-align:center">成员访问</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>..</code></td>
<td style="text-align:center"><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td>
<td style="text-align:center">右排除范围</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>..</code></td>
<td style="text-align:center"><code>..expr</code></td>
<td style="text-align:center">结构体更新语法</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>..</code></td>
<td style="text-align:center"><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td>
<td style="text-align:center">“与剩余部分”的模式绑定</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>...</code></td>
<td style="text-align:center"><code>expr...expr</code></td>
<td style="text-align:center">模式: 范围包含模式</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center"><code>expr / expr</code></td>
<td style="text-align:center">算术除法</td>
<td style="text-align:center">Div</td>
</tr>
<tr>
<td style="text-align:center"><code>/=</code></td>
<td style="text-align:center"><code>var /= expr</code></td>
<td style="text-align:center">算术除法与赋值</td>
<td style="text-align:center">DivAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>:</code></td>
<td style="text-align:center"><code>pat: type</code>, <code>ident: type</code></td>
<td style="text-align:center">约束</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>:</code></td>
<td style="text-align:center"><code>ident: expr</code></td>
<td style="text-align:center">结构体字段初始化</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>:</code></td>
<td style="text-align:center"><code>'a: loop {...}</code></td>
<td style="text-align:center">循环标志</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>;</code></td>
<td style="text-align:center"><code>expr;</code></td>
<td style="text-align:center">语句和语句结束符</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>;</code></td>
<td style="text-align:center"><code>[...; len]</code></td>
<td style="text-align:center">固定大小数组语法的部分</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center"><code>expr &lt;&lt; expr</code></td>
<td style="text-align:center">左移</td>
<td style="text-align:center">Shl</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;=</code></td>
<td style="text-align:center"><code>var &lt;&lt;= expr</code></td>
<td style="text-align:center">左移与赋值</td>
<td style="text-align:center">ShlAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center"><code>expr &lt; expr</code></td>
<td style="text-align:center">小于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center"><code>expr &lt;= expr</code></td>
<td style="text-align:center">小于等于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center"><code>var = expr</code>, <code>ident = type</code></td>
<td style="text-align:center">赋值/等值</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center"><code>expr == expr</code></td>
<td style="text-align:center">等于比较</td>
<td style="text-align:center">PartialEq</td>
</tr>
<tr>
<td style="text-align:center"><code>=&gt;</code></td>
<td style="text-align:center"><code>pat =&gt; expr</code></td>
<td style="text-align:center">匹配准备语法的部分</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center"><code>expr &gt; expr</code></td>
<td style="text-align:center">大于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center"><code>expr &gt;= expr</code></td>
<td style="text-align:center">大于等于比较</td>
<td style="text-align:center">PartialOrd</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center"><code>expr &gt;&gt; expr</code></td>
<td style="text-align:center">右移</td>
<td style="text-align:center">Shr</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;=</code></td>
<td style="text-align:center"><code>var &gt;&gt;= expr</code></td>
<td style="text-align:center">右移与赋值</td>
<td style="text-align:center">ShrAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>@</code></td>
<td style="text-align:center"><code>ident @ pat</code></td>
<td style="text-align:center">模式绑定</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center"><code>expr ^ expr</code></td>
<td style="text-align:center">按位异或</td>
<td style="text-align:center">BitXor</td>
</tr>
<tr>
<td style="text-align:center"><code>^=</code></td>
<td style="text-align:center"><code>var ^= expr</code></td>
<td style="text-align:center">按位异或与赋值</td>
<td style="text-align:center">BitXorAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>\|</code></td>
<td style="text-align:center"><code>pat \| pat</code></td>
<td style="text-align:center">模式选择</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>\|</code></td>
<td style="text-align:center"><code>expr \| expr</code></td>
<td style="text-align:center">按位或</td>
<td style="text-align:center">BitOr</td>
</tr>
<tr>
<td style="text-align:center"><code>\|=</code></td>
<td style="text-align:center"><code>var \|= expr</code></td>
<td style="text-align:center">按位或与赋值</td>
<td style="text-align:center">BitOrAssign</td>
</tr>
<tr>
<td style="text-align:center"><code>\|\|</code></td>
<td style="text-align:center"><code>expr \|\| expr</code></td>
<td style="text-align:center">逻辑或</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center"><code>expr?</code></td>
<td style="text-align:center">错误传播</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h5 id="序列">序列</h5>
<p>即基于范围，如 <code>1..5</code> 生成从1到4的连续数字，左闭右开，常用于循环中。</p>
<ul>
<li><code>1..=5</code> 即可表示全闭区间。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> {</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"{} "</span>, i);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 1 2 3 4</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="使用-as-完成类型转换">使用 As 完成类型转换</h5>
<p>使用 <code>As</code> 来完成一个类型到另一个类型的转换，其最常用于将原始类型转换为其他原始类型。</p>
<h5 id="有理数与复数">有理数与复数</h5>
<p>社区开发的高质量 Rust 数值库：<a target="_blank" rel="noopener" href="https://crates.io/crates/num">num</a>。</p>
<p>导入也十分简单：</p>
<ol>
<li>创建工程：<code>cargo new complex-num</code>；</li>
<li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 添加 <code>num = "0.4.0"</code>。</li>
<li>导入 <code>num</code>：<code>use num::Complex;</code>。</li>
<li><code>cargo build &amp;&amp; cargo run</code>。</li>
</ol>
<p>实例代码：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> num::complex::Complex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Complex { re: <span class="number">2.1</span>, im: -<span class="number">1.2</span> };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Complex::<span class="title function_ invoke__">new</span>(<span class="number">11.1</span>, <span class="number">22.2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{} + {}i"</span>, result.re, result.im);</span><br><span class="line">    <span class="comment">// 13.2 + 21i</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="字符-布尔-单元类型">字符、布尔、单元类型</h4>
<p>字符：</p>
<ul>
<li>所有的 Unicode 值都可以作为 Rust 字符。</li>
<li>Unicode 为 4 字节编码，故字符类型也占用 4 个字节。</li>
</ul>
<p>布尔类型：</p>
<ul>
<li>占用 1 字节。</li>
</ul>
<p>单元类型：</p>
<ul>
<li>就是 <code>()</code>，唯一的值也为 <code>()</code>，可以理解为 <code>void</code>。</li>
<li><code>main</code> 函数返回的就是单元类型。</li>
<li>可以用 <code>()</code> 作为 map 的值，表示不关注具体的值，只关注 <code>key</code>。</li>
</ul>
<p><em>Rust中没有返回值的函数称为发散函数，即无法收敛的函数。</em></p>
<h4 id="语句与表达式">语句与表达式</h4>
<p>Rust 的语句和表达式：</p>
<ul>
<li>语句会执行一些操作但是不会返回一个值</li>
<li>表达式会在求值后返回一个值。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">0</span>; <span class="comment">// 语句</span></span><br><span class="line">x = x + <span class="number">1</span>;  <span class="comment">// 语句</span></span><br><span class="line">x + <span class="number">1</span>       <span class="comment">// 表达式</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>表达式总要返回值，且不能包含分号</strong></p>
<ul>
<li>带上分号则变成一条语句。</li>
</ul>
<p><code>let</code> 也是语句，故不能将 <code>let</code> 语句赋值给其他值。</p>
<p>表达式可以成为语句的一部分，例如 <code>let y = 6</code> 中，<code>6</code> 就是一个表达式，处理后后返回一个值 <code>6</code>。</p>
<p><em>能返回值，它就是表达式。</em></p>
<h4 id="函数">函数</h4>
<p>大概的格式如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>规范上，函数名和变量名需要使用蛇形命名法。</li>
<li>函数的位置随便，不在乎定义在何处。</li>
</ul>
<p>Rust 中定义函数如果需要具备参数 <strong>必须声明参数名称和类型</strong> 。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="title function_ invoke__">fun</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">fun</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) </span><br><span class="line">{</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x 的值为 : {}"</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"y 的值为 : {}"</span>, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Rust 函数声明返回值类型的方式：</p>
<ul>
<li>在参数声明之后用 <code>-&gt;</code> 来声明函数返回值的类型。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">{</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在函数体中，随时都可以以 <code>return</code> 关键字结束函数运行并返回一个类型合适的值。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ten</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当函数无返回值时：</p>
<ul>
<li>返回一个 <code>()</code>。</li>
<li>通过 <code>;</code> 结尾的语句返回一个 <code>()</code>。</li>
</ul>
<p>上面的发散函数，可以用 <code>!</code> 作返回类型，表示永不返回。</p>
<ul>
<li>这种语法往往用作会导致程序崩溃的函数。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">eend</span>() <span class="punctuation">-&gt;</span> ! {</span><br><span class="line">    <span class="built_in">panic!</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="所有权和借用">所有权和借用</h3>
<h4 id="所有权">所有权</h4>
<p>Rust 使用 <strong>所有权系统</strong>。</p>
<p>对于内存管理方面，计算机语言出现了三种流派：</p>
<ul>
<li>垃圾回收机制（GC）：程序运行时不断寻找不再使用的内存，代表有 Java、Go；</li>
<li>手动管理内存：通过调用函数方式进行申请和释放内存，代表有 C++；</li>
<li>通过所有权管理内存：编译器在编译时会根据一系列规则进行检查。
<ul>
<li>检查只发生在编译器，所有在运行期并不会有性能上的损失。</li>
</ul>
</li>
</ul>
<p>C 语言上的不安全：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">fun</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">char</span> *c = <span class="string">"xyz"</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>上述代码可以编译通过。</li>
<li><code>a</code> 为局部变量，当离开作用域时，其内存会被系统回收，从而返回成了悬挂指针。</li>
<li><code>c</code> 的值时常量，存储在常量区，其生命周期为整个程序运行期间，当程序结束系统才会回收这片内存。</li>
</ul>
<h5 id="栈与堆">栈与堆</h5>
<p>栈：先进后出。栈中的所有数据都必须占用已知且固定大小的内存空间。</p>
<p>堆：可存放对于大小未知或可能变化的数据。</p>
<ul>
<li>当往堆上放入数据时，请求一定大小的内存空间，OS在堆的某处寻找并标记区域为已使用，返回该地址的指针。这个过程称为在堆上分配内存（分配）。</li>
<li>指针会被推入栈中，通过栈中的指针获取在堆上的数据。</li>
</ul>
<p>两者在性能上：在栈上分配内存比在堆上分配内存要快，处理器在栈上分配数据会比在堆上分配数据更高效。</p>
<p>当代码调用函数时，传递给函数的参数（可能指向堆上数据的指针和函数的局部变量）依次入栈；当调用结束时，这些值按相反顺序出栈。</p>
<p>堆上的数据是缺乏组织的，所以管理堆上数据的分配和释放尤为重要。</p>
<ul>
<li>当没有及时释放时，便造成了内存泄漏（数据无法被回收）。</li>
</ul>
<h5 id="所有权的原则">所有权的原则</h5>
<p>原则如下：</p>
<ol>
<li>Rust 中每一个值都被一个变量所拥有，该变量称为值的所有者（Owner）。</li>
<li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者。</li>
<li>当变量（所有者）离开作用域时，这个值将被丢弃。</li>
</ol>
<h5 id="变量绑定背后的数据交互">变量绑定背后的数据交互</h5>
<p>了解深拷贝和浅拷贝。</p>
<blockquote>
<p>简单来说，深拷贝在内存上独立，复制内容在新的内存空间上。浅拷贝在内存上共享。比如把A复制到B，如果是深复制，则A和B独立互不影响；如果是浅复制，在修改A，B也会改变。</p>
</blockquote>
<h6 id="拷贝-浅拷贝">拷贝（浅拷贝）</h6>
<p>浅拷贝只发生在栈上，如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></tbody></table></figure>
<p>基本类型在编译时是已知大小，会存储在栈上，所以拷贝其值是快速的。</p>
<p>Rust 具有 <code>Copy</code> 的特征，可以用在类似整型这样在栈中存储的类型。</p>
<ul>
<li>如果拥有 <code>Copy</code> 特征，则一个旧变量在被赋值给其他变量后仍可用，即赋值的过程是拷贝的过程。</li>
</ul>
<p>规则：</p>
<ul>
<li>任何基本类型的组合可以 <code>Copy</code>；</li>
<li>不需要分配内存或某种形式的资源的类型是可以 <code>Copy</code></li>
</ul>
<p>一些 <code>Copy</code> 的类型：</p>
<ul>
<li>所有整数类型；</li>
<li>所有浮点数类型；</li>
<li>布尔类型；</li>
<li>字符类型；</li>
<li>包含的类型都可 <code>Copy</code> 的元组；</li>
<li>不可变引用 <code>&amp;T</code>
<ul>
<li><code>&amp;mut T</code> 是可变引用，不可以 <code>Copy</code>。</li>
</ul>
</li>
</ul>
<h6 id="克隆-深拷贝">克隆（深拷贝）</h6>
<p><strong>Rust 永远不会自动创建数据的深拷贝。</strong></p>
<ul>
<li>任何自动的复制都不是深拷贝。</li>
</ul>
<p>当需要深度复制数据时，使用方法 <code>clone()</code>。</p>
<ul>
<li>使用 <code>clone()</code> 会降低程序性能</li>
</ul>
<h6 id="转移所有权">转移所有权</h6>
<p>有代码如下：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这是浅拷贝，且没有发生所有权的转移。</li>
<li>整个过程的赋值都是通过浅拷贝方式完成，发生在栈中，所以不需要所有权转移。</li>
</ul>
<p>另有代码如下：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>String</code> 为字符串类型，是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成，其中堆指针是最重要的，它指向了真实存储字符串内容的堆内存（跟 C++ 的 <code>std::vector</code> 类似）。
<ul>
<li>即不会自动拷贝。</li>
</ul>
</li>
<li>此时处理方式为：当 <code>s1</code> 被赋予 <code>s2</code> 后，Rust 认为 <code>s1</code> 不再有效，因此也无需在 <code>s1</code> 离开作用域后 drop（丢弃） 任何东西。
<ul>
<li>把所有权从 <code>s1</code> 转移给了 <code>s2</code>，<code>s1</code> 在被赋予 <code>s2</code> 后就马上失效了。</li>
<li>这种类似于移动语义的机制，C++ 的 <code>std::move()</code>。</li>
</ul>
</li>
</ul>
<p>如果真的有两个所有者，那么当 <code>s1</code> 和 <code>s2</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放（double free）</strong> 的错误。</p>
<h5 id="函数传值与返回">函数传值与返回</h5>
<p>将值传递给函数，一样会发生移动或者赋值。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>); <span class="comment">// s 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s); <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                        <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line">                        <span class="comment">// println!("s value: {}", s); // 报错，s 已经移出作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">// x 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x); <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x value: {}"</span>, x); <span class="comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line"><span class="comment">// 所以不会有特殊操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) {</span><br><span class="line">    <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, some_string);</span><br><span class="line">} <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) {</span><br><span class="line">    <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, some_integer);</span><br><span class="line">} <span class="comment">// 这里，some_integer 移出作用域。不会有特殊操作</span></span><br></pre></td></tr></tbody></table></figure>
<p>对于返回的值：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>(); <span class="comment">// gives_ownership 将返回值移给 s1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>); <span class="comment">// s2 进入作用域</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);</span><br><span class="line">    <span class="comment">// s2 被移动到 takes_and_gives_back 中,它也将返回值移给 s3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s1: {:?}"</span>, s1);</span><br><span class="line">    <span class="comment">// println!("s2: {:?}", s2); // s2 被移走</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"s3: {:?}"</span>, s3);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line"><span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// gives_ownership 将返回值移动给调用它的函数</span></span><br><span class="line"><span class="comment">/// #### 返回值</span></span><br><span class="line"><span class="comment">/// 返回一个 String 的所有权</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    some_string</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="comment">/// #### 参数</span></span><br><span class="line"><span class="comment">/// * `a_string` - 要被移动给调用者的 String</span></span><br><span class="line"><span class="comment">/// #### 返回值</span></span><br><span class="line"><span class="comment">/// 将接收到的 String 的所有权返回出去</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">    <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于所有权，所以总是把一个值传来传去来使用它。</p>
<h4 id="引用和借用">引用和借用</h4>
<p>Rust 具有 <strong>借用</strong> 这一概念。</p>
<ul>
<li>借用：获取变量的引用。
<ul>
<li>如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主。</li>
</ul>
</li>
</ul>
<h5 id="引用和解引用">引用和解引用</h5>
<p>常规引用是一个指针类型，指向了对象存储的内存地址。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用 <code>*</code> 进行解引用。</li>
</ul>
<h5 id="不可变引用">不可变引用</h5>
<p>有如下代码：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> {</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>); <span class="comment">// 构造一个字符串</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{} {}"</span>, s1, len);</span><br><span class="line">    <span class="comment">// hello 5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>此处函数传入字符串，但无需再用返回的方式传出所有权。</li>
<li>函数参数为 <code>&amp;String</code>。</li>
<li><code>&amp;</code> 在此处表示引用，允许使用值，但不获取所有权。</li>
<li><code>&amp;s1</code> 为指向 <code>s1</code> 的引用，但不拥有它。</li>
</ul>
<p>这样借用可以进行对变量一定的访问。</p>
<h5 id="可变引用">可变引用</h5>
<p>当然也可以试着修改借用的变量。（得寸进尺）</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) {</span><br><span class="line">    string.<span class="title function_ invoke__">push_str</span>(<span class="string">", 🌏"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s);</span><br><span class="line">    <span class="comment">// hello, 🌏</span></span><br><span class="line">    <span class="comment">// 由于 Unicode 编码，当然 🌏 也可以显示</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>s</code> 是可变类型，<code>&amp;mut s</code> 是可变的引用，<code>string: &amp;mut String</code> 是接收可变引用的参数。</li>
</ul>
<p>但是，<strong>可变引用同时只能存在一个</strong>。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="comment">// let r2 = &amp;mut s; // 报错</span></span><br><span class="line">    <span class="comment">// print!("{} {}", r1, r2);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可变借用 <code>r1</code> 持续到最后一次使用的位置（即输出）；</li>
<li>在 <code>r1</code> 存活间，又尝试创建第二个可变借用 <code>r2</code> 是会引起出错的。</li>
</ul>
<p>这种限制的好处就是使 Rust 在编译期就避免数据竞争。数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。</p>
<p>数据竞争可由以下行为造成：</p>
<ul>
<li>两个或更多的指针同时访问同一数据</li>
<li>至少有一个指针被用来写入数据</li>
<li>没有同步数据访问的机制</li>
</ul>
<p><em>可以通过加大括号限制作用域的方式解决部分问题。引用的作用域从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号</em></p>
<p>还有一件事，<strong>可变引用与不可变引用不能同时存在</strong>。（太安全了吧QAQ）</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="comment">// 大问题，不能将`s`借用为可变的，因为它也被借用为不可变的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}, {}, and {}"</span>, r1, r2, r3);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可以理解为，正在借用不可变引用的用户，肯定不希望借用的东西莫名其妙被改了。</li>
</ul>
<h5 id="nll">NLL</h5>
<p>NLL：Not-Lexical-Lifetimes，一种 Rust 编译器优化行为。</p>
<ul>
<li>用于找到某个引用在作用域 <code>}</code> 结束前就不再被使用的代码位置。</li>
</ul>
<h5 id="悬垂引用">悬垂引用</h5>
<p>悬垂引用也叫做悬垂指针。</p>
<ul>
<li>指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。</li>
</ul>
<p>如在 C++ 中，易见的悬挂：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> aa = *<span class="built_in">fun</span>();</span><br><span class="line">	cout &lt;&lt; aa;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这其实是可以编译通过，但函数 <code>fun</code> 返回的指针式悬挂的。
<ul>
<li>当 <code>fun</code> 中的 <code>a</code> 离开作用域时，<code>a</code> 会被释放，但 <code>fun</code> 返回的指针仍然指向 <code>a</code>。</li>
</ul>
</li>
</ul>
<p>在 Rust 中编译器可以确保 <strong>引用永远也不会变成悬垂状态</strong>。</p>
<ul>
<li>当获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。（🐂牛）</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = <span class="title function_ invoke__">no_dangle</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> {</span><br><span class="line">    <span class="comment">// 报错：该函数返回了一个借用的值，但是已经找不到它所借用值的来源</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line">    &amp;a</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">    <span class="comment">// 正常的，返回一个解引用，即值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line">    *&amp;a</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="借用规则总结">借用规则总结</h5>
<ul>
<li>同一时刻，要么只有一个可变引用，要么有任意数量的不可变引用。</li>
<li>引用必须总是有效的（非悬挂）。</li>
</ul>
<h3 id="复合类型">复合类型</h3>
<p>复合类型是由其它类型组合而成的，最典型的就是结构体 <code>struct</code> 和枚举 <code>enum</code>。</p>
<h4 id="字符串与切片">字符串与切片</h4>
<p>Rust 的字符串并没有想象中的简单。</p>
<h5 id="切片">切片</h5>
<p>切片：允许引用集合中部分连续的元素序列，而不是引用整个集合。</p>
<ul>
<li>创建切片的语法：<code>[开始索引..终止索引]</code>，其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置，左闭右开。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>]; <span class="comment">// 等价于 &amp;s[..5]</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">all1</span> = &amp;s[<span class="number">0</span>..len];      <span class="comment">// 完整切片</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">all2</span> = &amp;s[..];          <span class="comment">// 完整切片</span></span><br></pre></td></tr></tbody></table></figure>
<p>注意，中文在 UTF-8 中占用三个字节。</p>
<p>字符串切片的类型标识是 <code>&amp;str</code>。</p>
<p>一个对初学者难受的代码：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"the first word is: {}"</span>, word);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> {</span><br><span class="line">    &amp;s[..<span class="number">1</span>]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="字符串">字符串</h5>
<p>Rust 中的字符是 Unicode 类型。</p>
<ul>
<li>每个字符占据 4 个字节内存空间。</li>
</ul>
<p>但是在字符串中是 UTF-8 编码。</p>
<ul>
<li>也就是字符串中的字符所占的字节数是变化的（1 - 4）。</li>
</ul>
<p>Rust 语言级别上的字符串类型：<code>str</code>。</p>
<ul>
<li>通常以引用类型出现 <code>&amp;str</code>，即字符串切片。</li>
<li><code>str</code> 是硬编码进可执行文件，无法修改。</li>
</ul>
<p><code>String</code> 是一个可增长、可改变且具有所有权的 UTF-8 编码字符串。</p>
<p><em>当提及字符串，往往指的是 <code>String</code> 类型和 <code>&amp;str</code> 字符串切片类型。</em></p>
<ul>
<li>除了 <code>String</code>，还有 <code>OsString</code>、<code>OsStr</code>、<code>CsString</code>、<code>CsStr</code> 等。</li>
<li>都以 <code>String</code> 或 <code>Str</code> 结尾，分别对应具有所有权和被借用的变量。</li>
</ul>
<h6 id="string-与-str-的转换">String 与 &amp;str 的转换</h6>
<p>从 <code>&amp;str</code> 类型生成 <code>String</code>：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">"hello"</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>从 <code>String</code> 类型转为 <code>&amp;str</code>：取引用</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>(s: &amp;<span class="type">str</span>) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, {}!"</span>, s);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Fingsinz"</span>);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s[..<span class="number">2</span>]);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(s.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="字符串索引">字符串索引</h6>
<p>字符串底层数据存储是 <code>[u8]</code>。</p>
<ul>
<li><strong>但不能使用索引进行访问字符串的子串。</strong>
<ul>
<li>因为字符串中的字符所占的字节数是变化的。</li>
<li>比如汉字占 3 个字节，而英文占 1 个字节。</li>
</ul>
</li>
</ul>
<p>以此类推，使用索引进行字符串切片（如 <code>&amp;str[0..2]</code>）时也需要格外小心。</p>
<h6 id="字符串的操作">字符串的操作</h6>
<p>追加：在原有的字符串上追加，并不会返回新的字符串。</p>
<ul>
<li><code>push(@pos, @char)</code> 追加字符 <code>char</code>；</li>
<li><code>push_str(@pos, @str)</code> 追加字符串字面量。</li>
<li>字符串需要是可变的。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Hello"</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">insert</span>(<span class="number">5</span>, <span class="string">'!'</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s);  <span class="comment">// Hello!</span></span><br><span class="line">    s.<span class="title function_ invoke__">insert_str</span>(<span class="number">6</span>, <span class="string">"World"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s);  <span class="comment">// Hello!World</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>替换：将字符串中的某个字符串替换成其他字符串。</p>
<ul>
<li><code>replace(@target, @replacement)</code>：将所有的目标字符串替换成新字符串。适用于 <code>String</code> 和 <code>&amp;str</code>。
<ul>
<li>该方法是返回一个新的字符串，而不是操作原来的字符串。</li>
</ul>
</li>
<li><code>replacen(@target, @replacement, @count)</code>：将 <code>count</code> 个的目标字符串替换成新字符串。适用于 <code>String</code> 和 <code>&amp;str</code>。
<ul>
<li>该方法是返回一个新的字符串，而不是操作原来的字符串。</li>
</ul>
</li>
<li><code>replace_range(@range, @replacement)</code>：将范围内的字符串替换成新字符串。仅适用于 <code>String</code> 类型。
<ul>
<li>该方法是直接操作原来的字符串，不会返回新的字符串。</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">"rust rust rust"</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">news1</span> = s.<span class="title function_ invoke__">replace</span>(<span class="string">"rust"</span>, <span class="string">"Rust"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">news2</span> = s.<span class="title function_ invoke__">replacen</span>(<span class="string">"rust"</span>, <span class="string">"Rust"</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, news1); <span class="comment">// Rust Rust Rust</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, news2); <span class="comment">// Rust Rust rust</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ms</span> = <span class="string">"rust rust rust"</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    ms.<span class="title function_ invoke__">replace_range</span>(<span class="number">5</span>..<span class="number">6</span>, <span class="string">"R"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, ms); <span class="comment">// rust Rust rust</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>删除：都仅适用于 <code>String</code> 类型。</p>
<ul>
<li><code>pop()</code>：删除并返回字符串的最后一个字符。
<ul>
<li>该方法直接操作原来的字符串。</li>
<li>返回值是一个 <code>Option</code> 类型，如果字符串为空，则返回 <code>None</code>。</li>
</ul>
</li>
<li><code>remove(@pos)</code>：删除并返回字符串指定位置（按字节处理）的字符。
<ul>
<li>该方法直接操作原来的字符串。</li>
</ul>
</li>
<li><code>truncate(@pos)</code>：删除字符串从指定位置（按字节处理）开始到结尾的全部字符。
<ul>
<li>该方法直接操作原来的字符串。</li>
</ul>
</li>
<li><code>clear()</code>：清空字符串。
<ul>
<li>该方法直接操作原来的字符串。</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="string">"Rrust!"</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">popstr</span> = s1.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, popstr.<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// !</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="title function_ invoke__">remove</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s1); <span class="comment">// Rust</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="title function_ invoke__">truncate</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s1); <span class="comment">// Ru</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s1); <span class="comment">// s1 为空</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>连接：连接字符串。</p>
<ul>
<li>使用 <code>+</code> 或者 <code>+=</code> 连接字符串：要求右边参数必须为字符串的切片引用类型，不能直接传递 <code>String</code> 类型。
<ul>
<li><code>+</code> 返回一个新的字符串，调用了 <code>add()</code> 方法：<code>fn add(self, s: &amp;str) -&gt; String</code>。</li>
</ul>
</li>
<li><code>format!</code> ：与 <code>print!</code> 类似。适用于 <code>String</code> 和 <code>&amp;str</code> 类型。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">"Hello "</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">"World"</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2;</span><br><span class="line">    <span class="comment">// println!("{}", s1); // s1 所有权由函数已经转移给 s3</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s2); <span class="comment">// World</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s3); <span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s4</span> = s3.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    s4 += <span class="string">"!"</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s4); <span class="comment">// Hello World!</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="字符串转义">字符串转义</h6>
<p>通过转移的方式 <code>\</code> 输出 ASCII 和 Unicode 字符。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 通过 \ + 字符的十六进制表示，转移输出一个字符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">"\x52\x75\x73\x74"</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s1); <span class="comment">// Rust</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// \u 可以输出一个 unicode 字符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">"\u{211D}"</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s2); <span class="comment">// ℝ</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加 \ 转义不换行</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="string">"a\</span></span><br><span class="line"><span class="string">        b\</span></span><br><span class="line"><span class="string">        c\</span></span><br><span class="line"><span class="string">        d</span></span><br><span class="line"><span class="string">        e"</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s3);</span><br><span class="line">    <span class="comment">// abcd</span></span><br><span class="line">    <span class="comment">//     e</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="操作-utf-8-字符串">操作 UTF-8 字符串</h6>
<p>逐字符遍历：</p>
<ul>
<li>避免索引尴尬情况。</li>
</ul>
<p>逐字节遍历：</p>
<ul>
<li>遍历字符串的底层字节数组表现形式。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">"我在用 Rust 编程"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() {</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"{}"</span>, c);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 我在用 Rust 编程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">bytes</span>() {</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"{} "</span>, b);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 230 136 145 229 156 168 231 148 168 32 82 117 115 116 32 231 188 150 231 168 139</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字符串包含双引号，可以在开头和结尾加 #</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotes</span> = <span class="string">r#"a"bbb"a"#</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, quotes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还是有歧义，可以继续增加，没有限制</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">longer_delimiter</span> = <span class="string">r###"aaaa"##!"###</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, longer_delimiter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果需要准确从 UTF-8 字符串中获取子串是较为复杂的事情。</p>
<ul>
<li>比如，想要从 <code>holla中国人नमस्ते</code> 这种变长的字符串中取出某一个子串，使用标准库是做不到的。
<ul>
<li>需要在 <a target="_blank" rel="noopener" href="http://crates.io">crates.io</a> 上搜索第三方库来寻找想要的功能。</li>
</ul>
</li>
</ul>
<h6 id="剖析字符串">剖析字符串</h6>
<p>关于 <code>String</code> 可变，而字符串字面值 <code>str</code> 却不可以：</p>
<ul>
<li>字面值文本在编译时就知道内容，直接硬编码进可执行文件中。
<ul>
<li>字面值是不可变的，而字符串是有在程序运行中动态变化的需求。</li>
</ul>
</li>
</ul>
<p><code>String</code> 类型支持一个可变、可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来管理内容：</p>
<ul>
<li>在使用 <code>String::from</code> 是就会构造 <code>String</code>类型；</li>
<li>在 <code>}</code> 处会自动调用释放内存函数 <code>drop</code>，用于释放离开作用域的变量。</li>
</ul>
<h4 id="元组">元组</h4>
<p><strong>元组是由多种类型组合到一起形成的。</strong></p>
<p>创建元组的语法如下：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure>
<h5 id="解构元组">解构元组</h5>
<p>用同样的形式把一个复杂对象中的值匹配出来或者使用 <code>.</code> 都可以访问元组的元素。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>, <span class="string">"aaa"</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> (x, y, z, w) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}, {}, {}, {}"</span>, x, y, z, w); <span class="comment">// 500, 6.4, 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//println!("{}, {}, {}, {}", tup.0, tup.1, tup.2, tup.3);</span></span><br><span class="line">    <span class="comment">// 上语句会报错，因为字符串的所有权已经转移到 w，所以 tup.3 不再有效</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用 <code>let (x, y, z, w) = tup</code> 进行模式匹配，用相似的模式进行匹配，元组对应的值就会绑定到变量 <code>x</code>、<code>y</code>、<code>z</code> 和 <code>w</code> 上。</li>
</ul>
<p>元组常用于函数的返回值上，返回多个值。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="string">"Hello "</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s1, len) = <span class="title function_ invoke__">string_splicing</span>(s1, s2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}:{}"</span>, s1, len);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">string_splicing</span>(s1: <span class="type">String</span>, s2: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ret</span> = s1 + s2;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = ret.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    (ret, len)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="结构体">结构体</h4>
<p>结构体与元组：都是由多种类型组合而成。</p>
<ul>
<li>但是与元组不同的是，结构体可以为内部的每个字段起一个富有含义的名称。</li>
</ul>
<h5 id="结构体的语法">结构体的语法</h5>
<p>一个结构体由几部分组成：</p>
<ul>
<li>关键字 <code>struct</code> 定义；</li>
<li>清晰的结构体名称；</li>
<li>几个结构体字段。</li>
</ul>
<p>如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> {</span><br><span class="line">    id: <span class="type">i32</span>,</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">i8</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">student</span> = Student {</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"John"</span>),</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}, {}, {}"</span>, student.id, student.name, student.age);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>初始化实例时，每个字段都需要初始化；</li>
<li>初始化时的顺序不必与定义时的顺序一致。</li>
<li>访问结构体字段时使用 <code>.</code>。</li>
</ul>
<p>另外注意，Rust 不支持将结构体的某个字段标记为可变，需要整个结构体声明为可变。</p>
<p>支持简化结构体构建：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">make_student</span>(id: <span class="type">i32</span>, name: <span class="type">String</span>, age: <span class="type">i8</span>) <span class="punctuation">-&gt;</span> Student {</span><br><span class="line">    Student { id, name, age }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>进行结构体更新时，也是挺方便的：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">student1</span> = Student {</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"John"</span>),</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">student2</span> = Student {</span><br><span class="line">        age: <span class="number">21</span>,</span><br><span class="line">        ..student1</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{} {} {}"</span>, student2.id, student2.name, student2.age);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>..</code> 语法表明凡是没有显式声明的字段，全部从 <code>student1</code> 中自动获取。</li>
<li>需要注意的是 <code>..student1</code> 必须在结构体的尾部使用。</li>
<li>此处 <code>student1.name</code> 的所有权已经移到 <code>student2</code>，所以 <code>student1.name</code> 不再有效，不能输出，但是其他字段（基本类型）依旧有效。</li>
</ul>
<h5 id="结构体的内存排序">结构体的内存排序</h5>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">File</span> {</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>File</code> 的内存排序如下：</p>
<table>
    <caption>File struct</caption>
	<tbody><tr>
	    <th colspan="3" align="center">name</th>
	    <th colspan="3" align="center">data</th>
	</tr>
	<tr>
	    <td colspan="3" align="center">String</td>
	    <td colspan="3" align="center">Vec</td>
	</tr>
	<tr>
	    <td>ptr</td>
        <td>size</td>
        <td>capacity</td>
        <td>ptr</td>
        <td>size</td>
        <td>capacity</td>
	</tr>
</tbody></table>
<ul>
<li><code>name</code> 的 <code>ptr</code> 指向一块 <code>[u8; name.size]</code> 内存的开头。</li>
<li><code>data</code> 的 <code>ptr</code> 指向另一块 <code>[u8; data.size]</code> 内存的开头。</li>
</ul>
<h5 id="元组结构体">元组结构体</h5>
<p>结构体必须要有名称，但是结构体的字段可以没有名称。</p>
<ul>
<li>元组结构体：这种结构体长得很像元组，字段没有名称。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="单元结构体">单元结构体</h5>
<p>单元结构体跟单元类型很像，没有任何字段和属性。</p>
<ul>
<li>当定义一个类型，但是不关心该类型的内容, 只关心它的行为时，就可以使用单元结构体。</li>
</ul>
<h5 id="结构体数据的所有权">结构体数据的所有权</h5>
<p>结构体当中它所拥有的数据应当是拥有所有权的，而不是其他地方借用的。</p>
<ul>
<li>借用数据需要考虑生命周期：生命周期确保结构体的作用范围比它所借用的数据的作用范围要小。</li>
</ul>
<h5 id="derive-debug">[derive(Debug)]</h5>
<p>Rust 默认没有给结构体实现 <code>Display</code> 特征，而把输出格式的选择权利交给程序员。</p>
<ul>
<li>顾名思义，<code>Display</code> 特征能够使得结构体实现自动格式输出。</li>
</ul>
<p>使用 <code>#[derive(Debug)]</code> 对结构体进行了标记，这样才能使用 <code>println!("{:?}", s);</code> 的方式对其进行打印输出：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle {</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:?}"</span>, rect1);</span><br><span class="line">    <span class="comment">// Rectangle { width: 30, height: 50 }</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用 <code>println!("{:?}", s);</code> 输出时，需要结构体实现 <code>Debug</code> 特征。</li>
<li><code>#[derive(Debug)]</code> 用 <code>derive</code> 派生实现了 <code>Debug</code> 特征。</li>
</ul>
<p>当结构体较大时，此时可以使用 <code>{:#?}</code> 来替代 <code>{:?}</code> 会有更美观的格式。</p>
<p>还有一个简单的输出 debug 信息的方法：使用 <code>dbg!</code> 宏。</p>
<ul>
<li>该宏会拿走表达式的所有权，然后打印出相应的文件名、行号等 debug 信息，还有表达式的求值结果。</li>
<li>它最终还会把表达式值的所有权返回。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> {</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scale</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle {</span><br><span class="line">        width: dbg!(<span class="number">30</span> * scale), <span class="comment">// 30 * scale = 60</span></span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    dbg!(&amp;rect1);</span><br><span class="line">    <span class="comment">// [src\main.rs:14:5] &amp;rect1 = Rectangle {</span></span><br><span class="line">    <span class="comment">//     width: 60,</span></span><br><span class="line">    <span class="comment">//     height: 50,</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="枚举">枚举</h4>
<p>通过列举可能的成员来定义一个枚举类型，如熟悉的枚举一周：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> {</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>枚举类型是一个类型，其会包含所有可能的枚举成员, 而枚举值是该类型中的具体某个成员的实例。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> {</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday,</span><br><span class="line">}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> (oh_no, no_no, ok, come_on, happy) = (</span><br><span class="line">        Weekday::Monday,</span><br><span class="line">        Weekday::Tuesday,</span><br><span class="line">        Weekday::Wednesday,</span><br><span class="line">        Weekday::Thursday,</span><br><span class="line">        Weekday::Friday,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> (happier, sad) = (Weekday::Saturday, Weekday::Sunday);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:?} {:?} {:?} {:?} {:?}"</span>, oh_no, no_no, ok, come_on, happy);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:?} {:?}"</span>, happier, sad);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 Rust 中，任何数据类型都可以放入到枚举中，这给枚举增加了更多功能。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Operation</span> {</span><br><span class="line">    Quit,                    <span class="comment">// 不包含变量</span></span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>), <span class="comment">// 包含三个 u8 变量</span></span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),           <span class="comment">// 包含一个 String 变量</span></span><br><span class="line">    Move { x: <span class="type">i32</span>, y: <span class="type">i32</span> }, <span class="comment">// 包含一个匿名结构体变量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">o1</span> = Operation::Quit;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">o2</span> = Operation::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">o3</span> = Operation::<span class="title function_ invoke__">Write</span>(<span class="string">"hello"</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="数组">数组</h4>
<p>数组：<code>array</code>，长度固定，是基本类型。</p>
<p>动态数组：<code>Vector</code>，长度可动态增长。</p>
<ul>
<li>数组的长度是编译时确定的，而动态数组的长度是运行时确定的。</li>
<li>数组 <code>array</code> 是存储在栈上，而动态数组 <code>Vector</code> 是存储在堆上。</li>
<li><code>Vector</code> 和 <code>String</code> 一样都是高级类型，即集合类型。</li>
</ul>
<h5 id="创建数组">创建数组</h5>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">// [3, 3, 3, 3, 3]</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>数组类型通过方括号声明；</li>
<li>可以显式指定数组元素类型和长度。</li>
<li>数组的长度也是类型的一部分。</li>
</ul>
<h5 id="访问数组元素">访问数组元素</h5>
<p>数组是连续的，可以通过索引访问。</p>
<ul>
<li>下标从 0 开始。</li>
</ul>
<p>另外，如果使用索引访问元素时，编译器会在编译期预防越界情况。但如果索引是外部输入的，那么编译器并不能预防。</p>
<p>如果数组元素非基础类型，且出现：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">array</span> = [<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"rust is good!"</span>); <span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:#?}"</span>, array);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>那必然是报错的。<code>String</code> 是具有所有权的高级类型，其并不能在数组中使用这种形式进行复制（没有深拷贝）。</li>
</ul>
<p>而解决方法应该是调用 <code>std::array::from_fn</code>：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">array</span>: [<span class="type">String</span>; <span class="number">8</span>] = std::array::<span class="title function_ invoke__">from_fn</span>(|_i| <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"rust"</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:#?}"</span>, array);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="数组切片">数组切片</h5>
<p>数组也允许引用集合中的部分连续片段：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"{:#?}"</span>, slice);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>省略主函数部分。</li>
</ul>
<p>切片的特点：</p>
<ul>
<li>切片的长度可以与数组不同，并不是固定的，取决于指定的起始和结束位置。</li>
<li>创建切片的代价非常小，因为切片只是针对底层数组的一个引用。</li>
<li>切片类型 <code>[T]</code> 拥有不固定的大小，而切片引用类型 <code>&amp;[T]</code> 则具有固定的大小，<code>&amp;[T]</code> 更有用，<code>&amp;str</code> 字符串切片也同理。</li>
</ul>
<h3 id="流程控制">流程控制</h3>
<h4 id="if-else-if">if-else if</h4>
<p><code>if else</code> 表达式根据条件执行不同的代码分支：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition == <span class="literal">true</span> {</span><br><span class="line">    <span class="comment">// A...</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// B...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>若 <code>condition</code> 的值为 <code>true</code>，则执行 A 代码，否则执行 B 代码。</li>
</ul>
<p><code>if</code> 语句（块）是表达式，可以返回值，但是需要保证每个分支的返回类型一样：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = <span class="keyword">if</span> a == <span class="number">1</span> {</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="number">6</span> <span class="comment">// 正确</span></span><br><span class="line">        <span class="comment">//'6' // 错误，类型不一致</span></span><br><span class="line">    };</span><br></pre></td></tr></tbody></table></figure>
<p>与其它语言一样，通过 <code>if-else if</code> 可以处理多重条件判断。</p>
<h4 id="循环控制">循环控制</h4>
<p>Rust 有三种循环控制方式：</p>
<ul>
<li><code>for</code> 循环；</li>
<li><code>while</code> 循环；</li>
<li><code>loop</code> 循环。</li>
</ul>
<h5 id="for-循环">for 循环</h5>
<p>简单举个例子：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> {</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"{} "</span>, i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>1..=5</code> 是一个范围，表示 从 1 到 5 的 序列。</li>
</ul>
<p>除了数字的循环外，<code>for-in</code> 用法更靓眼：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 元素 <span class="keyword">in</span> 集合 {</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<table>
    <caption>for-in的用法</caption>
    <tbody><tr>
        <th>使用方法</th>
        <th>等价使用方式</th>
        <th>所有权</th>
    </tr>
    <tr>
        <td><code>for item in collection</code></td>
        <td><code>for item in IntoIterator::into_iter(collection)</code></td>
        <td>转移所有权</td>
    </tr>
    <tr>
        <td><code>for item in &amp;collection</code></td>
        <td><code>for item in collection.iter()</code></td>
        <td>不可变借用</td>
    </tr>
    <tr>
        <td><code>for item in &amp;mut collection</code></td>
        <td><code>for item in collection.iter_mut()</code></td>
        <td>可变借用</td>
</tr></tbody></table>
<p><code>for-in</code> 中也可以获取元素的索引：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般的循环，数组实现了深拷贝所以所有权还在</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> a {</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"{} "</span>, i);</span><br><span class="line">        <span class="comment">// 4 3 2 1</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可获取索引的循环</span></span><br><span class="line">    <span class="comment">// `.iter()` 方法把 `a` 数组变成一个迭代器</span></span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, v) <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() {</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"({}:{}) "</span>, i + <span class="number">1</span>, v);</span><br><span class="line">        <span class="comment">// (1:4) (2:3) (3:2) (4:1)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果想单纯的循环十次，（用于）循环变量不使用，可以这样写：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">10</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">        <span class="comment">// 打印10次</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>_</code> 的含义是忽略该值或类型的意思。</li>
</ul>
<p>比较两种循环：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">collection</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..collection.<span class="title function_ invoke__">len</span>() {</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">item</span> = collection[i];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> collection {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>性能比较：
<ul>
<li>第一种方式使用索引，会触发边界检查，导致性能损耗。</li>
<li>第二种方式在编译时就完成分析并证明访问时合法的，性能不会有损失。</li>
</ul>
</li>
<li>安全性比较：
<ul>
<li>第一张对 <code>collection</code> 的索引访问是非连续的，存在一定可能性在两次访问之间 <code>collection</code> 发生了变化，导致脏数据产生。</li>
<li>第二种直接迭代是连续访问。（由于所有权限制，访问过程中，数据不会发生变化）</li>
</ul>
</li>
</ul>
<h5 id="continue-和-break">continue 和 break</h5>
<ul>
<li>使用 <code>continue</code> 可以跳过当次循环，开始下次循环。（在其它语言也这样吧）</li>
<li>使用 <code>break</code> 可以直接跳出当前整个循环。</li>
</ul>
<h5 id="while-循环">while 循环</h5>
<p>跟 C++ 类似。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n &lt;= <span class="number">5</span> {</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"{} "</span>, n); <span class="comment">// 0 1 2 3 4 5 </span></span><br><span class="line"></span><br><span class="line">        n = n + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, n); <span class="comment">// 6</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="loop-循环">loop 循环</h5>
<p><code>loop</code> 就是一个简单的 <strong>无限循环</strong>，不会自动结束。</p>
<ul>
<li>需要额外的 <code>break</code> 关键字控制循环结束。</li>
<li><code>loop</code> 是一个表达式，可以返回值。</li>
<li>在 <code>loop</code> 循环中，<code>break</code> 结束时可以带出一个返回值。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ret</span> = <span class="keyword">loop</span> {</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">5</span> {</span><br><span class="line">            <span class="keyword">break</span> n;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, ret);</span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="模式匹配">模式匹配</h3>
<p><code>match</code> 的魅力。</p>
<h4 id="match-匹配">match 匹配</h4>
<p><code>match</code> 的通用形式：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> target {</span><br><span class="line">    模式<span class="number">1</span> =&gt; 表达式<span class="number">1</span>,</span><br><span class="line">    模式<span class="number">2</span> =&gt; {</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        表达式<span class="number">2</span></span><br><span class="line">    },</span><br><span class="line">    _ =&gt; 表达式<span class="number">3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>match</code> 允许将一个值与一系列的模式相比较，并根据相匹配的模式执行对应的代码。</li>
<li><code>match</code> 的分支有两个部分：<strong>一个模式和针对该模式的处理代码</strong>。</li>
<li>跟 <code>switch</code> 很像，<code>_</code> 类似于 <code>default</code>。
<ul>
<li>除了 <code>_</code>，还可以随便用一个变量名承接即可。</li>
</ul>
</li>
<li><code>match</code> 语句会从上往下匹配，遇到第一个匹配的就执行对应的表达式，然后结束。</li>
<li>可能会出现 <code>|</code>，类似于逻辑或，比如 <code>X|Y</code> 可以匹配 <code>X</code> 也可以匹配 <code>Y</code>。</li>
</ul>
<p>举一个例子：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> {</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">direction</span> = Direction::Up;</span><br><span class="line">    <span class="keyword">match</span> direction {</span><br><span class="line">        Direction::Up =&gt; <span class="built_in">println!</span>(<span class="string">"Up"</span>),</span><br><span class="line">        Direction::Down =&gt; <span class="built_in">println!</span>(<span class="string">"Down"</span>),</span><br><span class="line">        Direction::Left =&gt; <span class="built_in">println!</span>(<span class="string">"Left"</span>),</span><br><span class="line">        Direction::Right =&gt; <span class="built_in">println!</span>(<span class="string">"Right"</span>),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="match-表达式赋值">match 表达式赋值</h5>
<p><code>match</code> 本身也是一个表达式，因此可以用来赋值：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> {</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">direction</span> = Direction::Up;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">direction_num</span> = <span class="keyword">match</span> direction {</span><br><span class="line">        Direction::Up =&gt; <span class="number">0</span>,</span><br><span class="line">        Direction::Down =&gt; <span class="number">1</span>,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, direction_num);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="模式绑定">模式绑定</h5>
<p>模式匹配还可以从模式中取出绑定的值，例如：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Action</span> {</span><br><span class="line">    <span class="title function_ invoke__">Say</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">MoveTo</span>(<span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">actions</span> = [Action::<span class="title function_ invoke__">Say</span>(<span class="string">"Hello Rust"</span>.<span class="title function_ invoke__">to_string</span>()), Action::<span class="title function_ invoke__">MoveTo</span>(<span class="number">1</span>, <span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">action</span> <span class="keyword">in</span> actions {</span><br><span class="line">        <span class="keyword">match</span> action {</span><br><span class="line">            Action::<span class="title function_ invoke__">Say</span>(s) =&gt; {</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"{}"</span>, s);</span><br><span class="line">            }</span><br><span class="line">            Action::<span class="title function_ invoke__">MoveTo</span>(x, y) =&gt; {</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Point ({}, {})"</span>, x, y);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>enum</code> 中可以放入数据类型，再加上模式匹配可以从模式中取出绑定的值，所以可以实现上述代码。</li>
</ul>
<h5 id="穷尽匹配">穷尽匹配</h5>
<p><code>match</code> 的匹配必须穷尽所有情况，比如下述代码因为没有穷尽所有情况而报错。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> {</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">direction</span> = Direction::Up;</span><br><span class="line">    <span class="keyword">match</span> direction {</span><br><span class="line">        Direction::Up =&gt; <span class="built_in">println!</span>(<span class="string">"UpUp"</span>),</span><br><span class="line">        <span class="comment">// 缺少 Down 的匹配</span></span><br><span class="line">        Direction::Left | Direction::Right =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"ohh"</span>);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="if-let-匹配">if let 匹配</h4>
<p>当只要匹配一个条件，且忽略其他条件时就用 <code>if let</code>。</p>
<p>如下面两个代码是等价的：</p>
<p>实现1：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> v {</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>实现2：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="number">3</span>) = v {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="变量遮蔽">变量遮蔽</h4>
<p>无论是 <code>match</code> 还是 <code>if let</code>，这里都是一个新的代码块，而且这里的绑定相当于新变量，如果你使用同名变量，会发生变量遮蔽：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Action</span> {</span><br><span class="line">    <span class="title function_ invoke__">Say</span>(<span class="type">String</span>),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">action</span> = Action::<span class="title function_ invoke__">Say</span>(<span class="string">"Hello Rust"</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">"abc"</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">match</span> action {</span><br><span class="line">        Action::<span class="title function_ invoke__">Say</span>(s) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{}"</span>, s); <span class="comment">// Hello Rust</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, s); <span class="comment">// abc</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="matches-宏">matches! 宏</h4>
<p><code>matches!</code> 宏可以将一个表达式跟模式进行匹配，然后返回匹配的结果 <code>true</code> 或者 <code>false</code>。</p>
<p>如使用：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ch</span> = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, matches!(ch, <span class="string">'a'</span>..=<span class="string">'z'</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, matches!(number, <span class="number">10</span>..=<span class="number">20</span>)); <span class="comment">// false</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="解构-option">解构 Option</h4>
<p><code>Option</code> 是一种枚举，用于解决 Rust 中变量是否有值的问题：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; {</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>一个变量要么有值：Some(T)，要么为空：None。</strong></li>
<li>由于封装，可以直接使用 <code>Some(T)</code> 和 <code>None</code>，而不需要使用  <code>Option::Some(T)</code> 和 <code>Option::None</code>。</li>
</ul>
<p>使用 <code>Option&lt;T&gt;</code>，是为了从 <code>Some</code> 中取出其内部的 <code>T</code> 值以及处理没有值的情况。</p>
<p>编写一个函数，它获取一个 <code>Option&lt;i32&gt;</code>，如果其中含有一个值，将其加一；如果其中没有值，则函数返回 <code>None</code> 值：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; {</span><br><span class="line">    <span class="keyword">match</span> x {</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="title function_ invoke__">Some</span>(x + <span class="number">1</span>),</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (ans1, ans2) = (<span class="title function_ invoke__">add_one</span>(five), <span class="title function_ invoke__">add_one</span>(none));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:?}, {:?}"</span>, ans1, ans2); <span class="comment">// Some(6), None</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="模式使用场景">模式使用场景</h4>
<p>用到模式的地方：</p>
<ul>
<li><code>match</code> 分支。</li>
<li><code>if let</code> 语句。</li>
<li><code>while let</code> 循环。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].<span class="title function_ invoke__">to_vec</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = v.<span class="title function_ invoke__">pop</span>() {</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"{} "</span>, top);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// c b a</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>for</code> 循环：使用特定模式匹配可迭代容器。</li>
<li><code>let</code> 语句：使用变量绑定数据也是一种模式匹配。</li>
<li>函数参数也是模式。</li>
</ul>
<p>还有关于 <code>let</code> 和 <code>if let</code>：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">Some</span>(x) = some_option_value;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>因为右边的值可能不为 <code>Some</code>，而是 <code>None</code>，这种时候就不能进行匹配。</li>
<li>对于 <code>let</code>、<code>for</code>、<code>match</code> 都要求完全覆盖匹配。</li>
</ul>
<p>而 <code>if let</code>：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = some_option_value {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, x);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>if let</code> 允许匹配一种模式，忽略其余模式。</li>
</ul>
<h4 id="全模式列表">全模式列表</h4>
<p><em>模式的相关语法</em></p>
<h5 id="匹配字面值">匹配字面值</h5>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x {</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"anything"</span>),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码获得特定的具体值。</li>
</ul>
<h5 id="匹配命名变量">匹配命名变量</h5>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x {</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">"match y = {:?}"</span>, y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"match： x = {:?}"</span>, x),</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"main: x = {:?}, y = {:?}"</span>, x, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>变量遮蔽。</li>
</ul>
<h5 id="单分支多模式">单分支多模式</h5>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x {</span><br><span class="line">        <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one or two"</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"anything"</span>),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用 <code>|</code> 表示或。</li>
</ul>
<h5 id="通过序列-匹配值范围">通过序列 …= 匹配值范围</h5>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x {</span><br><span class="line">        <span class="number">1</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"1~5"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"something else"</span>),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>序列只允许用于数字或字符类型，原因是它们可以连续。</li>
</ul>
<h5 id="解构并分解值">解构并分解值</h5>
<p>使用模式来解构结构体、枚举、元组、数组和引用。</p>
<h6 id="解构结构体">解构结构体</h6>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> {</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point { x: <span class="number">0</span>, y: <span class="number">7</span> };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> { x, y } = p;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> { x: a, y: b } = p;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"({}, {})"</span>, x, y); <span class="comment">// (0, 7)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"({}, {})"</span>, a, b); <span class="comment">// (0, 7)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>模式中的变量名不必与结构体中的字段名一致。</li>
</ul>
<p>还可以匹配结构体中的某个字段：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point { x: <span class="number">0</span>, y: <span class="number">7</span> };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p {</span><br><span class="line">        Point { x, y: <span class="number">0</span> } =&gt; <span class="built_in">println!</span>(<span class="string">"在x轴上{}"</span>, x),</span><br><span class="line">        Point { x: <span class="number">0</span>, y } =&gt; <span class="built_in">println!</span>(<span class="string">"在y轴上{}"</span>, y),</span><br><span class="line">        Point { x, y } =&gt; <span class="built_in">println!</span>(<span class="string">"不在轴上({}, {})"</span>, x, y),</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 在y轴上7</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="解构枚举">解构枚举</h6>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Op</span> {</span><br><span class="line">    Quit,</span><br><span class="line">    Move1 { x: <span class="type">i32</span>, y: <span class="type">i32</span> }, <span class="comment">// 绑定结构体</span></span><br><span class="line">    <span class="title function_ invoke__">Move2</span>(<span class="type">i32</span>, <span class="type">i32</span>),          <span class="comment">// 绑定元组</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">op</span> = Op::<span class="title function_ invoke__">Move2</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">match</span> op {</span><br><span class="line">        Op::Quit =&gt; <span class="built_in">println!</span>(<span class="string">"Quit"</span>),</span><br><span class="line">        Op::Move1 { x, y } =&gt; <span class="built_in">println!</span>(<span class="string">"Move1: ({}, {})"</span>, x, y),</span><br><span class="line">        Op::<span class="title function_ invoke__">Move2</span>(x, y) =&gt; <span class="built_in">println!</span>(<span class="string">"Move2: ({}, {})"</span>, x, y),</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>模式匹配需要类型相同。</li>
</ul>
<h6 id="解构嵌套的结构体和枚举">解构嵌套的结构体和枚举</h6>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> {</span><br><span class="line">    <span class="title function_ invoke__">Rgb</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hsv</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Op</span> {</span><br><span class="line">    Quit,</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(Color),</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Op::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg {</span><br><span class="line">        Op::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b)) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"R:{}, G:{}, B:{}"</span>, r, g, b)</span><br><span class="line">        }</span><br><span class="line">        Op::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(h, s, v)) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"H:{}, S:{}, V:{}"</span>, h, s, v)</span><br><span class="line">        }</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>match</code> 可以匹配嵌套的项。</li>
</ul>
<h6 id="解构结构体和元组">解构结构体和元组</h6>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> {</span><br><span class="line">        x: <span class="type">i32</span>,</span><br><span class="line">        y: <span class="type">i32</span>,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ((feet, inches), Point { x, y }) = ((<span class="number">3</span>, <span class="number">10</span>), Point { x: <span class="number">3</span>, y: -<span class="number">10</span> });</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"feet: {}, inches: {}, x: {}, y: {}"</span>, feet, inches, x, y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>用复杂的方式来混合、匹配和嵌套解构模式。</li>
<li>上述代码为结构体和元组嵌套在元组中，把原始类型解构出来。</li>
</ul>
<h6 id="解构数组">解构数组</h6>
<ul>
<li>定长数组解构：</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> [x, y, z] = arr;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{} {} {}"</span>, x, y, z);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>不定长数组解构：</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = &amp;_arr[..];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> [x, ..] = arr {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{}"</span>, x); <span class="comment">// 1</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> &amp;[.., y] = arr {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{}"</span>, y); <span class="comment">// 3</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: &amp;[<span class="type">i32</span>] = &amp;[];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(matches!(arr, [..])); <span class="comment">// 断言成功</span></span><br><span class="line">    <span class="built_in">assert!</span>(!matches!(arr, [x, ..])); <span class="comment">// 断言成功</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="忽略模式中的值">忽略模式中的值</h5>
<ul>
<li>使用 <code>_</code> 忽略整个值：当不再需要特定函数参数时，最好修改签名不再包含无用的参数。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fun</span>(_: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> () {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"只使用y：{}"</span>, y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="title function_ invoke__">fun</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用嵌套的 <code>_</code> 忽略部分值。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">match</span> (setting_value, new_setting_value) {</span><br><span class="line">        (<span class="title function_ invoke__">Some</span>(_), <span class="title function_ invoke__">Some</span>(_)) =&gt; {} <span class="comment">// 不关心值，只关心类型</span></span><br><span class="line">        _ =&gt; {</span><br><span class="line">            setting_value = new_setting_value;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"setting is {:?}"</span>, setting_value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">match</span> numbers {</span><br><span class="line">        (first, _, third, _, fifth) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{}, {}, {}"</span>, first, third, fifth);</span><br><span class="line">            <span class="comment">// 2, 6, 8</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>使用下划线开头忽略未使用的变量。</p>
<ul>
<li>带 <code>_</code> 的变量仍会将值绑定到变量，而 <code>_</code> 则完全不会绑定。</li>
</ul>
</li>
<li>
<p>用 <code>..</code> 忽略剩余值。</p>
</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">match</span> numbers {</span><br><span class="line">        (first, .., end) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{}, {}"</span>, first, end);</span><br><span class="line">            <span class="comment">// 2, 8</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">match</span> numbers {</span><br><span class="line">        (first, ..) =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{}"</span>, first); <span class="comment">// 2</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="匹配守卫提供的额外条件">匹配守卫提供的额外条件</h5>
<p>匹配守卫（match guard）是一个位于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它能为分支模式提供更进一步的匹配条件。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x {</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) <span class="keyword">if</span> n &gt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"&gt; 5"</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) <span class="keyword">if</span> y =&gt; <span class="built_in">println!</span>(<span class="string">"{}"</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(_) | <span class="literal">None</span> <span class="keyword">if</span> y =&gt; <span class="built_in">println!</span>(<span class="string">"aa"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"bb"</span>),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>匹配守卫直接取得解构后的值作比较（如匹配分支1）；</li>
<li>匹配守卫可以直接用外部的 <code>y</code>（如匹配分支2）；</li>
<li>使用 <code>|</code> 加上匹配守卫，需要先满足前面 或 的条件再判断匹配守卫的条件（如匹配分支3），即 <code>(Some(_) | None) if y</code>。</li>
</ul>
<h5 id="绑定">@ 绑定</h5>
<p><code>@</code> 运算符允许为一个字段绑定另一个变量。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Op</span> {</span><br><span class="line">    Operation { id: <span class="type">i32</span> },</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">op</span> = Op::Operation { id: <span class="number">5</span> };</span><br><span class="line">    <span class="keyword">match</span> op {</span><br><span class="line">        Op::Operation { id: mid @ <span class="number">3</span>..=<span class="number">7</span> } =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{} &gt;= 3 and {} &lt;= 7"</span>, mid, mid);</span><br><span class="line">        }</span><br><span class="line">        Op::Operation { id: <span class="number">0</span>..=<span class="number">2</span> } =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&gt;= 0 and &lt;= 2"</span>);</span><br><span class="line">        }</span><br><span class="line">        Op::Operation { id } =&gt; {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{}"</span>, id);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>第一个匹配分支中，测试 <code>Op::Operation</code> 的 <code>id</code> 字段是否位于 <code>3..=7</code> 范围内，同时也希望能将其值绑定到 <code>mid</code> 变量中以便此分支中相关的代码可以使用它。
<ul>
<li>其实也可以把 <code>mid</code> 命名为 <code>id</code>，不影响、</li>
</ul>
</li>
<li>第二个匹配分支中，没有使用 <code>@</code> 绑定，所以不能再使用结构体中的 <code>id</code>。</li>
</ul>
<p>在 Rust 1.56 时新增，使用 <code>@</code> 还可以在绑定新变量的同时对目标进行解构。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> {</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="comment">// 绑定新变量 `p`，同时对 `Point` 进行解构</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> @ Point { x: px, y: py } = Point { x: <span class="number">10</span>, y: <span class="number">23</span> };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x: {}, y: {}"</span>, px, py); <span class="comment">// x: 10, y: 23</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:?}"</span>, p); <span class="comment">// Point { x: 10, y: 23 }</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = Point { x: <span class="number">10</span>, y: <span class="number">5</span> };</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">p</span> @ Point { x: <span class="number">10</span>, y } = point {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"({},{})"</span>, p.x, p.y); <span class="comment">// (10,5)</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">":("</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 Rust 1.53 新增特性：</p>
<ul>
<li>在 Rust 1.53 之前，需要这么写：</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">match</span> number {</span><br><span class="line">        num @ <span class="number">1</span> | num @ <span class="number">2</span> | num @ <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"{}"</span>, num),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"{}"</span>, number),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>但是在 Rust 1.53 之后，可以这么写：</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">match</span> number {</span><br><span class="line">        num @ (<span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"{}"</span>, num),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"{}"</span>, number),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="方法">方法</h3>
<p>在面向对象编程中，方法指的是对象可执行的函数。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.method();</span><br></pre></td></tr></tbody></table></figure>
<h4 id="定义方法">定义方法</h4>
<p>使用 <code>impl</code> 来定义方法。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> {</span><br><span class="line">    width: <span class="type">i32</span>,</span><br><span class="line">    height: <span class="type">i32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(w: <span class="type">i32</span>, h: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Rect {</span><br><span class="line">        Rect {</span><br><span class="line">            width: w,</span><br><span class="line">            height: h,</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">shape</span> = Rect::<span class="title function_ invoke__">new</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, shape.<span class="title function_ invoke__">area</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>impl Rect</code> 表示为 <code>Rect</code> 实现方法，即 <code>impl</code> 语句块中一切都是跟 <code>Rect</code> 相关联的。</li>
<li><code>new</code> 是 <code>Rect</code> 的关联函数，因为第一个参数不是 <code>self</code>，且 <code>new</code> 不是关键字。</li>
<li><code>area</code> 中的参数 <code>&amp;self</code> 表示借用当前的 <code>Rect</code> 结构体，</li>
</ul>
<p><strong>Rust 的对象定义和方法定义是分离的。</strong></p>
<p>方法代替函数的好处有：</p>
<ul>
<li>不用再在函数签名中书写 <code>self</code> 对应的类型；</li>
<li>代码的组织性、内聚性更强，对于代码维护和阅读有好处。</li>
</ul>
<h5 id="self">self</h5>
<p><code>self</code> 指代类型的实例（跟Python中挺像）。</p>
<ul>
<li>为哪个结构体实现方法，那么 <code>self</code> 就是指代哪个结构体的实例。</li>
</ul>
<p><code>self</code> 依然具有所有权的概念：</p>
<ul>
<li><code>self</code> 表示 <code>Rect</code> 的所有权转移到该方法中，这种形式用的较少。</li>
<li><code>&amp;self</code> 表示该方法对 <code>Rect</code> 的不可变借用。</li>
<li><code>&amp;mut self</code> 表示可变引用。</li>
</ul>
<h5 id="方法名">方法名</h5>
<p><strong>在 Rust 中，允许方法名跟结构体的字段名相同。</strong></p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> {</span><br><span class="line">    width: <span class="type">i32</span>,</span><br><span class="line">    height: <span class="type">i32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">        <span class="keyword">self</span>.width</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">height</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">        <span class="keyword">self</span>.height</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>此时，<code>rect.width()</code> 表示调用方法，<code>rect.width</code> 表示访问字段。</li>
</ul>
<p>方法跟字段同名，适用于 <code>getter</code> 访问器的实现。</p>
<h5 id="运算符？">-&gt;运算符？</h5>
<p>C/C++ 中，如果对象指针调用方法时，会使用到 <code>-&gt;</code>：<code>object-&gt;fun()</code>。</p>
<p>但在 Rust 中，会有自动引用和解引用的功能。</p>
<ul>
<li>当使用 <code>object.fun()</code> 调用方法时，会自动为 <code>object</code> 添加 <code>&amp;</code>、<code>&amp;mut</code> 或 <code>*</code> 以便使得与方法签名匹配。</li>
<li>因为方法中明确接收 <code>self</code> 的类型。</li>
</ul>
<h4 id="带有多个参数的方法">带有多个参数的方法</h4>
<p>和普通函数一样：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rect) <span class="punctuation">-&gt;</span> <span class="type">bool</span> {</span><br><span class="line">        <span class="keyword">self</span>.width &gt;= other.width &amp;&amp; <span class="keyword">self</span>.height &gt;= other.height</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="关联函数">关联函数</h4>
<p>关联函数：定义在 <code>impl</code> 中且参数没有 <code>self</code> 的函数。</p>
<p>构造函数的写法：不包含 <code>self</code> 即可。</p>
<p>Rust 中有一个约定俗成的规则，使用 <code>new</code> 来作为构造器的名称，出于设计上的考虑，Rust 特地没有用 <code>new</code> 作为关键字。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> {</span><br><span class="line">    width: <span class="type">i32</span>,</span><br><span class="line">    height: <span class="type">i32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(width: <span class="type">i32</span>, height: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Rect {</span><br><span class="line">        Rect { width, height }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rect::<span class="title function_ invoke__">new</span>(<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="多个-impl-定义">多个 impl 定义</h4>
<p>Rust 允许为一个结构体定义多个 <code>impl</code> 块，目的是提供更多的灵活性和代码组织性。</p>
<ul>
<li>例如当方法多了后，可以把相关的方法组织在同一个 <code>impl</code> 块中。</li>
</ul>
<h4 id="为枚举实现方法">为枚举实现方法</h4>
<p>枚举可以像结构体一样，实现方法。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(dead_code)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">WeekDays</span> {</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">WeekDays</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_day_name</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> {</span><br><span class="line">            WeekDays::Monday =&gt; <span class="string">"Monday"</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            WeekDays::Tuesday =&gt; <span class="string">"Tuesday"</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            WeekDays::Wednesday =&gt; <span class="string">"Wednesday"</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            WeekDays::Thursday =&gt; <span class="string">"Thursday"</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            WeekDays::Friday =&gt; <span class="string">"Friday"</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">day</span> = WeekDays::Friday;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"今天是 {}"</span>, day.<span class="title function_ invoke__">get_day_name</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="泛型和特征">泛型和特征</h3>
<h4 id="泛型-generics">泛型 Generics</h4>
<p>当出现需求：用同一功能的函数处理不同类型的数据，例如两个数的加法，无论是整数还是浮点数，甚至是自定义类型，都能进行支持。</p>
<ul>
<li>C++ 中的模板函数就是一种解决方法。</li>
</ul>
<p><em>泛型怎么不是一种多态呢。</em></p>
<p>Rust 给出的解决方案是：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a: T, b: T) <span class="punctuation">-&gt;</span> T {</span><br><span class="line">    a + b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">"{}, {}, {}"</span>,</span><br><span class="line">        <span class="title function_ invoke__">add</span>(<span class="number">1i8</span>, <span class="number">2i8</span>),       <span class="comment">// 3</span></span><br><span class="line">        <span class="title function_ invoke__">add</span>(<span class="number">1.2f32</span>, <span class="number">2.3f32</span>), <span class="comment">// 3.5</span></span><br><span class="line">        <span class="title function_ invoke__">add</span>(<span class="number">20</span>, <span class="number">30</span>)          <span class="comment">// 50</span></span><br><span class="line">    );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>T</code> 就是泛型参数。</li>
<li><code>std::ops::Add&lt;Output = T</code> 为对 <code>T</code> 进行限制，因为不是所有的 <code>T</code> 类型都能进行相加。</li>
</ul>
<h5 id="结构体中使用泛型">结构体中使用泛型</h5>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; {</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point { x: <span class="number">1</span>, y: <span class="number">2</span> };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point { x: <span class="number">3.0</span>, y: <span class="number">4.0</span> };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>需要提前声明泛型参数 <code>Point&lt;T&gt;</code>。</li>
<li><code>x</code> 和 <code>y</code> 字段时相同的类型。</li>
</ul>
<p>当然可以不止一个泛型参数：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T, U&gt; {</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="枚举中使用泛型">枚举中使用泛型</h5>
<p>很明显，<code>Option</code> 中过就有一个泛型参数 <code>T</code>。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; {</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>还有一个：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; {</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这个枚举主要用于函数返回值，<code>Result</code> 关注的主要是值的正确性。</li>
</ul>
<h5 id="方法中使用泛型">方法中使用泛型</h5>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span>&lt;T&gt; {</span><br><span class="line">    width: T,</span><br><span class="line">    height: T,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Rect&lt;T&gt; {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T {</span><br><span class="line">        &amp;<span class="keyword">self</span>.width</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用泛型参数前，需要提前声明，如 <code>impl&lt;T&gt;</code>。</li>
<li><code>impl</code> 处的 <code>Rect&lt;T&gt;</code> 不再是泛型声明，而是一个完整的结构体类型。</li>
</ul>
<h6 id="为具体的泛型类型实现方法">为具体的泛型类型实现方法</h6>
<p>把 <code>T</code> 换成特定的具体类型：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span>&lt;T, U&gt; {</span><br><span class="line">    width: T,</span><br><span class="line">    height: U,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span>&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt; {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> {</span><br><span class="line">        <span class="keyword">self</span>.width</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rect {</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">20</span>,</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rect {</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">22.0</span>,</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, rect1.<span class="title function_ invoke__">width</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, rect2.<span class="title function_ invoke__">width</span>()); <span class="comment">// 报错，无该方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="const-泛型">const 泛型</h5>
<p><em>Rust 1.51 版本引入。</em></p>
<p>const 泛型是针对值的泛型。</p>
<p>正好可以用于处理数组长度的问题。</p>
<ul>
<li>数组而言，长度也是类型的一部分。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt;(arr: [T; N]) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:?}"</span>, arr);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>定义一个类型为 <code>[T; N]</code> 的数组，<code>T</code> 是一个基于类型的泛型参数；而 <code>N</code> 是一个基于值的泛型参数，用来代替数组的长度。</li>
</ul>
<h5 id="泛型的性能">泛型的性能</h5>
<p>在 Rust 中泛型是零成本的抽象，意味着在使用泛型时，完全不用担心性能上的问题。</p>
<ul>
<li>实际上是损失了编译速度和增大了最终生成文件的大小。</li>
</ul>
<p>Rust 通过在编译时进行泛型代码的单态化来保证效率。</p>
<ul>
<li>单态化：将通用代码转换为特定代码的过程。</li>
<li>编译器的工作与创建泛型函数的步骤相反。</li>
</ul>
<p>对于程序员而言，使用泛型可以编写不重复的代码，而 Rust 将会为每一个实例编译其特定类型的代码。</p>
<h4 id="特征-trait">特征 Trait</h4>
<p>特征定义了<strong>一组可以被共享的行为：只要实现了特征，就能使用这组行为</strong>。</p>
<h5 id="定义特征">定义特征</h5>
<p>定义特征：把一些方法组合在一起。</p>
<ul>
<li>目的是定义一个实现某些目标所必需的行为的集合。</li>
</ul>
<p>举个例子，在数据中有小说和日记等内容载体，希望对相应的内容进行总结。那么总结这个行为就是共享的，可以都用一个特征：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用 <code>trait</code> 关键字声明一个特征，<code>Summary</code> 是特征名。</li>
<li>大括号中定义了该特征的所有方法。
<ul>
<li>特征不定义行为具体是怎么样的，因此使用函数签名。</li>
<li>每一个实现这个特征的类型都需要具体实现该特征的相应方法，编译器也会确保任何实现 <code>Summary</code> 特征的类型都拥有与这个签名的定义完全一致的 <code>summarize</code> 方法。</li>
</ul>
</li>
</ul>
<h5 id="为类型实现特征">为类型实现特征</h5>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Novel</span> {</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Diary</span> {</span><br><span class="line">    <span class="keyword">pub</span> date: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Novel</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"{} by {}"</span>, <span class="keyword">self</span>.title, <span class="keyword">self</span>.author)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Diary</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"Diary for {}"</span>, <span class="keyword">self</span>.date)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = Novel {</span><br><span class="line">        title: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Dracula"</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"Bram Stoker"</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">"Bram Stoker's classic novel about a bloodthirsty master of the night."</span>,</span><br><span class="line">        ),</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">diary</span> = Diary {</span><br><span class="line">        date: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"2014-01-02"</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"A record of my daily life."</span>),</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Novel: {:#?}"</span>, novel);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Diary: {:#?}"</span>, diary);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="特征定义与实现的位置">特征定义与实现的位置</h6>
<p><em>孤儿规则</em></p>
<p>上述代码中，<code>Summary</code> 被定义为公开的 <code>pub</code>，所以只需要引入到包中，就可使用该特征。</p>
<p>关于特征实现与定义的位置：<strong>如果想要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> 或者 <code>T</code> 至少有一个是在当前作用域中定义的</strong>。</p>
<p>这样确保其他人编写的代码不会破坏自己的代码。</p>
<h6 id="默认实现">默认实现</h6>
<p>在特征中定义具有默认实现的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="string">"Reading..."</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>还有，默认实现允许调用相同特征中的其他方法，哪怕这些方法没有默认实现：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">simple_summary</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{}"</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">simple_summary</span>());</span><br><span class="line">        <span class="string">"Reading..."</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Novel</span> {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">simple_summary</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> {</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"{}"</span>, <span class="keyword">self</span>.content)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>那么通过上述代码，<code>Novel</code> 的实例可以通过调用 <code>summarize</code> 方法间接调用了 <code>simple_summary</code> 方法。</li>
</ul>
<h5 id="使用特征作为函数参数">使用特征作为函数参数</h5>
<p>先定义一个函数，使用特征作为函数参数：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>impl Summary</code> 表示实现了 <code>Summary</code> 特征的 <code>item</code> 参数。</li>
<li>可以使用任何实现了 <code>Summary</code> 特征的类型作为该函数的参数，同时在函数体内，还可以调用该特征的方法。</li>
</ul>
<h5 id="特征约束">特征约束</h5>
<p>通过特征约束一些变量类型。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) {</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{}"</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>T: Summary</code> 被称为特征约束。</li>
</ul>
<p>特征约束的表达很奇妙，比如；</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item1: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) {}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>函数的两个参数可以是实现了 <code>Summary</code> 特征的不同的类型。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: SUmmary&gt;(item1: &amp;T, item2: &amp;T) {}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>函数的两个参数都必须是实现了 <code>Summary</code> 特征的相同的类型。</li>
</ul>
<h6 id="多重约束">多重约束</h6>
<p>可以指定多个约束条件：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + <span class="built_in">Send</span>)) {}</span><br></pre></td></tr></tbody></table></figure>
<p>或</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + <span class="built_in">Send</span>&gt;(item: &amp;T) {}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>T: Summary + Send</code> 表示 <code>T</code> 必须同时实现 <code>Summary</code> 和 <code>Send</code> 特征。</li>
</ul>
<h6 id="where-约束">Where 约束</h6>
<p>当特征约束变得很多时，使用 <code>where</code> 进行一些形式上的改进：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fun</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Send</span> + <span class="built_in">Clone</span>,</span><br><span class="line">    U: <span class="built_in">Clone</span> + Summary,</span><br><span class="line">{...}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="例-找最大值">例-找最大值</h6>
<p>方式一：使用特征约束，且使用引用方式。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_1</span>&lt;T: <span class="built_in">PartialOrd</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() {</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest {</span><br><span class="line">            largest = item;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    largest</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>PartialOrd</code> 特征可以用于比较两个值。</li>
</ul>
<p>方法二：使用特征约束，使得值具有 <code>Copy</code> 特征。</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_2</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() {</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest {</span><br><span class="line">            largest = item;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h6 id="特征约束有条件地实现方法或特征">特征约束有条件地实现方法或特征</h6>
<p>特征约束，可以在指定类型 + 指定特征的条件下去实现方法：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; {</span><br><span class="line">        x: T,</span><br><span class="line">        y: T,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> {</span><br><span class="line">            <span class="keyword">Self</span> { x, y }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; {</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) {</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y {</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"The largest member is x = {}"</span>, <span class="keyword">self</span>.x);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"The largest member is y = {}"</span>, <span class="keyword">self</span>.y);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>只有同时实现了 <code>Display</code> 和 <code>PartialOrd</code> 特征的类型 <code>T</code>，才可以调用 <code>cmp_display</code> 方法。</li>
</ul>
<h5 id="函数返回中的-impl-trait">函数返回中的 impl Trait</h5>
<p>可以通过 <code>impl Trait</code> 来说明一个函数返回了一个类型，该类型实现了某个特征：</p>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ret_summary</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> {</span><br><span class="line">    Novel {</span><br><span class="line">        title: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"a"</span>),</span><br><span class="line">        author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"b"</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">"c"</span>),</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>Novel</code> 实现了 <code>Summary</code> 特征，所以可以用它作为返回值。</li>
<li><code>ret_summary</code> 返回一个实现了 <code>Summary</code> 特征的类型，但不知道具体什么类型。</li>
</ul>
<p><em>可能在数据类型十分复杂，不知道怎么声明，就可以使用这种返回类型。如闭包和迭代器的类型就是很复杂。</em></p>
<p>但是这种返回值只能有一种具体的类型，不能模棱两可。</p>
<ul>
<li>即一个分支下返回实现了某特征的 A 类型，而另一个分支又返回实现了某特征的 B 类型。这种情况是拒绝的。</li>
</ul>
<h5 id="通过-derive-派生特征">通过 derive 派生特征</h5>
<p>形如 <code>#[derive(Debug)]</code> 的代码，是一种特征派生语法。</p>
<p><code>derive</code> 派生出来的是 Rust 默认提供的特征。</p>
<p>更多见<a target="_blank" rel="noopener" href="https://course.rs/appendix/derive.html">派生特征</a>。</p>
<h5 id="调用方法需要引入特征">调用方法需要引入特征</h5>
<p><strong>如果要使用一个特征的方法，那么需要将该特征引入当前的作用域中。</strong></p>
<p><em>Rust 把最常用的标准库中的特征通过 <code>std::prelude</code> 模块提前引入到当前作用域中。</em></p>
<h5 id="综合例子">综合例子</h5>
<ul>
<li>自定义类型实现加法操作。</li>
<li>自定义类型实现打印输出。</li>
</ul>
<figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::{fmt::Display, ops::Add};</span><br><span class="line"></span><br><span class="line"><span class="comment">//限制类型 T 必须实现了 Add 特征，否则无法进行 + 操作</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span>&lt;T: Add&lt;T, Output = T&gt;&gt; {</span><br><span class="line">    real: T,</span><br><span class="line">    imag: T,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 Complex&lt;T: Add&lt;T, Output = T&gt;&gt; 实现 Add 特征</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Add&lt;T, Output = T&gt;&gt; Add <span class="keyword">for</span> <span class="title class_">Complex</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Complex&lt;T&gt;;</span><br><span class="line">    <span class="comment">// 定义了一个类型别名 Output</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, p: Complex&lt;T&gt;) <span class="punctuation">-&gt;</span> Complex&lt;T&gt; {</span><br><span class="line">        Complex {</span><br><span class="line">            real: <span class="keyword">self</span>.real + p.real,</span><br><span class="line">            imag: <span class="keyword">self</span>.imag + p.imag,</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 Complex&lt;T: Add&lt;T, Output = T&gt;&gt; 实现 Display 特征</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Add&lt;T, Output = T&gt; + Display&gt; Complex&lt;T&gt; {</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">print</span>(&amp;<span class="keyword">self</span>) {</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"{} + {}i"</span>, <span class="keyword">self</span>.real, <span class="keyword">self</span>.imag);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: Add&lt;T, Output = T&gt;&gt;(a: T, b: T) <span class="punctuation">-&gt;</span> T {</span><br><span class="line">    a + b</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Complex { real: <span class="number">1</span>, imag: <span class="number">2</span> };</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Complex { real: <span class="number">3</span>, imag: <span class="number">4</span> };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">add</span>(a, b);</span><br><span class="line">    c.<span class="title function_ invoke__">print</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="特征对象-todo">特征对象 Todo</h4>
<h4 id="深入特征-todo">深入特征 Todo</h4>
<h3 id="集合类型-todo">集合类型 Todo</h3>
<h4 id="动态数组-vector">动态数组 Vector</h4>
<h4 id="kv-存储-hashmap">KV 存储 HashMap</h4>
<h3 id="认识生命周期-todo">认识生命周期 Todo</h3>
<h3 id="返回值和错误处理-todo">返回值和错误处理 Todo</h3>
<h3 id="包和模块-todo">包和模块 Todo</h3>
<h4 id="包-crate">包 Crate</h4>
<h4 id="模块-module">模块 Module</h4>
<h4 id="使用-use-引入模块及受限可见性">使用 use 引入模块及受限可见性</h4>
<h3 id="注释和稳定-todo">注释和稳定 Todo</h3>
<h3 id="格式化输出-todo">格式化输出 Todo</h3>
</div><script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-03-04</span>
            
                <span>该篇文章被 Fingsinz</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/Rust/'>
                            Rust
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E7%AC%94%E8%AE%B0/'>
                            笔记
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            ©2023-2024 

            
                

            
                
                    / <a href="/"> Fingsinz&#39;s Space </a>
                

            
                
                    / <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/fingsinz"> 知乎 </a>
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>我在想，时下你所需要的，应该是痛痛快快换个心情，干干脆脆享受人生。</span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
    </body>


</html>